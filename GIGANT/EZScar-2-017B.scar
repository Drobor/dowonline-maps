---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
--EZScar  The easy way to do scar programming
--Version 2.016 Beta - backwards compatible with Winter-Assault
--Tim Young (Programmer), Dre Reding (Lua Reference), Philip Young (Idea Man/Tester)
--Lots of help from the community forums, and some code snipped from there.
---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
--For information on how to customize this for your own maps, read the doc
--that comes with this.  Please keep that document along with all copies
--of EZScar so anyone stumbling across maps can use EZScar also
--
--This script is messageware. You can freely copy, redistribute, change, and use this 
--code, and are encouraged to do so.  If you reuse small portions of the code, please
--mention you used EZScar as a reference.  If you reuse the majority of this code,
--please keep this header and the "message" intact.  The original creators believe 
--that all people should at least have one opportunity to know that God's Word gives 
--direction to an abundant life, regardless of race, upbringing, age, education, 
--or gender. And that there is hope for our lives regardless of the mess we have 
--made of them.
--If you are interested in discovering more about this message, here are two
--websites you can check out:
--  http://powertochange.com
--  http://www.rbc.org/bible-study/answers-to-tough-questions/home.aspx
---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
--All SCAR scripts need these for them to work:  Do not remove
import("ScarUtil.scar")
import("WXPScarUtil.scar")
--import("EZScar-2-016B.scar")
--We do it, just in case it was not already done

--
--The following (until the "do not edit beyond this point") can be snipped
--out and used for the main game script.  You will want to add an
--import("EZScar-[version].scar") up by the other "import" commands.

------------------------------------------------------------------
------- Make your edits here -------------------------------------
------------------------------------------------------------------

--g_GameType: "invasion" or "onslaught"  Currently not used 
g_GameType = "invasion"

--end the game once the last wave is over
g_end_game_after_waves=false

--number of things you need to save before the game is over.  -1 if disabled
g_end_game_when_saved=3

-- g_debug true/false  If set to true, the "enemy" bases will be owned by player 1.  Do this to test base building.
g_debug = false 
g_debug_print = false 

--Do we use exciting awards for kills/deaths/etc?
g_do_awards=false

-- g_DestroyHQ  True|False   If you destroy all the HQs in a base, does the base self-destruct?
g_DestroyHQ = false

--The number of players the map is designed for.  We will compute the difficulty from this
g_MapConfiguredFor = 3

--Automatically recompute the map difficulty based on the number of players who joined
g_AutoRecompute=true

--g_max_locations=#  The number of possible locations for the enemy to spawn at.
--   There should be basic_markers for every location.  Read the "readme" file for information
--   The markers should be like: 1-hq-1, 1-turret-1, 1-military-1, 1-minefield-1, 1-power-1
--    Where the first number is the "location" and the second number is an incremantal count.
--    12-turret-5 is the fifth turret at the location number 12
g_max_locations=14

--If using the eldar and webways, each successive wave comes from the next webway.
--if set to "false", the waves will come from one webway until that one is destroyed
--then it will move to the next
g_cycle_webways=true

--g_WaveDelay = an array of delay times before each wave.  If not enough times are given, the last time
--listed will be used for all the remaining waves.
g_WaveDelay= {
	160, 60, 30 
}

function localinit()
	print("LOCALINIT-start")
--	CreateRule( {"PointTaken", "player", "uncap"}, {"Scatter","player","ScatterMark", limit=3})
--	CreateRule( "Always", {"Scatter","terminators","ScatterMark", morale=true, delay={10,20,30,5}})
--	CreateRule( {"Proximity", "player", "Terminators"}, {"Scatter","player","ScatterMark", morale=true})
--	CreateRule( {"EgroupDestroyed","orbital"}, {"Scatter","player","ScatterMark", morale=true})
--	CreateRule( {"SgroupDestroyed","terminators"}, {"Scatter","player","ScatterMark", morale=true})
--	CreateRule( "Always" , {"Squad","player1", "ScatterMark", "guard_squad_basilisk", "TimGroup", limit=3})
--	CreateRule( "Always" , {"Teleport", "terminators","teleportsource5",{"teleportdest1","teleportdest2"}, message="Zap!"})
--	CreateRule( "Always" , {"Patrol", "othergroup",{"teleportdest1","teleportdest2", "ScatterMark"}})
--	CreateRule( "Always" , {"AddVPlayer",1,"tyranid_race"} )
--	DoItNow({"Base","player", "reverse","default",{"Player1-start","Player3-start","Player4-start"}})
--	print ("starting Terminators group: "..gensgroup("terminators"))
--	DoItNow({"CreateSGroup","player",{"space_marine_squad_scout_advance_sp","terminators"},"newgroupname"})
--	DoItNow({"Summon","newgroupname","ScatterMark"})
	--DoItNow({"Base","player", "reverse","default","Player4-start"})
	--CreateRule( {"PointTaken", "player", "givetanks1"}, {"endgame"})
--	DefineVPlayer( {Location="1", PlayerNum=1, Race="chaos_race"})
--	Objective_Add( { title_id = 18010000, short_desc_id = 18010001, help_tip_id = 18010002 }, true )
	print("LOCALINIT-end")
end

-- g_GamePlay
-- race-names may be one of: "chaos_marine_race" , "eldar_race" ,  "guard_race" 
--      "ork_race" , "space_marine_race" , "necron_race" ,  "tau_race", or "default"
--	"default" will use the race for player2 as is chosen when the map is put together
g_GamePlay = {
--     #wave, race,   #location-on-board, trickle/wave, #difficulty, #squad-cap, #vehicle-cap, #Timer
--	1, "ork_race",  		"1",      "wave-trickle",		1, 	10 ,	3,	10,
--	2, "tau_race",		"2", 	    "wave-trickle",   	1,  	10,	 	10, 	10,
--	2, "tau_race",		"3", 	    "wave-trickle",   	1,  	10,	 	10, 	10,
--	3, "chaos_marine_race",	"1",	    "wave-trickle", 	2, 	15, 		8,	10,
--	3, "chaos_marine_race",	"2",	    "wave-trickle", 	2, 	15, 		8,	10,
--	4, "tau_race", 		"1",      "wave-trickle",   	 2, 	15, 		7,	10,
--	4, "ork_race", 		"2",      "wave-trickle",   	 2, 	10, 		4,	10,
--	4, "chaos_race", 		"3",      "wave-trickle",   	 3, 	5, 		4,	10,
--	5, "default", 	"4",      "wave-trickle",    1, 	10, 		10,	3,
--	5, "necron_race", 	"2",      "wave-trickle",    	2, 	10, 		10,	3,
--	5, "default", 	"3",      "wave-trickle",    3, 	10, 		10,	3,
}

--g_WaveActions
--There are three timeframes.  BEFORE a wave (while the countdown timer is occuring)
--DURING a wave (while there is a single virtual player still alive)
--"NOT" which means all times except "during" the wave specified.
--and ALWAYS which happens during all waves
--TELEPORT will teleport the squads/vehicles of the player mentioned (player or enemy) to the destination when they are in the proximity circle of the marker
--DESTROY will destroy the squads/vehicles of the player mentioned (player or enemy) to the destination when they are in the proximity circle of the marker
--SAVE will destroy the squad listed, displaying a "you have saved them" message
--BUILDING and BUILDING-ONCE will build the specified blueprint at the specified marker.  "once" means at the beginning of the time specified.  Otherwise it will be re-spawned
--SQUAD and SQUAD-ONCE will build the specified squad/vehicle at the specified marker.  "once" means at the beginning of the time specified.  Otherwise it will be re-spawned
--the TIMER is how long it waits after being destroyed before it re-spawns
--note that some of the examples have a | at the end, depicting the option may be left blank
g_WaveActions = {
--g_WaveActions="before|during|not", "wave#", "action", "enemy|player", "marker", "blueprint|dest-marker", timer

--	"before",1,"grant_research","enemy","","eldar_shroud_ability_research",0,
	--"before",1,"building","player","reveal","strategic_point_flag",3,
	--"before",1,"building","player","teleportsource1","strategic_objective_struct",3,
	--"before",1,"building","player","teleportsource2","relic_struct",3,
--	"before",1,"grant_research","enemy","","eldar_ranger_infiltration_research",0,
--	"before",1,"grant_research","enemy","","eldar_farseer_ability_research",0,
--	"before",1,"grant_research","enemy","","eldar_farseer_ability_research_2",0,
--	"before",1,"grant_research","enemy","","eldar_farseer_ability_research_3",0,
--	"before",1,"grant_research","enemy","","eldar_research_farseerhealth_1",0,
--	"before",1,"grant_research","enemy","","eldar_research_farseerhealth_2",0,
--	"before",1,"grant_research","enemy","","eldar_fleet_of_foot_research",0,
--	"before",1,"grant_research","player","","all",0,
--	"before",1,"restrict-ai","enemy","off","",0,
--	"before",1,"destroy","enemy","BaseDestroy","",0,
--	"always",1,"resources","player","all",10000,30,


--	"before",1,"base","player1","21","default",5
--	"before|during|not|always",wave,"teleport","player|enemy","source-marker","destination-marker",0,
--	"before|during|not|always",wave,"destroy","player|enemy","source-marker","squad-to-destroy",10,
--	"before|during|not|always",wave,"save","player|enemy","source-marker","squad-to_save",0,
--	"before|during|not|always",wave,"squad-once","player|enemy","destination","squad-blueprint",5,
--	"before|during|not|always",wave,"squad","player|enemy","destination","squad-blueprint",5,
--	"before|during|not|always",wave,"building-once","player|enemy","destination","building-blueprint",5,
--	"before|during|not|always",wave,"building","player|enemy","destination","building-blueprint",5,
--	"before|during|not|always",wave,"fow","on|off","marker|egroup|sgroup|","",0,
--	"before|during|not|always",wave,"fow-once","on|off","marker|egroup|sgroup|","",0,
--	"before|during|not|always",wave,"restrict-ai","enemy","on|off","",0,
--	"before|during|not|always",wave,"message","","[put your message here]|random","",0,
--	"before|during|not|always",wave,"command","attack","squad|", "squad|marker|player|", 30,
--	"before|during|not|always",wave,"resources","player|enemy","req|power|ork", "#number", 30,
--	"before|during|not|always",wave,"resources-once","player|enemy","req|power|ork", "#number", 30
--	"before|during|not|always",wave,"grant_research","player|enemy","research", "#number", 30
--	"before|during|not|always",wave,"revoke_research","player|enemy","research", "#number", 30
--	"before|during|not|always",wave,"base","player{1,3,4,5,6,7}|enemy","location#", "race", 30
--	"before|during|not|always",wave,"compact-base","player{1,3,4,5,6,7}|enemy","location#", "race", 30
--	"before|during|not|always",wave,"reverse-compact-base","player{1,3,4,5,6,7}|enemy","location#", "race", 30
}




	

--g_Bonus -- give the player a group of *something* when they capture a point
--The first part is a point that is an "egroup" (created with the map editor) containing a point (strategic/critical/relic)
--Then comes the "who gets it" part.  ENEMY, PLAYER, or ANY
-- the "gift" is an "egroup" that exists at the beginning of the game and owned by the world, a squad/vehicle blueprint
-- or one of the keywords ENABLE, DISABLE, PREFER-ENABLE, or PREFER-DISABLE (each in lower-case)
--To have multiple gifts when a point is taken, make another line with the same point
--eg:"SpacemarinePoint", "player","SpacemarineBuildings", "",1,0			--Give the player who takes the point the egroup "SpacemarineBuildings"
--   "SpacemarinePoint", "any","space_marine_squad_predator", "gifts",0.9,10	--Give anyone who takes the point a predator at .9 strength.  When that is destroyed, give him another one 10 seconds later
--   "CivilianPoint","player","guard_squad_civilian_male_a","ToSave",0.3,60  -- Spawn a civilian that needs saving (the ToSave group-name will be used in the "save" WaveActions)
--HEALTH is the % health an item is spawned with.  0 is dead, 1 is fully-alive.  0.5 is half-dead
--the timer is how many seconds after the previous one was destroyed before the new one is re-spawned (for vehicles/squads)
g_Bonus = {
--point,"player|enemy|any", "egroup|sgroup|squad|enable|disable|prefer-enable|prefer-disable|endgame|kill-vplayer","groupname", health|rulenum|vplayer, timer
--	"GiveTank","player","space_marine_squad_predator_advance_sp","",1,10,
}

function end_game()
	--This is a function that tells what to do for the end of game
	--g_end_time begins as 1 and counts upward, 1 for each second
	--The gametime() function returns "minutes: ## seconds: ##" of gametime
	if g_end_time <= 1 then
		 W40k_Letterbox(true,2)
	elseif g_end_time <= 3 then
		W40k_ShowSystemMessage("Arggg!  You have beaten me!")
	elseif g_end_time <= 6 then
		W40k_ShowSystemMessage("But I will be back again!")
	elseif g_end_time <= 9 then
		W40k_ShowSystemMessage("And then...  Beware!")
	elseif g_end_time <= 12 then
		--This last one just pauses for a sec before the end of game
		W40k_ShowSystemMessage("")
		W40k_Letterbox(false,2)
	else
		--Always end with killing the player2 just in case...
		Player_Kill( g_Player2 )
	end
end


---------------------
-- Here you can make your own mix of races
-- One building-set that needs to be destroyed
-- and your own selected bunch of squads that will be spawned
-- This gives you a lot of variety at your disposal

-- custom1_buildings= "Building_blueprint", "type", HowManyPerBase_drop#

custom1_buildings =
{
	"guard_hq","hq",6,
	"guard_infantry","military",8,
	"guard_mines","minefield",20,
	"guard_plasma_generator","power",10,
	"guard_turret_heavy_bolter","turret",30,
	"guard_turret_missile_launcher_sp","turret",30 
}

custom1_squads=
{
	"guard_heavy_weapons_team_squad","squad",0,4,4,
	"guard_squad_assassin_advance_sp","squad",0,1,2,
	"guard_squad_command_squad","squad",0,1,2,
	"guard_squad_commissar_advance_sp","squad",5,4,0,
	"guard_squad_guardsmen","squad",20,10,0,
	"guard_squad_guardsmen_advance_sp","squad",0,0,1,
	"guard_squad_kasrkin","squad",0,1,5,
	"guard_squad_kasrkin_advance_single_sp","squad",0,0,2,
	"guard_squad_ogryns_advance_sp","squad",0,0,3,
	"guard_squad_priest_advance_sp","squad",1,0,1,
	"guard_squad_psyker_advance_sp","squad",1,0,1,
	"guard_squad_hellhound","vehicle",0,1,0,
	"guard_squad_baneblade","vehicle",0,0,0,
	"guard_squad_basilisk","vehicle",0,0,0,
	"guard_squad_basilisk_stronghold_sp","vehicle",0,0,0,
	"guard_squad_chimera","vehicle",0,2,2,
	"guard_squad_lemanruss","vehicle",0,1,2,
	"guard_squad_sentinel","vehicle",0,2,0
}

custom2_buildings =
{
	"guard_hq","hq",3,
	"guard_mechanized","military",3,
	"guard_mines","minefield",10,
	"guard_plasma_generator","power",10,
	"guard_turret_heavy_bolter","turret",20,
	"guard_turret_missile_launcher_sp","turret",20 
}

custom2_squads=
{
	"guard_heavy_weapons_team_squad","squad",10,1,4,
	"guard_squad_assassin_advance_sp","squad",0,0,3,
	"guard_squad_command_squad","squad",0,0,0,
	"guard_squad_commissar_advance_sp","squad",0,0,0,
	"guard_squad_guardsmen","squad",0,0,0,
	"guard_squad_guardsmen_advance_sp","squad",0,0,0,
	"guard_squad_kasrkin","squad",0,0,1,
	"guard_squad_kasrkin_advance_single_sp","squad",0,0,1,
	"guard_squad_ogryns_advance_sp","squad",0,0,2,
	"guard_squad_priest_advance_sp","squad",0,0,1,
	"guard_squad_psyker_advance_sp","squad",0,0,1,
	"guard_squad_hellhound","vehicle",0,0,0,
	"guard_squad_baneblade","vehicle",0,0,1,
	"guard_squad_basilisk","vehicle",10,1,5,
	"guard_squad_basilisk_stronghold_sp","vehicle",0,0,3,
	"guard_squad_chimera","vehicle",0,0,0,
	"guard_squad_lemanruss","vehicle",0,1,2,
	"guard_squad_sentinel","vehicle",0,1,1
}


--- Use the top portion of this file for the template------------
-- CUT HERE------------------------------------------------------
-----------------------------------------------------------------
-----------------------------------------------------------------
----  You should not need to edit beyond this point -------------
-----------------------------------------------------------------
-----------------------------------------------------------------

space_marine_buildings =
{
	"space_marine_ability_building", "military", 1,
	"space_marine_armoury",  "military", 1,
	"space_marine_barracks",  "military", 2, 
	"space_marine_drop_pod_building", "none", 0, 
	"space_marine_generator", "power", 10,
	"space_marine_hq", "hq", 3,
	"space_marine_interface_relay", "none",0, 
	"space_marine_listening_post", "post", 20, 
	"space_marine_mine_field", "minefield", 30,
	"space_marine_orbital_relay",  "military", 1,
	"space_marine_orbital_relay_stronghold_sp", "none", 0, 
	"space_marine_single_player_only_drop_pod_building", "none", 0,
	"space_marine_sp_thunderhawk","none", 0, 
	"space_marine_thermo_generator", "thermo", 1, 
	"space_marine_turret_bolter", "turret", 10,
	"space_marine_turret_missile_sp","turret", 10, 
	"space_marine_vehicle_building",   "military", 2 
}

chaos_buildings =
{
	"chaos_armoury","military",1,
	"chaos_greater_sacrificial_circle","military",1,
	"chaos_hq","hq",3,
	"chaos_listening_post","post",20,
	"chaos_machine_pit","military",1,
	"chaos_mine_field","minefield",5,
	"chaos_plasma_generator","power",1,
	"chaos_sacrificial_circle","military",1,
	"chaos_single_player_only_sacrificial_circle","none",0,
	"chaos_temple","military",2,
	"chaos_thermo_plasma_generator","thermo",0,
	"chaos_turret_bolter","turret",10,
	"chaos_turret_missile_launcher_sp","turret",10
}

eldar_buildings =
{
	"eldar_advanced_warp_generator","thermo",0,
	"eldar_aspect_portal","military",1,
	"eldar_hq","hq",3,
	"eldar_hq_sp_msoe05","",1,
	"eldar_listening_post","post",20,
	"eldar_mine_field","minefield",1,
	"eldar_soul_shrine","military",1,
	"eldar_support_platform_cannon_sp","turret",1,
	"eldar_support_platform_scatterlaser","turret",15,
	"eldar_support_portal","turret",15,
	"eldar_warp_generator","power",1,
	"eldar_webway_gate","military",1,
	"eldar_webway_gate","webway",1
}

ig_buildings =
{
	"guard_hq","hq",3,
	"guard_infantry","military",3,
	"guard_listening_post","post",20,
	"guard_mars_pattern","military",1,
	"guard_mechanized","military",3,
	"guard_mines","minefield",10,
	"guard_plasma_generator","power",10,
	"guard_tactica","military",1,
	"guard_thermo_plasma","thermo",1,
	"guard_turret_heavy_bolter","turret",20,
	"guard_turret_missile_launcher_sp","turret",20
}
	
necron_buildings =	
{
	"monolith","hq",3,
	"necron_energy_core","military",10,
	"necron_forbidden_archive","military",1,
	"necron_greater_summoning_core","military",1,
	"necron_listening_post","post",20,
	"necron_plasma_generator","power",10,
	"necron_summoning_core","military",1,
	"necron_thermoplasma_generator","thermo",1,
	"necron_tunnel","none",1,
	"necron_turret","turret",10,
	"necron_turret_missile_sp","turret",10
}

ork_buildings =
{
	"ork_bigger_generator","thermo",1,
	"ork_boy_hut","military",2,
	"ork_generator","power",8,
	"ork_gork_totem","post",20,
	"ork_hq","hq",3,
	"ork_mek_shop","military",2,
	"ork_mine_field","minefield",30,
	"ork_pile_o_guns","military",1,
	"ork_waagh_banner","turret",10,
	"ork_waagh_banner_missile_sp","turret",10,
	"ork_waagh_banner_turret_sp","turret",10,
}

tau_buildings =
{
	"tau_barracks","military",1,
	"tau_hq","hq",3,
	"tau_kroot_nest","minefield",1,
	"tau_listening_post","post",20,
	"tau_missile_turret_sp","turret",10,
	"tau_plasma_generator","power",8,
	"tau_research_building","military",1,
	"tau_shrine_of_kauyon","military",1,
	"tau_shrine_of_montka","military",1,
	"tau_shrine_of_purpose","military",1,
	"tau_thermoplasma_generator","thermo",1,
	"tau_turret_sp","turret",10,
	"tau_vehicle_building","military",1
}
dark_eldar_buildings =
{
	"dark_eldar_haemonculus_laboratory","military",1,
	"dark_eldar_hall_of_blood","military",1,
	"dark_eldar_hq","hq",3,
	"dark_eldar_hq_sp_dxp3","",0,
	"dark_eldar_hq_sp_dxp3_player","",0,
	"dark_eldar_listening_post","post",20,
	"dark_eldar_plasma_generator","power",7,
	"dark_eldar_prisoner_cage_sp_dxp3","",1,
	"dark_eldar_skimmer_shop","military",1,
	"dark_eldar_slave_caravel","military",5,
	"dark_eldar_soul_cage","military",1,
	"dark_eldar_soul_cage_sp_dxp3","",1,
	"dark_eldar_thermo_plasma","thermo",1,
	"dark_eldar_wych_cult_arena","military",1,
}
sisters_buildings = 
{
	"sisters_holy_reliquary","military",1,
	"sisters_hq","hq",3,
	"sisters_hq_sp_dxp3_player","",1,
	"sisters_infantry","military",3,
	"sisters_listening_post","post",20,
	"sisters_mines","minefield",20,
	"sisters_plasma_generator","power",7,
	"sisters_sanctuary","military",1,
	"sisters_shrine","military",1,
	"sisters_shrine_sp_dxp3","",1,
	"sisters_thermo_plasma","thermo",1,
	"sisters_turret_flamer","turret",10,
	"sisters_vehicle_building","military",2,
}

tyranid_buildings =
{ "tyranids_adv_magma_vent","thermo",1,
 "tyranids_capillary_tower","military",1,
 "tyranids_digest_pool","military",1,
 "tyranids_hq","hq",1,
 "tyranids_spore_chimney","post",1,
 "tyranids_xeno_hive","military",1,
 "tyranids_gaunt_hive","military",1,
 "tyranids_relic_hive","military",1,
 "tyranids_warrior_hive","military",1
}


--For the vehicle/squad we have the following information:
--vehicle/squad name (used for spawning)
--Is it  avehicle or squad
--how many of them should be in a squad of easy, medium, or hard level
space_marine_squads =
{
	"space_marine_squad_apothecary","squad", 1, 1, 1,
	"space_marine_squad_apothecary_veteran_stronghold_sp","squad", 0, 0, 0,
	"space_marine_squad_assault","squad", 1, 1, 0,
	"space_marine_squad_assault_sp","squad", 0, 1, 1,
	"space_marine_squad_assault_veteran_sp","squad", 0, 0, 1,
	"space_marine_squad_assault_veteran_stronghold_sp","squad", 0, 0, 1,
	"space_marine_squad_chaplain","squad", 0, 0, 0,
	"space_marine_squad_chaplain_advance_sp","squad", 0, 0, 0,
	"space_marine_squad_chaplain_stronghold_sp","squad", 0, 0, 0,
	"space_marine_squad_dreadnought","vehicle", 1, 1, 2,
	"space_marine_squad_dreadnought_advance_sp","vehicle", 0,1, 2,
	"space_marine_squad_dreadnought_hellfire","vehicle", 0, 1, 0,
	"space_marine_squad_dreadnought_hellfire_advance_sp","vehicle", 0, 0, 0,
	"space_marine_squad_force_commander","squad", 0, 1, 0,
	"space_marine_squad_force_commander_advance_sp","squad", 0, 0, 1,
	"space_marine_squad_grey_knights","squad", 0, 1, 0,
	"space_marine_squad_land_raider","vehicle", 0, 0, 1,
	"space_marine_squad_land_speeder","vehicle", 2, 0, 0,
	"space_marine_squad_land_speeder_advance_sp","vehicle", 0, 1, 1,
	"space_marine_squad_librarian","squad", 0, 0, 0,
	"space_marine_squad_librarian_advance_sp","squad", 0, 0, 0,
	"space_marine_squad_librarian_stronghold_sp","squad", 0, 0, 0,
	"space_marine_squad_predator","vehicle", 0, 1, 0,
	"space_marine_squad_predator_advance_sp","vehicle", 0, 0, 2,
	"space_marine_squad_rhino","vehicle", 2, 0, 0,
	"space_marine_squad_scout","squad", 3, 0, 0,
	"space_marine_squad_scout_advance_sp","squad", 0, 1, 0,
	"space_marine_squad_servitor","servitor", 1, 1, 1,
	"space_marine_squad_servitor_sp","servitor", 0, 0, 0,
	"space_marine_squad_skull_probe","squad", 1, 1, 1,
	"space_marine_squad_sp_force_commander","squad", 0, 0, 0,
	"space_marine_squad_sp_metiel","squad", 0, 0, 0,
	"space_marine_squad_tactical","squad", 1, 2, 4,
	"space_marine_squad_terminator","squad", 0, 0, 1,
	"space_marine_squad_terminator_assault","squad", 0, 0, 1,
	"space_marine_squad_terminator_assault_veteran_sp","squad", 0, 0, 1,
	"space_marine_squad_terminator_assault_veteran_stronghold_sp","squad", 0, 0, 1,
	"space_marine_squad_terminator_veteran_sp","squad", 0, 0, 0,
	"space_marine_squad_terminator_veteran_stronghold_sp","squad", 0, 0, 0,
	"space_marine_squad_thunderhawk","vehicle", 0, 0, 0,
	"space_marine_squad_veteran_stronghold_sp","vehicle", 0, 0, 0,
	"space_marine_squad_tempest","vehicle",0,1,2,
	"space_marine_squad_whirlwind","vehicle", 0, 0, 1
}

sisters_squads=
{
	"sisters_squad_ascension_angel","squad", 0, 0, 0,
	"sisters_squad_assassin","squad", 0, 1, 1,
	"sisters_squad_assassin_hg_dxp3","squad", 0, 0, 0,
	"sisters_squad_battle_sister","squad", 3, 2, 1,
	"sisters_squad_battle_sister_hg_dxp3","squad", 0, 0, 0,
	"sisters_squad_battle_sister_sp_dxp3_prisoner","squad", 0, 0, 0,
	"sisters_squad_canoness","squad", 0, 1, 0,
	"sisters_squad_canoness_advance_sp","squad", 0, 0, 1,
	"sisters_squad_celestian","squad", 0, 1, 1,
	"sisters_squad_celestian_hg_dxp3","squad", 0, 0, 0,
	"sisters_squad_celestian_sp_dxp3_prisoner","squad", 0, 0, 0,
	"sisters_squad_confessor","squad", 0, 0, 1,
	"sisters_squad_confessor_hg_dxp3","squad", 0, 0, 0,
	"sisters_squad_exorcist_tank","vehicle", 0, 1, 0,
	"sisters_squad_exorcist_tank_sp_dxp3","vehicle", 0, 0, 0,
	"sisters_squad_immolator_tank","vehicle", 0, 1, 2,
	"sisters_squad_lightning","vehicle", 0, 1, 2,
	"sisters_squad_living_saint","squad", 0, 0, 1,
	"sisters_squad_living_saint_sp_dxp3","squad", 0, 0, 0,
	"sisters_squad_missionary","squad", 2, 1, 0,
	"sisters_squad_missionary_hg_dxp3","squad", 0, 0, 0,
	"sisters_squad_missionary_sp_dxp3_prisoner","squad", 0, 0, 0,
	"sisters_squad_penitent_engine","vehicle", 0, 1, 1,
	"sisters_squad_penitent_engine_hg_dxp3","vehicle", 0, 0, 0,
	"sisters_squad_repentia","squad", 0, 1, 2,
	"sisters_squad_repentia_mistress_hg_dxp3","squad", 0, 0, 1,
	"sisters_squad_repentia_sp_dxp3_prisoner","squad", 0, 0, 0,
	"sisters_squad_rhino","vehicle", 1, 0, 0,
	"sisters_squad_rhino_sp_dxp3","vehicle", 0, 0, 0,
	"sisters_squad_seraphim","squad", 1, 2, 2,
	"sisters_squad_seraphim_hg_dxp3","squad", 0, 0, 0,
	"sisters_squad_seraphim_sp_dxp3","squad", 0, 0, 0,
	"sisters_squad_servitor","squad", 0, 0, 0,
	"sisters_squad_servitor_hg_dxp3","squad", 0, 0, 0,
	"sisters_squad_lightning","vehicle",0,0,2,
	"sisters_squad_veteran_superior_hg_dxp3","squad", 0, 0, 0,
}

tyranid_squads=
{
	"tyranids_squad_broodlord","squad",0,0,0,  --2
	"tyranids_squad_genestealer","squad",0,0,0,
	"tyranids_squad_genestealer_max","squad",0,0,0,
	"tyranids_squad_hormagaunt","squad",5,0,0,
	"tyranids_squad_hormagaunt_max","squad",1,0,0,
	"tyranids_squad_lictor","squad",0,0,0, --1
	"tyranids_squad_ripperswarm","squad",5,0,0,
	"tyranids_squad_spinegaunt","squad",2,0,0,
	"tyranids_squad_spinegaunt_max","squad",0,0,0,
	"tyranids_squad_termagant","squad",2,0,0,
	"tyranids_squad_termagant_max","squad",0,0,0,
	"tyranids_squad_trygon","squad",0,0,0, --3
	"tyranids_squad_warrior","squad",2,0,0,
	"tyranids_squad_zoanthropes","squad",2,0,0,
}

dark_eldar_squads=
{
	"dark_eldar_squad_archon","squad", 0, 1, 1,
	"dark_eldar_squad_archon_hg_dxp3","squad", 0, 0, 0,
	"dark_eldar_squad_beastmaster","squad", 0, 1, 1,
	"dark_eldar_squad_dais_of_destruction","vehicle", 0, 0, 1,
	"dark_eldar_squad_dais_of_destruction_sp_dxp3","vehicle", 0, 0, 0,
	"dark_eldar_squad_fastrepair_sp_dxp3","squad", 0, 0, 0,
	"dark_eldar_squad_haemonculus","squad", 0, 1, 1,
	"dark_eldar_squad_haemonculus_hg_dxp3","squad", 0, 0, 0,
	"dark_eldar_squad_haemonculus_sp_dxp3_prisoner","squad", 0, 0, 0,
	"dark_eldar_squad_hellion","squad", 0, 1, 1,
	"dark_eldar_squad_hellion_leader_hg_dxp3","squad", 0, 0, 1,
	"dark_eldar_squad_hellion_sp_dxp3","squad", 0, 0, 0,
	"dark_eldar_squad_incubus_hg_dxp3","squad", 0, 0, 0,
	"dark_eldar_squad_mandrake","squad", 3, 1, 1,
	"dark_eldar_squad_mandrake_hg_dxp3","squad", 0, 0, 0,
	"dark_eldar_squad_raider","vehicle", 0, 1, 1,
	"dark_eldar_squad_raider_hg_dxp3","vehicle", 0, 0, 0,
	"dark_eldar_squad_raider_sp_dxp3","vehicle", 0, 0, 0,
	"dark_eldar_squad_ravager","vehicle", 0, 1, 1,
	"dark_eldar_squad_raven","vehicle", 1, 0, 0,
	"dark_eldar_squad_reaver","squad", 1, 1, 0,
	"dark_eldar_squad_reaver_hg_dxp3","squad", 0, 0, 0,
	"dark_eldar_squad_reaver_sp_dxp3_prisoner","squad", 0, 0, 0,
	"dark_eldar_squad_scourge","squad", 0, 1, 1,
	"dark_eldar_squad_scourge_hg_dxp3","squad", 0, 0, 0,
	"dark_eldar_squad_scourge_sp_dxp3","squad", 0, 0, 0,
	"dark_eldar_squad_slave","squad", 0, 0, 0,
	"dark_eldar_squad_slave_murdered","squad", 0, 0, 0,
	"dark_eldar_squad_soulstorm","vehicle", 1, 0, 1,
	"dark_eldar_squad_talos","vehicle", 0, 1, 1,
	"dark_eldar_squad_warp_beast","squad", 0, 1, 1,
	"dark_eldar_squad_warp_beast_hg_dxp3","squad", 0, 0, 0,
	"dark_eldar_squad_warrior","squad", 1, 1, 0,
	"dark_eldar_squad_warrior_leader_hg_dxp3","squad", 0, 0, 0,
	"dark_eldar_squad_warrior_sp_dxp3_prisoner","squad", 0, 0, 0,
	"dark_eldar_squad_wych","squad", 0, 1, 1,
	"dark_eldar_squad_wych_leader_hg_dxp3","squad", 0, 0, 0,
	"dark_eldar_squad_ravager","vehicle",0,1,2,
	"dark_eldar_squad_wych_sp_dxp3_prisoner","squad", 0, 0, 0,
}

chaos_squads=
{
	"chaos_marine_squad","squad",1,2,0,
	"chaos_marine_squad_stronghold_sp","squad",0,0,0,
	"chaos_squad_aspiring_champion_advance_sp","squad",0,1,0,
	"chaos_squad_bloodthirster","squad",0,0,0,
	"chaos_squad_cultist","squad",3,0,0,
	"chaos_squad_cultist_advance_sp","squad",0,0,0,
	"chaos_squad_daemon_prince","squad",0,1,1,
	"chaos_squad_daemon_prince_advance_sp","squad",0,0,0,
	"chaos_squad_defiler","squad",0,1,0,
	"chaos_squad_defiler_advance_sp","squad",0,0,0,
	"chaos_squad_horror","squad",1,2,3,
	"chaos_squad_khorne_berserker","squad",0,1,0,
	"chaos_squad_khorne_berserker_advance_sp","squad",0,0,0,
	"chaos_squad_khorne_berserker_sp_elites","squad",0,0,1,
	"chaos_squad_khorne_berserker_sp_msd02","squad",0,0,0,
	"chaos_squad_khorne_berserker_stronghold_sp","squad",0,0,0,
	"chaos_squad_lord","squad",0,1,0,
	"chaos_squad_lord_advance_sp","squad",0,0,1,
	"chaos_squad_lord_sp_msd01","squad",0,0,0,
	"chaos_squad_obliterator","squad",0,0,1,
	"chaos_squad_obliterator_advance_sp","squad",0,0,0,
	"chaos_squad_obliterator_stronghold_sp","squad",0,0,0,
	"chaos_squad_possessed_marine","squad",0,1,0,
	"chaos_squad_possessed_marine_advance_sp","squad",0,0,1,
	"chaos_squad_possessed_marine_stronghold_sp","squad",0,0,0,
	"chaos_squad_predator","vehicle",0,1,0,
	"chaos_squad_predator_advance_sp","vehicle",0,0,1,
	"chaos_squad_raptor","vehicle",1,1,0,
	"chaos_squad_raptor_champion_advance_sp","vehicle",0,0,1,
	"chaos_squad_raptor_stronghold_sp","vehicle",0,0,0,
	"chaos_squad_rhino","vehicle",1,0,0,
	"chaos_squad_slave","squad",1,0,0,
	"chaos_squad_sorcerer","squad",0,1,0,
	"chaos_squad_sorcerer_advance_sp","squad",0,1,0,
	"chaos_squad_sorcerer_stronghold_sp","squad",0,0,0,
	"chaos_squad_sorcerer_torment_sp","squad",0,0,1,
	"chaos_squad_sorceror_nis","squad",0,0,0,
	"chaos_squad_hell_talon","vehicle",0,1,2,
	"chaos_squad_sp_champion","squad",0,0,1
}
eldar_squads=
{
	"eldar_guardian_squad","squad",0,0,0,
	"eldar_harlequin_squad","squad",0,1,1,
	"eldar_squad_avatar","squad",0,0,1,
	"eldar_squad_avatar_stronghold_sp","squad",0,0,0,
	"eldar_squad_banshee_exarch_council","squad",0,0,0,
	"eldar_squad_banshees","squad",0,0,0,
	"eldar_squad_bonesinger","squad",0,1,1,
	"eldar_squad_dark_reaper_exarch_council","squad",0,0,0,
	"eldar_squad_dark_reapers","squad",0,0,0,
	"eldar_squad_dark_reapers_base","squad",0,0,0,
	"eldar_squad_dark_reapers_exarch_sp","squad",0,0,0,
	"eldar_squad_falcon_grav_tank","vehicle",0,1,1,
	"eldar_squad_falcon_grav_tank_advance_sp","vehicle",0,0,0,
	"eldar_squad_farseer","squad",0,1,1,
	"eldar_squad_farseer_advance_sp","squad",0,0,0,
	"eldar_squad_farseer_sp","squad",0,0,0,
	"eldar_squad_farseer_stronghold_sp","squad",0,0,0,
	"eldar_squad_fire_dragon","squad",0,0,0,
	"eldar_squad_fire_dragon_exarch_council","squad",0,0,0,
	"eldar_squad_fire_prism","squad",0,0,0,
	"eldar_squad_grav_platform","vehicle",1,0,0,
	"eldar_squad_grav_platform_brightlance","vehicle",0,0,0,
	"eldar_squad_grav_platform_brightlance_advance_sp","vehicle",0,0,0,
	"eldar_squad_rangers","squad",1,0,0,
	"eldar_squad_rangers_advance_sp","squad",0,0,0,
	"eldar_squad_seer_council","squad",0,0,0,
	"eldar_squad_seer_council_advance_sp","squad",0,0,0,
	"eldar_squad_vypers","squad",0,0,0,
	"eldar_squad_vypers_advance_sp","squad",0,0,0,
	"eldar_squad_warp_spider","squad",1,0,0,
	"eldar_squad_warp_spider_exarch_council","squad",0,0,0,
	"eldar_squad_warp_spider_stronghold_sp","squad",0,0,0,
	"eldar_squad_wraithlord","squad",0,0,0,
	"eldar_squad_wraithlord_advance_sp","squad",0,0,0,
	"eldar_squad_nightwing","vehicle",0,1,2,
	"eldar_squad_nightwing_elite_sp_dxp3","vehicle",0,0,0,
	"sp_eldar_banshee_exarch_squad","squad",0,0,0
}
ig_squads=
{
	"guard_heavy_weapon_team_entrenched_squad_sp","squad",0,0,0,
	"guard_heavy_weapons_team_squad","squad",0,1,4,
	"guard_squad_assassin","squad",0,1,2,
	"guard_squad_assassin_advance_sp","squad",0,0,0,
	"guard_squad_baneblade","vehicle",0,0,1,
	"guard_squad_basilisk","vehicle",0,1,2,
	"guard_squad_basilisk_sp_mso2","vehicle",0,0,0,
	"guard_squad_basilisk_stronghold_sp","vehicle",0,0,0,
	"guard_squad_chimera","vehicle",1,2,2,
	"guard_squad_chimera_sp_test","vehicle",0,0,0,
	"guard_squad_command_squad","squad",0,0,0,
	"guard_squad_command_squad_advance_sp","squad",0,0,0,
	"guard_squad_commissar","squad",0,1,2,
	"guard_squad_commissar_advance_sp","squad",0,0,0,
	"guard_squad_enginseer","squad",0,0,0,
	"guard_squad_enginseer_advance_sp","squad",0,0,0,
	"guard_squad_enginseer_sp_transportable","squad",0,0,0,
	"guard_squad_guardsmen","squad",4,3,4,
	"guard_squad_guardsmen_advance_sp","squad",0,0,0,
	"guard_squad_hellhound","vehicle",0,0,0,
	"guard_squad_hellhound_advance_sp","vehicle",0,0,0,
	"guard_squad_kasrkin","squad",0,1,0,
	"guard_squad_kasrkin_advance_single_sp","squad",0,0,0,
	"guard_squad_kasrkin_advance_sp","squad",0,0,1,
	"guard_squad_lemanruss","vehicle",0,1,0,
	"guard_squad_lemanruss_advance_sp","vehicle",0,0,2,
	"guard_squad_ogryns","squad",0,1,2,
	"guard_squad_ogryns_advance_sp","squad",0,0,0,
	"guard_squad_priest","squad",0,0,0,
	"guard_squad_priest_advance_sp","squad",0,0,0,
	"guard_squad_psyker","squad",0,0,0,
	"guard_squad_psyker_advance_sp","squad",0,0,0,
	"guard_squad_psyker_sp_msdc5","squad",0,0,0,
	"guard_squad_sentinel","vehicle",1,2,2,
	"guard_squad_marauder","vehicle",0,1,2,
	"guard_squad_sentinel_advance_sp","vehicle",0,0,0
}

necron_squads=
{
	"necron_basic_warrior_squad","squad",2,2,3,
	"necron_basic_warrior_squad_advance_sp","squad",0,0,0,
	"necron_builder_scarab_squad","servitor",1,0,0,
	"necron_builder_scarab_squad_advance_sp","servitor",0,0,0,
	"necron_destroyer_squad","vehicle",0,1,2,
	"necron_destroyer_squad_advance_sp","vehicle",0,0,0,
	"necron_flayed_one_squad","squad",0,1,2,
	"necron_flayed_one_squad_advance_sp","squad",0,0,0,
	"necron_heavy_destroyer_squad","vehicle",0,1,2,
	"necron_heavy_destroyer_squad_advance_sp","vehicle",0,0,0,
	"necron_immortal_squad","squad",0,1,2,
	"necron_immortal_squad_advance_sp","squad",0,0,0,
	"necron_lord_destroyer_squad","vehicle",0,1,1,
	"necron_lord_squad","squad",0,1,1,
	"necron_lord_squad_advance_sp","squad",0,0,0,
	"necron_night_bringer","squad",0,0,0,
	"necron_night_bringer_squad_advance_sp","squad",0,0,0,
	"necron_pariah_squad","squad",1,0,0,
	"necron_pariah_squad_advance_sp","squad",0,0,0,
	"necron_restored_monolith_squad","vehicle",0,1,1,
	"necron_scarab_squad","squad",0,0,0,
	"necron_tomb_spyder_squad","vehicle",0,0,1,
	"necron_tomb_spyder_squad_advance_sp","vehicle",0,0,0,
	"necron_wraith_squad","squad",2,1,0,
	"necron_wraith_squad_advance_sp","squad",0,0,0
}

ork_squads=
{
	"ork_flash_gitz_squad","squad",0,1,2,
	"ork_squad_armored_nob","squad",0,1,0,
	"ork_squad_armored_nob_advance_sp","squad",0,0,1,
	"ork_squad_bad_dok","squad",0,1,2,
	"ork_squad_bad_dok_advance_sp","squad",0,0,0,
	"ork_squad_bad_dok_sp_trainer","squad",0,0,0,
	"ork_squad_grot","squad",0,0,0,
	"ork_squad_killa_kan","vehicle",0,1,2,
	"ork_squad_killa_kan_advance_sp","vehicle",0,0,0,
	"ork_squad_looted_tank","vehicle",0,1,1,
	"ork_squad_looted_tank_advance_sp","vehicle",0,0,1,
	"ork_squad_looted_tank_sp","vehicle",0,0,0,
	"ork_squad_mek_boy","squad",0,0,1,
	"ork_squad_mek_boy_advance_sp","squad",0,0,0,
	"ork_squad_nob","squad",0,1,2,
	"ork_squad_nob_advance_sp","squad",0,0,0,
	"ork_squad_nob_sp","squad",0,0,0,
	"ork_squad_shoota_boy","squad",1,2,2,
	"ork_squad_shoota_boy_advance_sp","squad",0,0,0,
	"ork_squad_slugga","squad",7,5,1,
	"ork_squad_slugga_advance_sp","squad",0,0,0,
	"ork_squad_squiggoth","vehicle",0,0,1,
	"ork_squad_squiggoth_sp_long_rampage","vehicle",0,0,0,
	"ork_squad_stormboy","squad",0,2,2,
	"ork_squad_stormboy_advance_sp","squad",0,0,0,
	"ork_squad_tankbusta","squad",0,1,2,
	"ork_squad_tankbusta_advance_sp","squad",0,0,0,
	"ork_squad_trukk","vehicle",2,0,0,
	"ork_squad_trukk_advance_sp","vehicle",0,0,0,
	"ork_squad_warboss","squad",0,1,1,
	"ork_squad_warboss_advance_sp","squad",0,0,0,
	"ork_squad_warboss_sp_md2","squad",0,0,0,
	"ork_squad_warboss_stronghold_sp","squad",0,0,0,
	"ork_squad_wartrak","vehicle",1,2,2,
	"ork_squad_fighta_bomba","vehicle",0,1,2,
	"ork_squad_fighta_bomba_sp_dxp3","vehicle",0,0,0,
	"ork_squad_wartrak_advance_sp","vehicle",0,0,0
}

tau_squads=
{
	"tau_broadside_battlesuit_squad","squad",1,0,0,
	"tau_broadside_battlesuit_squad_clone_sp","squad",1,0,0,
	"tau_builder_squad","servitor",0,0,0,
	"tau_builder_squad_clone_sp","servitor",0,0,0,
	"tau_commander_squad","squad",0,0,0,
	"tau_commander_squad_advance_sp","squad",0,0,0,
	"tau_commander_squad_clone_sp","squad",0,0,0,
	"tau_crisis_suit_squad","squad",1,1,2,
	"tau_crisis_suit_squad_clone_sp","squad",0,0,0,
	"tau_crisis_suit_squad_stronghold_sp","squad",0,0,0,
	"tau_devilfish_troop_carrier","vehicle",0,0,0,
	"tau_devilfish_troop_carrier_clone_sp","vehicle",0,0,0,
	"tau_drone_harbinger_squad","squad",0,0,0,
	"tau_drone_harbinger_squad_advance_sp","squad",0,0,0,
	"tau_drone_harbinger_squad_clone_sp","squad",0,0,0,
	"tau_drone_squad","squad",1,0,0,
	"tau_drone_squad_clone_sp","squad",0,0,0,
	"tau_ethereal_squad","squad",0,0,0,
	"tau_ethereal_squad_clone_sp","squad",0,0,0,
	"tau_ethereal_squad_stronghold_sp","squad",0,0,0,
	"tau_fire_warrior_squad","squad",0,0,0,
	"tau_fire_warrior_squad_clone_sp","squad",0,0,0,
	"tau_greater_knarloc_squad","squad",0,0,0,
	"tau_greater_knarloc_squad_clone_sp","squad",0,0,0,
	"tau_hammerhead_gunship_squad","vehicle",0,1,2,
	"tau_hammerhead_gunship_squad_advance_sp","vehicle",0,0,0,
	"tau_hammerhead_gunship_squad_clone_sp","vehicle",0,0,0,
	"tau_harbinger_drones_squad","squad",0,0,0,
	"tau_honor_guard_crisis_suit_squad_advance_honor_guard_sp","squad",0,0,0,
	"tau_honor_guard_crisis_suit_squad_advance_honor_guard_sp_clone_sp","squad",0,0,0,
	"tau_honor_guard_crisis_suit_squad_advance_sp","squad",0,0,0,
	"tau_honor_guard_fire_warrior_squad_advance_sp","squad",1,0,0,
	"tau_honor_guard_fire_warrior_squad_stronghold_sp","squad",0,0,0,
	"tau_honor_guard_stealth_suit_squad_advance_sp","squad",0,0,0,
	"tau_kroot_alpha_squad_advance_sp","squad",0,0,0,
	"tau_kroot_carnivore_squad","squad",0,0,1,
	"tau_kroot_carnivore_squad_clone_sp","squad",0,0,0,
	"tau_kroot_hound_squad","squad",1,0,0,
	"tau_kroot_hound_squad_advance_sp","squad",0,0,0,
	"tau_kroot_hound_squad_clone_sp","squad",0,0,0,
	"tau_kroot_shaper_squad","squad",0,0,0,
	"tau_kroot_shaper_squad_advance_sp","squad",0,0,0,
	"tau_kroot_shaper_squad_clone_sp","squad",0,0,0,
	"tau_krootox_squad","squad",0,1,2,
	"tau_krootox_squad_clone_sp","squad",0,0,0,
	"tau_pathfinder_squad","squad",0,0,0,
	"tau_pathfinder_squad_advance_sp","squad",0,0,0,
	"tau_pathfinder_squad_clone_sp","squad",0,0,0,
	"tau_shasui_fire_warrior_bodyguard_sp","squad",0,0,0,
	"tau_shasui_fire_warrior_bodyguard_sp_clone_sp","squad",0,0,0,
	"tau_skyray_squad","squad",0,0,0,
	"tau_skyray_squad_advance_sp","squad",0,0,0,
	"tau_skyray_squad_clone_sp","squad",0,0,0,
	"tau_stealth_team_squad","squad",1,2,1,
	"tau_stealth_team_squad_sp","squad",0,0,0,
	"tau_vespid_auxiliary_squad","squad",0,0,0,
	"tau_vespid_auxiliary_squad_clone_sp","squad",0,0,0,
	"tau_vespid_auxiliary_squad_sp","squad",0,0,0,
	"tau_barracuda_squad","vehicle",0,1,2,
	"tau_vespid_elder_squad_advance_sp","squad",0,0,0
}
---------------------------------------------------
---------------------------------------------------
---------------------------------------------------
--Change anything beyond this point at your peril--
--SCAR scripting is very heavy beyond this point---
---------------------------------------------------
---------------------------------------------------
---------------------------------------------------

g_AllResearch= {
	"chaos_berserker_fear_research",
	"chaos_bloodthirster_research",
	"chaos_champion_melee_research_1",
	"chaos_champion_melee_research_2",
	"chaos_commander_health_research_1",
	"chaos_cultist_sight_research",
	"chaos_daemon_prince_research",
	"chaos_furious_charge_research",
	"chaos_infiltration_marine_research",
	"chaos_infiltration_research",
	"chaos_lord_research_2",
	"chaos_max_weapons_research",
	"chaos_plasma_pistol_research",
	"chaos_plasma_pistol_research_advance_sp",
	"chaos_possessed_daemon_fire_research",
	"chaos_possessed_daemon_mutation_research",
	"chaos_projectiles",
	"chaos_purge_the_weak",
	"chaos_smoke_launcher_research",
	"chaos_sorcerer_research_1",
	"chaos_wargear_upgrade_01_manreaper_research",
	"chaos_wargear_upgrade_02_accursed_crozius_research",
	"chaos_wargear_upgrade_03_plasma_pistol_research",
	"chaos_wargear_upgrade_04_melta_gun_research",
	"chaos_wargear_upgrade_05_helm_of_lorgar_research",
	"chaos_wargear_upgrade_06_daemonic_armor_research",
	"chaos_wargear_upgrade_07_daemonic_gauntlets_research",
	"chaos_wargear_upgrade_08_runic_boots_research",
	"chaos_wargear_upgrade_09_banner_research",
	"chaos_wargear_upgrade_10_daemonic_ascension_research",
	"chaos_wargear_upgrade_research",
	"eldar_annihilate_the_enemy",
	"eldar_exarch_ability_research",
	"eldar_exarch_ability_research_1",
	"eldar_farseer_ability_research",
	"eldar_farseer_ability_research_3",
	"eldar_fleet_of_foot_research",
	"eldar_haywire_bomb_research",
	"eldar_plasma_grenade_research",
	"eldar_power_research_1",
	"eldar_ranger_infiltration_research",
	"eldar_research_farseerhealth_1",
	"eldar_research_farseerhealth_2",
	"eldar_research_infantryaccuracy_1",
	"eldar_research_infantryaccuracy_2",
	"eldar_research_infantryhealth_1",
	"eldar_research_infantryhealth_2",
	"eldar_research_sp_soulstone",
	"eldar_shroud_ability_research",
	"eldar_tier2_research",
	"eldar_vehicle_ability_research",
	"eldar_wargear_upgrade_01_witchblade_research",
	"eldar_wargear_upgrade_02_singing_spear_research",
	"eldar_wargear_upgrade_03_shuriken_pistol_research",
	"eldar_wargear_upgrade_04_twin_shuriken_pistol_research",
	"eldar_wargear_upgrade_05_ghosthelm_research",
	"eldar_wargear_upgrade_06_wraithbone_armor_research",
	"eldar_wargear_upgrade_07_gauntlets_research",
	"eldar_wargear_upgrade_08_rune_warding_research",
	"eldar_wargear_upgrade_09_rune_witnessing_research",
	"eldar_wargear_upgrade_10_rune_aura_research",
	"eldar_wargear_upgrade_research",
	"eldar_warlock_ability_research",
	"eldar_webway_gate_healing_research",
	"eldar_webway_gate_relocation_research",
	"guard_enable_leader_accuracy_bonus",
	"guard_enable_strafing_run",
	"guard_full_scale_war",
	"guard_guardsman_morale",
	"guard_guardsman_morale_2",
	"guard_research_assassin_infiltrate",
	"guard_research_command_squad_size",
	"guard_research_kasrkin_armor",
	"guard_research_kasrkin_speed",
	"guard_upgrade_garrisoned_shoot",
	"guard_upgrade_guardsmen_health",
	"guard_upgrade_guardsmen_range",
	"guard_upgrade_ogryn_melee",
	"guard_upgrade_power_1",
	"guard_upgrade_power_2",
	"guard_upgrade_requisition_1",
	"guard_upgrade_requisition_2",
	"guard_upgrade_weapon_specialization",
	"guard_wargear_upgrade_01_master_power_claws_research",
	"guard_wargear_upgrade_02_power_fist_research",
	"guard_wargear_upgrade_03_storm_bolter_research",
	"guard_wargear_upgrade_04_plasma_pistol_research",
	"guard_wargear_upgrade_05_targeting_optics_research",
	"guard_wargear_upgrade_06_pauldrons_research",
	"guard_wargear_upgrade_07_chest_plate_research",
	"guard_wargear_upgrade_08_greaves_research",
	"guard_wargear_upgrade_09_sash_research",
	"guard_wargear_upgrade_10_governor_raiment_research",
	"guard_wargear_upgrade_research",
	"marine_accuracy_upgrade_research",
	"marine_commander_health_research_1",
	"marine_commander_health_research_1_advance_sp",
	"marine_commander_health_research_2",
	"marine_commander_health_research_2_advance_sp",
	"marine_force_commander_ability_research_1",
	"marine_force_commander_teleport_research",
	"marine_health_upgrade_research",
	"marine_heavy_armor_deployment",
	"marine_librarian_research_1",
	"marine_librarian_research_2",
	"marine_max_weapons_research",
	"marine_melta_bomb_research",
	"marine_quickening_research",
	"marine_scout_infiltrate_research",
	"marine_sergeant_melee_upgrade_1",
	"marine_sergeant_melee_upgrade_1_advance_sp",
	"marine_sergeant_melee_upgrade_2",
	"marine_sergeant_ranged_upgrade_1",
	"marine_sergeant_ranged_upgrade_1_advance_sp",
	"marine_skull_probe_infiltrate_research",
	"marine_smoke_launcher_research",
	"marine_sniper_rifle",
	"marine_wargear_upgrade_01_power_sword_research",
	"marine_wargear_upgrade_02_daemon_hammer_research",
	"marine_wargear_upgrade_03_plasma_pistol_research",
	"marine_wargear_upgrade_04_multi_melta_research",
	"marine_wargear_upgrade_05_halo_research",
	"marine_wargear_upgrade_06_shoulders_research",
	"marine_wargear_upgrade_07_girdle_research",
	"marine_wargear_upgrade_08_gauntlets_research",
	"marine_wargear_upgrade_09_greaves_research",
	"marine_wargear_upgrade_10_teleporter_research",
	"marine_wargear_upgrade_research",
	"necron_beacon_research",
	"necron_beacon_research2",
	"necron_chronometron_research",
	"necron_lightning_field_research",
	"necron_nightmare_shroud_research",
	"necron_night_bringer_research",
	"necron_phase_shifter_research",
	"necron_phylactery_research",
	"necron_power_research",
	"necron_power_research_2",
	"necron_resurrection_orb_research",
	"necron_solar_pulse_research",
	"necron_veil_of_darkness_research",
	"necron_wargear_upgrade_01_skinning_blades_research",
	"necron_wargear_upgrade_02_reaping_blades_research",
	"necron_wargear_upgrade_03_necrotyr_sigils_research",
	"necron_wargear_upgrade_04_gauss_flayer_research",
	"necron_wargear_upgrade_05_death_mask_research",
	"necron_wargear_upgrade_06_under_shoulder_research",
	"necron_wargear_upgrade_07_mantle_of_doom_research",
	"necron_wargear_upgrade_08_ribcage_research",
	"necron_wargear_upgrade_09_gauntlets_research",
	"necron_wargear_upgrade_10_death_shroud_research",
	"necron_wargear_upgrade_research",
	"necron_warrior_boost",
	"necron_warrior_boost_2",
	"necron_wraith_boost",
	"ork_power_research_1",
	"ork_recruitment",
	"ork_requisition_research_1",
	"ork_research_bigshoota",
	"ork_research_big_mek_1",
	"ork_research_burna",
	"ork_research_burna_2",
	"ork_research_eavy_armor_boyz",
	"ork_research_eavy_armor_boyz_2",
	"ork_research_eavy_armour",
	"ork_research_evenmorechoppy",
	"ork_research_evenmoredakka",
	"ork_research_extra_armour",
	"ork_research_grot_infiltrate",
	"ork_research_morechoppy",
	"ork_research_moredakka",
	"ork_research_powerclaw",
	"ork_research_rokkit_launcha",
	"ork_research_speed_boost",
	"ork_research_tank_busta_infiltrate",
	"ork_research_tougherorks",
	"ork_research_tougherorks_2",
	"ork_research_tougher_bosses",
	"ork_research_tougher_bosses_2",
	"ork_research_warboss_ranged_1",
	"ork_wargear_upgrade_01_bigga_claw_wargear_research",
	"ork_wargear_upgrade_02_mega_claw_wargear_research",
	"ork_wargear_upgrade_03_big_shoota_wargear_research",
	"ork_wargear_upgrade_04_mega_blasta_wargear_research",
	"ork_wargear_upgrade_05_big_horns_research",
	"ork_wargear_upgrade_06_red_gob_research",
	"ork_wargear_upgrade_07_mega_eavy_armor_research",
	"ork_wargear_upgrade_08_fasta_legz_research",
	"ork_wargear_upgrade_09_skullz_research",
	"ork_wargear_upgrade_10_boss_pole_research",
	"ork_wargear_upgrade_research",
	"tau_anti_grav_research",
	"tau_anti_grav_research_advance_sp",
	"tau_feral_leap_research",
	"tau_improved_metallurgy",
	"tau_improved_power_source_research",
	"tau_missile_barrage_research",
	"tau_power_research",
	"tau_power_research_2",
	"tau_requisition_research",
	"tau_requisition_research_2",
	"tau_stealth_suit_damage_research",
	"tau_targeting_optics",
	"tau_target_lock",
	"tau_teachings_of_kauyon_research",
	"tau_teachings_of_montka_research",
	"tau_wargear_upgrade_01_flamer_research",
	"tau_wargear_upgrade_02_fusion_blaster_research",
	"tau_wargear_upgrade_03_plasma_rifle_research",
	"tau_wargear_upgrade_04_missile_pod_research",
	"tau_wargear_upgrade_05_advanced_sensor_array_research",
	"tau_wargear_upgrade_06_iridium_armor_research",
	"tau_wargear_upgrade_07_jetpack_research",
	"tau_wargear_upgrade_08_stealth_field_research",
	"tau_wargear_upgrade_09_shield_drone_research",
	"tau_wargear_upgrade_10_gun_drone_research",
	"tau_wargear_upgrade_research"
}



function debug_print(text)
	if g_debug_print then
		print(text)
	end
end

function copy_table(item)
	local k,v
	local temp_copy
	if type(item)=="table" then
		temp_copy={}
		for k,v in pairs(item) do
			temp_copy[k]=copy_table(v)
		end
	else
		temp_copy=item
	end
	return temp_copy
end

function OnGameSetup()
	g_Player1 = World_GetPlayerAt(0)
	g_Player2 = World_GetPlayerAt(1)
--	g_Player3 = World_GetPlayerAt(2)
--	g_Player4 = World_GetPlayerAt(3)
--	g_Player5 = World_GetPlayerAt(4)
--	g_Player6 = World_GetPlayerAt(5)
--	g_Player7 = World_GetPlayerAt(6)
--	g_Player8 = World_GetPlayerAt(7)
	g_counter = 0				--depreciated
	g_count = 0				--depreciated
	g_alive_enemies = 0			--Number of alive enemies this round.  When it counts to 0, it will start the new round
	g_already_spawning = false		--Do we have a timer running for when the wave will occur
	g_wave_number = 1   			--The wave number to do.  We have not done any waves yet, so we are at 1
	g_wave_timer = 0
	g_last_vplayer=0
	--g_DestroyHQ=false
	Permitted_to_destroy_enemy=false	--When this is set to true, we can walk through the force-field defending the enemy base
	local looper					--Used for setting initial values in the virt-player and virt-player-counter arrays
	local seclooper
	virt_player={}
	virt_player_count={}
	for looper=1,50 do
		virt_player_count[looper]={}
		virt_player[looper] =1   -- position in squad-list-array of the squad to drop next
		for seclooper = 1 , 70 do
			virt_player_count[looper][seclooper]=0 -- The amount of that squad-type we have dropped already
		end
	end
	virtual_enemy_array={}
--	Util_StartNIS       ( EVENTS.NIS1 )
--	Util_StartIntel     ( EVENTS.INTEL1 )
--	Util_StartNIS       ( EVENTS.NIS2 )
--	Util_StartIntel     ( EVENTS.INTEL2 )
--	Util_StartIntel     ( EVENTS.INTEL2 )

end
 
--We want to make sure we have at least 1 of everything that has a number next to it.
--We want to make sure we do not have more than the given number of anything.
--We need to have a count of everything.  (can use an array of length [numoftotitems])
--loop through all of them.  If the "type" is what we want, and if the count < num avail then add it and increase the count for that index
--Have the count index be a local variable so it is destroyed when done
--have it be a function that accepts the type of building, the num of the pos, and player to recieve it.
--have a function that calls the above for each type: hq first, military, turret, power, and then minefield



function one_base(player, marker, array_of_buildings)
	local looper = 1
	local marker_name = ""
	local groupname=""
	local building_type = "hq"
	local flag = true
	local counter=0
	marker_name = marker
	if Marker_Exists (marker_name,"basic_marker") then
		groupname="protectedbase"
		for looper = 1, (table.getn(array_of_buildings)/3) do
			base=(looper * 3) -2
			if array_of_buildings[base + 1] == building_type and flag == true and EBP_Exists(array_of_buildings[base]) then
				--It is a base, make it
				--protected against no such blueprint
				Entity_CreateBuildingMarker(player,groupname,array_of_buildings[base],marker_name,1.0)
				flag = false
				counter = counter + 1
				print("Dropping a single building ("..array_of_buildings[base].." at location: "..marker_name)
			end
		end
		--UIWarning_Show( "dropping at marker "..marker.."  attempted "..counter )
	end
end



--drop a base for a human player
function base_for_player(player, location, race_name, basetype,direction)
	local looper=0
	local t_Player={}
	if type(player) == "string" then
		player=tonumber(player)
	end
	if player <= World_GetPlayerCount() and player ~= 2 then
		for looper = 0, World_GetPlayerCount() -1 do
			t_Player[looper+1] = World_GetPlayerAt(looper)
		end
		if race_name=="default" then
			race_name=Player_GetRaceName( t_Player[player] )
		end
		if t_Player[player] ~= nil and Player_IsAlive(t_Player[player]) then
			if basetype == "compact" then
				drop_compact_base(t_Player[player], race_name, Marker_GetPosition(Marker_FromName( location, "basic_marker" )),direction,location)
			else
				drop_base(t_Player[player], location, race_name, -1)
			end
		end
	end
end

--drop_squad(player, vplayer, race_array, location, difficulty, stype)
--drop squad, player who owns them, virt_player num, race
--marker location where they will fall, and the difficulty (1,2, or 3), squad type
function drop_squad(player, vplayer, race_array, position, difficulty, stype)
	local looper=0
	local seclooper=0
	local base=0
	local flag=true
	local escflag=false
	local doneit = false
	local group_name=""
	print("dropping squad vplayer="..vplayer.." difficulty="..difficulty.." stype="..stype.." position="..genstring(position))
	--Up to this point works. Now we need to uncomment below and see what happens
	
	--Here we simply drop the next item in the list
	--if Marker_Exists (location,"basic_marker") then
		--print("marker exists "..location.." for vplayer "..vplayer)
		while flag == true do
			if vplayer < 1 then
				vplayer=1
			end
			base=(virt_player[vplayer] * 5) -4  --This is the position within the race-array of the vehicle/squad we are looking at
			if race_array[base + 1] == stype then
				--print("we are looking at the right type of squad/vehicle")
				--We are looking at something of type squad/vehicle.
				--Now, if we have not gone over our quota of them, we will spawn some of them.
				--print("quota for ("..virt_player[vplayer]..")  "..race_array[base].." is "..race_array[base + 1 + difficulty]..", we have "..virt_player_count[vplayer][virt_player[vplayer]].." diff="..difficulty)
				if virt_player_count[vplayer][virt_player[vplayer]] < race_array[base + 1 + difficulty] then
					--print("we have not exceeded our quota of them")
					--we add them if we have not done them already
					if SBP_Exists(race_array[base]) then
						if stype == "vehicle" then
							group_name="enemyV"
						else
							group_name="enemyS"
						end
						group_name=group_name..virtual_enemy_array[(vplayer*4)-3]
						virt_player_count[vplayer][virt_player[vplayer]]=virt_player_count[vplayer][virt_player[vplayer]] + 1
						--print("try spawning them")
						--protected against no blueprint
						Util_CreateSquadsAtPositionEx(player, group_name, race_array[base], position, 1, 0)
						flag=false
						doneit = true
					else
						print("No such blueprint: "..genstring(race_array[base]))
					end
				end
			end
			virt_player[vplayer] = virt_player[vplayer] + 1
			base=(virt_player[vplayer] * 5) -4  --Again, calculating the new location in the race-array
			if (base+4) > table.getn(race_array) then
				--print("we looped through and need to re-start our loop")
				virt_player[vplayer]=1  --Start at the beginning of the array
				if escflag == true then
					flag = false
				end
				escflag = true
			end
		end
--	end
	if doneit == false then
		local seclooper=0
		for seclooper = 1 , 60 do
			virt_player_count[vplayer][seclooper]=0 -- The amount of that squad we have dropped already
		end
	end
end

function drop_wave(player, vplayer, race_array, location, difficulty, stype, race_name)
	local looper=0
	local group_name=""
	local cap=1
	local last_cap=0
	local flag = true
	local location_marker=""
	local countcheck=0
	local wherefrom="hq"
	print("dropping a wave for "..vplayer)
	if stype == "vehicle" then
		group_name="enemyV"
		--pull the player vehicle cap from g_GamePlay
		cap = g_GamePlay[ (virtual_enemy_array[(vplayer*4)] * 8) -1 ]
	else
		group_name="enemyS"
		--pull the player squad cap from g_GamePlay
		cap = g_GamePlay[ (virtual_enemy_array[(vplayer*4)] * 8) -2 ]
	end
	group_name=group_name..virtual_enemy_array[(vplayer*4)-3]
--	UIWarning_Show("about to spawn a squad of "..group_name.." for vplayer "..vplayer.." and cap of "..cap.." and a race_array of size "..table.getn(race_array) )
	if SGroup_Exists( group_name ) == false then  
		--make an enpty group so we can "count" it without blowing up
		SGroup_Create(group_name)
	end
	
	local GroupID=SGroup_FromName(group_name)
	--For a wave, we simply create as many as we can within the cap.
	if g_wave_location == nil then
		g_wave_location = {}
		print("g_wave_location was nil.  setting it")
	end
	if g_wave_location[location] == nil then
		g_wave_location[location] = 1
		print("g_wave_location[location("..location..")] was nil.  setting it to 1")
	end
	while (SGroup_Count( GroupID ) < (cap - 4)) and flag==true do
		looper=0
		if race_name == "tyranid_race" then
			--Find leader name
			--	vplayer#-tyranid-leader
			local leadername=vplayer.."_tyranid_leader"
			last_cap=SGroup_Count( GroupID )
			if SGroup_Exists(leadername) then
				print ("leader group exists - do wave")
				local position = SGroup_GetPosition( SGroup_FromName(leadername) )
				if position ~= nil then
					print("We know position.  Drop squad")
					drop_squad(player, vplayer, race_array, position, difficulty, stype)
				else
					print("cannot determine position of leader.  ")
					flag=false
				end
			end
			if SGroup_Count( GroupID ) == last_cap then
				flag=false
				print("we were unable to successfully drop anything.  Cap reached?")
			end
		else
			local mycheck="spawn"..location.."webway"
			wherefrom="webway"
			if EGroup_Exists(mycheck) == true then
				if EGroup_Count(EGroup_FromName(mycheck)) < 1 then
					mycheck="spawn"..location
					wherefrom="hq"
				end
			else
				mycheck="spawn"..location
				wherefrom="hq"
				if EGroup_Exists(mycheck) == false then
					print("oops.  creating group -"..mycheck.."- to avoid blowing up!")
					EGroup_Create(mycheck)
				end
			end
			if g_wave_location[location] > EGroup_Count(EGroup_FromName(mycheck)) then
				g_wave_location[location] = 1
			end

			local smalldrop=function( egroupid, itemindex, entityID )
				local whattoreturn=false
				if itemindex == g_wave_location[location] then
					local position = Entity_GetPosition( entityID )
					print("dropping squad on position of item "..itemindex)
					drop_squad(player, vplayer, race_array, position, difficulty, stype)
					whattoreturn=true
				end
				return whattoreturn
			end
			last_cap=SGroup_Count( GroupID )
			EGroup_ForEach( EGroup_FromName(mycheck), smalldrop )
			if wherefrom == "hq" then
				g_wave_location[location] = g_wave_location[location] + 1
			end
			if SGroup_Count( GroupID ) == last_cap then
				countcheck=countcheck+1
				--We did not add anything.  Excape our loop!
				if countcheck > 3 then
					flag=false
				end
			else
				--If we successfully dropped something, keep trying
				countcheck = 0
			end
		end
		if wherefrom == "webway" and g_cycle_webway == true then
			g_wave_location[location] = g_wave_location[location] + 1
		end
	end
end

function drop_trickle(player, vplayer, race_array, location, difficulty, stype, race_name)
	local looper=0
	local group_name=""
	local cap=1
	local last_cap=0
	local flag = true
	local location_marker=""
	local countcheck=0
	local wherefrom="hq"
	if stype == "vehicle" then
		group_name="enemyV"
		--pull the player vehicle cap from g_GamePlay
		cap = g_GamePlay[ (virtual_enemy_array[(vplayer*4)] * 8) -1 ]
	else
		group_name="enemyS"
		--pull the player squad cap from g_GamePlay
		cap = g_GamePlay[ (virtual_enemy_array[(vplayer*4)] * 8) -2 ]
	end
	group_name=group_name..virtual_enemy_array[(vplayer*4)-3]
	if SGroup_Exists( group_name ) == false then  
		--make an enpty group so we can "count" it without blowing up
		SGroup_Create(group_name)
	end
	
	local GroupID=SGroup_FromName(group_name)
	--For a wave, we simply create as many as we can within the cap.
	if g_wave_location == nil then
		g_wave_location = {}
		print("g_wave_location was nil.  setting it")
	end
	if g_wave_location[location] == nil then
		g_wave_location[location] = 1
		print("g_wave_location[location("..location..")] was nil.  setting it to 1")
	end
	if (SGroup_Count( GroupID ) < (cap - 4)) then
		looper=0
		if race_name == "tyranid_race" then
			--Find leader name
			--	vplayer#-tyranid-leader
			local leadername=vplayer.."_tyranid_leader"
			if SGroup_Exists(leadername) then
				local position = SGroup_GetPosition( SGroup_FromName(leadername) )
				if position ~= nil then
					drop_squad(player, vplayer, race_array, position, difficulty, stype)
				end
			end
		else
			local mycheck="spawn"..location.."webway"
			wherefrom="webway"
			if EGroup_Exists(mycheck) == true then
				if EGroup_Count(EGroup_FromName(mycheck)) < 1 then
					mycheck="spawn"..location
					wherefrom="hq"
				end
			else
				mycheck="spawn"..location
				wherefrom="hq"
				if EGroup_Exists(mycheck) == false then
					print("oops.  creating group -"..mycheck.."- to avoid blowing up!")
					EGroup_Create(mycheck)
				end
			end
			if g_wave_location[location] > EGroup_Count(EGroup_FromName(mycheck)) then
				g_wave_location[location] = 1
			end

			local smalldrop=function( egroupid, itemindex, entityID )
				local whattoreturn=false
				if itemindex == g_wave_location[location] then
					local position = Entity_GetPosition( entityID )
					print("dropping squad on position of item "..itemindex)
					drop_squad(player, vplayer, race_array, position, difficulty, stype)
					whattoreturn=true
				end
				return whattoreturn
			end
			EGroup_ForEach( EGroup_FromName(mycheck), smalldrop )
			if wherefrom == "hq" then
				g_wave_location[location] = g_wave_location[location] + 1
			end
		end
	end
	if wherefrom == "webway" then
		g_wave_location[location] = g_wave_location[location] + 1
	end
end

function increase_caps(player, cap)
	if cap > 20 then
		cap = 20
	end
	if Player_GetMaxSquadCap(player,CT_SquadCap) + cap < 50 then
		modifier_maxsquadcap_increase = Modifier_Create(MAT_Player, "max_squad_cap_player_modifier", MUT_Addition, false,cap,"")
		modifier_maxsupportcap_increase = Modifier_Create(MAT_Player, "max_support_cap_player_modifier", MUT_Addition, false,cap * 2,"")
		modifier_squadcap_increase = Modifier_Create(MAT_Player, "squad_cap_player_modifier", MUT_Addition, false,cap,"")
		modifier_supportcap_increase = Modifier_Create(MAT_Player, "support_cap_player_modifier", MUT_Addition, false,cap * 2,"")
		modifier_popcap_increase = Modifier_Create(MAT_Player,"population_cap_player_modifier",MUT_Addition,false,cap * 10,"")
	
		Modifier_ApplyToPlayer(modifier_maxsquadcap_increase, player)
		Modifier_ApplyToPlayer(modifier_maxsupportcap_increase, player)
		Modifier_ApplyToPlayer(modifier_squadcap_increase,   player)
		Modifier_ApplyToPlayer(modifier_supportcap_increase, player)
		Modifier_ApplyToPlayer(modifier_popcap_increase, player)
	end
end

function check_marker(who, marker, target, action)
	--Here we try to protect bases by teleporting people away from them if they are not allowed in
	--At the moment I am testing the teleport.  Assume perpetual protect mode
	local count = World_GetPlayerCount();
	local marker_name = "";
	local team=1;
	local looper=0;
	local t_Player={};
		for i = 0, count -1 do
			local j = (i+1);
			t_Player[j] = World_GetPlayerAt(i);
		end
		if who == "enemy" then
			team = 2
		else
			team = 1
		end
		
		for j = 1, count do
			if Player_IsAlive(t_Player[j]) == true then
				if Player_GetTeam(t_Player[j]) + 1 == team then
					marker_name = marker
					if Marker_Exists (marker_name,"basic_marker") then
						--UIWarning_Show( "Teleport marker exists "..marker.." team"..team.." computed from "..who.." is player "..j )
						if Player_AreSquadsNearMarker( t_Player[j], marker_name ) == true then
							--UIWarning_Show( "Squads near marker" )
							if action == "teleport" then
								local group = Player_GetAllSquadsNearMarker(t_Player[j], "tempGroup", marker_name );
								SGroup_DeSpawn("tempGroup")
								World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", "tempGroup")
								print("Troops close to teleport marker "..marker_name.."  DeSpawning")
								if Marker_Exists(target, "basic_marker") then
									SGroup_ReSpawnMarker("tempGroup", target)
									print("ReSpawning them at "..target)
									World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", "tempGroup")
								else
									print("end marker "..target.." does not exist.  Attempting to re-spawn at home base")
									SGroup_ReSpawnPosition("tempGroup", Player_GetStartPosition( t_Player[j] ))
									World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", "tempGroup")
								end
								--Clear the temp group so we can reuse it later
								SGroup_Clear("tempGroup")
								if Misc_GetLocalPlayerID() == Player_GetID(t_Player[j])  then
									UIWarning_Show( "Teleport in effect.  Bouncing your troops" )
								end
							elseif action == "destroy" then
								local group = Player_GetAllSquadsNearMarker(t_Player[j], "tempGroup", marker_name );
								if target ~= "" then
									if SGroup_Exists (target) then
										--target is a squad name.  Only deal with items in that group
										Player_GetAllSquadsNearMarker(t_Player[j], "tempGroup", marker_name );
										SGroup_Intersection("tempGroup", target)
									end
									if SBP_Exists( target ) then
										--target is a blueprint.  Only deal with that blueprint
										SGroup_Clear( group )
										Player_GetAllSquadsNearMarker(t_Player[j], "temp1Group", marker_name );
										Util_GetEntitiesByBP( "temp1Group", "tempGroup", target )
										SGroup_Clear( SGroup_FromName("temp1Group"))
									end
								end
								SGroup_DestroyAllSquads( "tempGroup")
								SGroup_Clear( SGroup_FromName("tempGroup"))
								print("troops in a destroy zone.  Killing them.")
								if Misc_GetLocalPlayerID() == Player_GetID(t_Player[j])  then
									UIWarning_Show( "Some of your troops that were too close to a protected zone have been destroyed!" )
								end
							elseif action=="save" then
								local group = Player_GetAllSquadsNearMarker(t_Player[j], "tempGroup", marker_name );
								if target ~= "" then
									local todo=false
									if SGroup_Exists (target) then
										--target is a squad name.  Only deal with items in that group
										Player_GetAllSquadsNearMarker(t_Player[j], "tempGroup", marker_name );
										SGroup_Intersection("tempGroup", target)
										todo=true
									elseif SBP_Exists( target ) then
										--target is a blueprint.  Only deal with that blueprint
										if SGroup_Exists("tempGroup") then
											SGroup_Clear("tempGroup")
										end
										Player_GetAllSquadsNearMarker(t_Player[j], "temp1Group", marker_name );
										print ("squad blueprint save check.  tmp1Group has "..SGroup_Count(SGroup_FromName("temp1Group")))
										print ("looking for blueprint"..target)
										Util_GetSquadsByBP( "temp1Group", "tempGroup", target )
										print ("group with blueprint.  tmpGroup has "..SGroup_Count(SGroup_FromName("tempGroup")))
										SGroup_Clear( SGroup_FromName("temp1Group"))
										todo=true
									end
									if todo == true then
										if SGroup_Count(SGroup_FromName("tempGroup")) > 0 then
											g_num_saved = g_num_saved + SGroup_Count(SGroup_FromName("tempGroup"))
											SGroup_DestroyAllSquads( "tempGroup")
											SGroup_Clear( SGroup_FromName("tempGroup"))
											if Misc_GetLocalPlayerID() == Player_GetID(t_Player[j])  then
												UIWarning_Show( g_num_saved.." saved!" )
											end
											print("troops in a 'save' zone.  Removing them from danger.")
											if g_end_game_when_saved > 0 then
												if g_num_saved > g_end_game_when_saved then
													--We saved as many as we needed to
													g_end_time=1
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
end


function special_spawn_squad(who, marker, blueprint, action)
	--Give squads to the players.  Give each player on the team the squad.
	local count = World_GetPlayerCount();
	local marker_name = marker;
	local team=1;
	local groupname="";
	local t_Player={};
	for i = 0, count -1 do
		local j = (i+1);
		t_Player[j] = World_GetPlayerAt(i);
	end
	if who == "enemy" then
		team = 2
	else
		team = 1
	end
	if SBP_Exists(blueprint) then
		for j = 1, count do
			if Player_IsAlive(t_Player[j]) == true then
				if Player_GetTeam(t_Player[j]) + 1 == team then
					marker_name = marker
					if Marker_Exists (marker_name,"basic_marker") then
						--Use a groupname that allows multiple ones to be given to the same or different players
						groupname=j..marker_name..action.."_gift"
						--UIWarning_Show("Spawning a "..blueprint.." for "..who.." at "..marker.." action number "..action.." and calling it "..groupname)
						if SGroup_Exists(groupname) then
							if SGroup_Count(  SGroup_FromName( groupname )) < 1 then
								print("respawning a special critter "..blueprint.." at "..marker_name)
								--protected against no blueprint
								Util_CreateSquadsAtMarkerEx(t_Player[j], groupname, blueprint, marker_name, 1, 0)
							end
						else
							print("Spawning a special critter "..blueprint.." at "..marker_name)
							--protected against no blueprint
							--Util_CreateSquadsAtMarkerEx( PlayerID playerId, String squadgroupName, String squadBlueprint, String markername, Integer numsquads, Integer loadout )
							Util_CreateSquadsAtMarkerEx(t_Player[j], groupname, blueprint, marker_name, 1, 0)
						end
					end
				end
			end
		end
	else
		print("Blueprint does not exist: "..genstring(blueprint))
	end
end


function special_spawn_building(who, marker, blueprint, action)
	--Give a player a particular building.  If the player is not the enemy, we randomly choose which player gets it
	local count = World_GetPlayerCount();
	local marker_name = "";
	local team=1;
	local looper=0;
	local groupname="";
	local t_Player={};
	local howmany=0;
	local whichone=1;
	if who == "enemy" then
		team = 2
	else
		team = 1
	end
	for i = 0, count -1 do
		local j = (i+1);
		t_Player[j] = World_GetPlayerAt(i);
		if Player_GetTeam(t_Player[j]) + 1 == team then
			howmany=howmany+1
		end
	end
	if who == "enemy" then
		whichone=1
	else
		random_seed()
		whichone=World_GetRand(1,howmany)
	end
	for j = 1, count do
		if Player_IsAlive(t_Player[j]) == true then
			if Player_GetTeam(t_Player[j]) + 1 == team then
				whichone=whichone-1
				if whichone == 0 then
					marker_name = marker
					if Marker_Exists (marker_name,"basic_marker") and EBP_Exists(blueprint) then
						groupname=j..marker_name.."_gift"
						if EGroup_Exists(groupname) then
							if EGroup_Count(  EGroup_FromName( groupname) ) < 1 then
								--protected against no such blueprint
								Entity_CreateBuildingMarker(t_Player[j],groupname,blueprint,marker_name,1.0)
								print("respawning a special building "..blueprint.." at "..marker_name)
							end
						else
							print("spawning a special building "..blueprint.." at "..marker_name)
							Entity_CreateBuildingMarker(t_Player[j],groupname,blueprint,marker_name,1.0)
						end
					end
				end
			end
		end
	end
end


function destroy_vplayer(vplayer)
	local teamgroup=""
	local teamgrouphq=""
	local restgroup=""
	local group_name=""
	if virtual_enemy_array[ (vplayer * 4) - 3 ] ~= nil and virtual_enemy_array[ (vplayer * 4) - 3 ] ~= "-1" then
		print("  destroying vplayer "..vplayer)
		restgroup="buildings"..virtual_enemy_array[ (vplayer * 4) - 3 ]
		teamgroup=restgroup.."military"
		teamgrouphq=restgroup.."hq"
		--UIWarning_Show( "Buildings at location "..virtual_enemy_array[ (vplayer * 4) - 3 ].." destroyed! "..teamgroup.."  "..teamgrouphq.." "..restgroup.." there were "..tot_num.." total  "..num_HQ.." headquarters and "..num_buildings.." buildings")
		--UIWarning_Show( "Buildings at location "..virtual_enemy_array[ (vplayer * 4) - 3 ].." destroyed! ")
		if EGroup_Exists(teamgroup) then
			EGroup_DestroyAllEntities( teamgroup )
			EGroup_Destroy( teamgroup )
		end
		if EGroup_Exists(teamgrouphq) then
			EGroup_DestroyAllEntities( teamgrouphq )
			EGroup_Destroy( teamgrouphq )
		end
		if EGroup_Exists(restgroup) then
			EGroup_DestroyAllEntities( restgroup )
			EGroup_Destroy( restgroup )
		end
		--Destroy Squads that were based out of here
		group_name="enemyS"..virtual_enemy_array[(vplayer*4)-3]
		if SGroup_Exists(group_name) then
			print ("number in squad="..SGroup_Count(SGroup_FromName(group_name))) 
			g_DeadPlayers[ table.getn(g_DeadPlayers) + 1] = group_name
			
			SGroup_SelfDestroy( group_name, false )

		end
		--Destroy Vehicles that were based out of here
		group_name="enemyV"..virtual_enemy_array[(vplayer*4)-3]
		if SGroup_Exists(group_name) then
			if SGroup_Count(SGroup_FromName(group_name)) > 0 then
				SGroup_SelfDestroy( group_name, false )
				g_DeadPlayers[ table.getn(g_DeadPlayers) + 1] = group_name
			end
		end
		virtual_enemy_array[ (vplayer * 4) - 3 ] = "-1"  	
		g_alive_enemies = g_alive_enemies -1
	end
end


function virt_player_alive_check()
	--Here we make sure all the buildings for our virtual players are alive
-- 	      Boolean  EGroup_Exists( String name )  
--		Void  EGroup_DestroyAllEntities( String groupname )
--		integer  EGroup_Count( EGroupID egroup )
	local looper=0
	local teamgroup=""
	local teamgrouphq=""
	local restgroup=""
	local num_HQ =0
	local num_buldings=0
	local tot_num=0
	local group_name=""
	local race_name
	for looper = 1, (table.getn(virtual_enemy_array) / 4) do
		--If vplayer race is tyranid, treat them differently.
		--vplayer.."_tyranid_leader"
		race_name=g_GamePlay[(virtual_enemy_array[(looper * 4) ] * 8) -6 ]
		if race_name == "tyranid_race" then
			if virtual_enemy_array[ (looper * 4) - 3 ] ~= "-1" then
				local leadername=looper.."_tyranid_leader"
				if SGroup_Exists(leadername) and SGroup_Count(SGroup_FromName(leadername)) > 0 then
					--We don't do anything if he exists.
				else
					--destroy_vplayer(looper)
					UIWarning_Show( "Tyranid leader from"..virtual_enemy_array[ (looper * 4) - 3 ].." destroyed! ")
					local tempgroupname="tyranid_"..looper.."deadgroup"
					local tempgroupid=SGroup_CreateIfNotFound(tempgroupname)
					group_name="enemyS"..virtual_enemy_array[(looper*4)-3]
					if SGroup_Exists(group_name) then
						SGroup_AddGroup(tempgroupid, SGroup_FromName(group_name))
					end
					--Destroy Vehicles that were based out of here
					group_name="enemyV"..virtual_enemy_array[(looper*4)-3]
					if SGroup_Exists(group_name) then
						SGroup_AddGroup(tempgroupid, SGroup_FromName(group_name))
					end
					g_DeadPlayers[ table.getn(g_DeadPlayers) + 1] = tempgroupname
					virtual_enemy_array[ (looper * 4) - 3 ] = "-1"  	
					g_alive_enemies = g_alive_enemies -1
					DoItNow( { "Scatter",tempgroupname,SGroup_GetPosition( tempgroupid ), proximity=50 } )
				end
			end
		else
			if virtual_enemy_array[ (looper * 4) - 3 ] ~= "-1" then
				restgroup="buildings"..virtual_enemy_array[ (looper * 4) - 3 ]
				teamgroup=restgroup.."military"
				teamgrouphq=restgroup.."hq"
				num_buildings=1
				num_HQ=1
				if EGroup_Exists(teamgroup) then
					num_buildings = EGroup_Count( teamgroup )
				else
					num_buildings=0
				end
				if EGroup_Exists(teamgrouphq) then
					num_HQ = EGroup_Count( teamgrouphq )
				else
					num_HQ=0
				end
				if g_DestroyHQ == true then
					tot_num=num_HQ
				else
					tot_num=num_HQ + num_buildings
				end
	--	UIWarning_Show("About to check to see if enemies are alive:  enemies:"..g_alive_enemies.."in array"..(table.getn(virtual_enemy_array) / 4 ).." buildings "..tot_num)
				
				if tot_num < 1 then
					destroy_vplayer(looper)
					UIWarning_Show( "Buildings at location "..virtual_enemy_array[ (looper * 4) - 3 ].." destroyed! ")
				end
			end
		end
	end
end

function endgame_test()
	local liveplayers=0
	local looper=0
	for looper = 1, (table.getn(virtual_enemy_array) / 4) do
		if virtual_enemy_array[(looper * 4) -3] ~= "-1" then
			liveplayers=liveplayers + 1
		end
	end
	if liveplayers > 0 then
		if Permitted_to_destroy_enemy == true then
			UIWarning_Show("The enemy base is now protected!")
		end 
		Permitted_to_destroy_enemy = false
	else
		if Permitted_to_destroy_enemy == false then
			UIWarning_Show("The enemy base is unprotected!")
		end 
		Permitted_to_destroy_enemy = true
	end
	--UIWarning_Show("liveplayers = "..liveplayers.." out of "..table.getn(virt_player_locations))
end

function getnth(mstring, nth)
	--return the string at the nth position
	--using | as the delimiter
	local word=""
	local count=0
	local match=nil
	for word in string.gfind(mstring, "[_%w]+") do
		count = count + 1
--		print("We found: "..word.." at: "..count)
		if count == nth then
--			print("  We have a match!")
			match=word
		end
	end
	return match
end

function get_first_race_name(mstring)
	--return the first valid racename
	--using | as the delimiter
	local word=""
	local count=0
	local match=""
	for word in string.gfind(mstring, "[_%w]+") do
		if race_known(word) then
			match=word
			print("  first valid race_name is: "..match)
		end
	end
	return match
end

function get_first_blueprint(mstring)
	--return the first valid blueprint 
	--using | as the delimiter
	local word=""
	local count=0
	local match=""
	local alldone=false
	for word in string.gfind(mstring, "[_%w]+") do
		if EBP_Exists(word) or SBP_Exists(word) then
			if not alldone then
				match=word
				print("  first valid blueprint is: "..match)
				alldone=true
			end
		else
			print("  This blueprint does not exist"..word)
		end
	end
	return match
end


function get_squad_race_array(race_name)
	local race_array=nil
	if race_name == "chaos_marine_race" then
		race_array= chaos_squads
	elseif race_name == "eldar_race" then
		race_array=  eldar_squads
	elseif race_name == "guard_race" then
		race_array=  ig_squads
	elseif race_name == "ork_race" then
		race_array=  ork_squads
	elseif race_name == "space_marine_race" then
		race_array=  space_marine_squads
	elseif race_name == "necron_race" then
		race_array=  necron_squads
	elseif race_name == "dark_eldar_race" then
		race_array=  dark_eldar_squads
	elseif race_name == "sisters_race" then
		race_array=  sisters_squads
	elseif race_name == "tyranid_race" then
		race_array=  tyranid_squads
	elseif race_name == "tau_race" then
		race_array=  tau_squads
	elseif race_name == "custom1" then
		race_array=  custom1_squads
	elseif race_name == "custom1_race" then
		race_array=  custom1_squads
	elseif race_name == "custom2" then
		race_array=  custom2_squads
	elseif race_name == "custom2_race" then
		race_array=  custom2_squads
	end
	return race_array
end

function get_building_race_array(race_name)
	local race_array=nil
	if race_name == "chaos_marine_race" then
		race_array= chaos_buildings
	elseif race_name == "eldar_race" then
		race_array=  eldar_buildings
	elseif race_name == "dark_eldar_race" then
		race_array=  dark_eldar_buildings
	elseif race_name == "guard_race" then
		race_array=  ig_buildings
	elseif race_name == "sisters_race" then
		race_array=  sisters_buildings
	elseif race_name == "tyranid_race" then
		race_array=  tyranid_buildings
	elseif race_name == "ork_race" then
		race_array=  ork_buildings
	elseif race_name == "space_marine_race" then
		race_array=  space_marine_buildings
	elseif race_name == "necron_race" then
		race_array=  necron_buildings
	elseif race_name == "tau_race" then
		race_array=  tau_buildings
	elseif race_name == "custom1" then
		race_array=  custom1_buildings
	elseif race_name == "custom1_race" then
		race_array=  custom1_buildings
	elseif race_name == "custom2" then
		race_array=  custom2_buildings
	elseif race_name == "custom2_race" then
		race_array=  custom2_buildings
	end
	return race_array
end

function race_known(race_name)
	--Determine if we have a race-array for the race
	--and if those blueprints (could be a mod) are known to ezscar
	--For speed of lookup, we store races that we know exist
	local race_array = get_squad_race_array(race_name)
	local looper
	local base
	local counter=0
	if g_known_races == nil then
		g_known_races={}
	end
	--Check if we have looked this race up before
	if g_known_races.race_name ~= nil then
		--We have looked them up.  Return our answer
		return g_known_races.race_name
	end
	if race_name == "default" then
		--We always have a default race.
		g_known_races.race_name = true
		return true
	end
	--Race_array is nil when we do not have the race programmed into ezscar
	if race_array == nil then
		--We do not have a race array programed in for that race
		g_known_races.race_name = false
		print("Warning: Unknown race "..genstring(race_array))
		return false
	end
	for looper = 1, 5 do
		base = (looper * 5) - 4
		if (base <= table.getn(race_array)) then
			if SBP_Exists(race_array[base]) then
				counter = counter + 1
				if counter > 2 then
					g_known_races.race_name = true
					return true
				end
			end
		end
	end
	g_known_races.race_name = false
	return false
end

function spawn_wave(player, vplayer, stype)
	local location = virtual_enemy_array[(vplayer * 4) -3]
	local difficulty = g_GamePlay[(virtual_enemy_array[ (vplayer * 4) ] * 8) -3 ]
	local race_name = g_GamePlay[(virtual_enemy_array[(vplayer * 4) ] * 8) -6 ]
	local race_array = tau_squads
--	print("doing spawn wave")
	if race_name=="default" then
		race_name=Player_GetRaceName( g_Player2 )
	end
	race_array=get_squad_race_array(race_name)
--	UIWarning_Show("spawning a wave for vplayer"..vplayer.." of race "..race_name.." at location "..location.." difficulty "..difficulty.." and stype "..stype)
	drop_wave(player, vplayer, race_array, location, difficulty, stype, race_name)
end

--spawn_trickle - decide if the virtual pop is too low, and if so, spawn the next squad
--is the virtual player still alive?
--Is the virtual population lower than it should be?
--If so, spawn a vehicles / squad
function spawn_trickle(player, vplayer, stype)
	local location = virtual_enemy_array[(vplayer * 4) -3]
	local difficulty = g_GamePlay[(virtual_enemy_array[ (vplayer * 4) ] * 8) -3 ]
	local race_name = g_GamePlay[(virtual_enemy_array[(vplayer * 4) ] * 8) -6 ]
	local race_array = tau_squads
--	print("doing spawn trickle")
	if race_name=="default" then
		race_name=Player_GetRaceName( g_Player2 )
	end
	race_array=get_squad_race_array(race_name)
--	UIWarning_Show("spawning a trickle for vplayer"..vplayer.." of race "..race_name.." at location "..location.." difficulty "..difficulty.." and stype "..stype)
	drop_trickle(player, vplayer, race_array, location, difficulty, stype, race_name)
end

--When we start the game, we determine how many players there are and such.
--If there are more human players, we want to increase the difficulty
--This is done by increasing the squad-cap for the various waves /trickles
--and by increasing the resources and stuff given to the enemy player
function recompute_difficulty()
	local looper=0
	local base=0
	--We do -1 because there is one bad-guy
	local num_players=World_GetPlayerCount() -1
	local orig_value=0
	--g_MapConfiguredFor
	if g_AutoRecompute==true then
		for looper=1,(table.getn(g_GamePlay)/8) do
			base=(looper*8) -7
			if g_GamePlay[base + 1] == "default" and Player_GetRaceName( g_Player2 ) == "ork_race" then
				--adjust for the difference in ork-cap from ordinary cap - I used to * 20, but too much
				g_GamePlay[base + 5] = g_GamePlay[base + 5] * 2
			end
			--Adjust in direct percentage.   Determine how many badguys per player and multiply
			--by the number of players actually in the game
			orig_value=g_GamePlay[base + 5]
			g_GamePlay[base + 5] = (g_GamePlay[base + 5] / g_MapConfiguredFor) * num_players
			if g_GamePlay[base + 5] < 10 and orig_value > 0 then 
				g_GamePlay[base + 5] = 10
			end
			orig_value=g_GamePlay[base + 6]
			g_GamePlay[base + 6] = (g_GamePlay[base + 6] / g_MapConfiguredFor) * num_players
			if g_GamePlay[base + 6] < 3 and orig_value > 0 then
				g_GamePlay[base + 6] = 3
			end
		end
	end
end

function seed_random(seed)
	local looper=seed
	print("Seeding random num with: "..genstring(seed))
	if g_hasbeenrandomized == false and type(seed) == "number" and seed >= 0 then
		looper = mymod(seed, 100)
		print("looper="..genstring(looper))
		while looper > 1 do
			World_GetRand( 1, 30 )
			looper = looper - 1
		end
		g_hasbeenrandomized = true
	end
end

function genscarerror()
	print("We are deliberately stopping SCAR here")
	print("for debugging purposes.  The error comes next.")
	generate_scar_error()
end

function random_seed()
	local looper
	local flag=false
	local total=0
	local playerinfo
	--This is an ugly routine that we really only want to call once...
	if g_hasbeenrandomized == false then
		for looper = 0, (World_GetPlayerCount() -1) do
			playerinfo=World_GetPlayerAt(looper)
			if Player_IsAlive( playerinfo ) then
				total=total+Player_GetSquadCount( playerinfo )
				total=total+Player_GetResource( playerinfo, RT_Requisition )
				total=total+Player_GetResource( playerinfo, RT_Power )
				total=total+Player_GetResource( playerinfo, RT_Pop )
				total=total+Player_GetBuildingSpawnedCount( playerinfo )
			end
		end
		total=mymod(total, 30)
		while total > 1 do
			World_GetRand( 1, 50 )
			total = total -1
		end
		g_hasbeenrandomized = true
	end
--	UIWarning_Show("random seed of "..total)
	--World_GetRand( 1, g_max_locations )
--	math.randomseed( 1003 )
end

function add_player(vplayer, game_play_index)
	--Spawn buildings
	--Register enemies
	--Put a ping on the map to show where the bases are
	--Write a message on the local player's screen saying a new wave happend
	--g_GamePlay #wave, race,   #location-on-board, trickle/wave, #difficulty, #squad-cap, #vehicle-cap	
	local flag=false
	local countdown=5
	local marker_test
	local base=(game_play_index * 8) - 7
	local location = g_GamePlay[base + 2]
	local race_name = g_GamePlay[base + 1]
	local difficulty = g_GamePlay[base + 4]
	if race_name=="default" then
		race_name=Player_GetRaceName( g_Player2 )
	end
	print("Adding vPlayer "..vplayer.." at location "..location.." race "..race_name)
	local timer=0
	timer = g_GamePlay[base + 7] 
	if location == "random" then
		--Their random function is pitiful.  So we use the built-in one.  We need to get a random something, so we get a seed value...
		random_seed()
		while flag == false and countdown > 0 do
			location=""..World_GetRand( 1, g_max_locations )  --This should be a string. Hopefully it is
			print("random location of "..location)
			--We do a quick test to see if the location exists.  This is not a complete scan of all points, but they should have one HQ
			if Marker_Exists(location.."-hq-1","basic_marker") then
				--Ahhh.  We do have a workable location.  Let's use it!
				flag=true
			else
				location=""..1
			end
			countdown = countdown -1
		end
	end
	local to_own = g_Player2
	if g_debug == true then
		to_own = g_Player1
	end
	if race_name ~= "tyranid_race" then
		drop_base(to_own, location, race_name, vplayer)
	else
		local leadername=vplayer.."_tyranid_leader"
		local spawnleader=tyranids_squad_lictor
		local markername=location.."-hq-1"
		if difficulty == 1 then
			spawnleader="tyranids_squad_lictor"
		elseif difficulty == 2 then
			spawnleader="tyranids_squad_broodlord"
		elseif difficulty == 3 then
			spawnleader="tyranids_squad_trygon"
		end
		print ("Creating a tyranid leader "..spawnleader)
		if SBP_Exists(spawnleader) then
			--protected against no blueprint
			Util_CreateSquadsAtMarkerEx( g_Player2, leadername, spawnleader, markername , 1, 1)
		else
			--If we need tyranids but the leader will not spawn, the game is basically toast
			--We will create the sgroup, which will let the game think it has been killed.
			--This will be a quick wave
			print("WOAH! No Tyranid leader.  Tyranid mod not loaded?: "..genstring(spawnleader))
			SGroup_CreateIfNotFound(leadername)
		end
	end
	--print("Adding vPlayer "..vplayer.." at location "..location.." race "..race_name.." and timer "..timer.."  from index "..game_play_index )
	if vplayer > 0 then
--		if (vplayer * 4) > table.getn(virtual_enemy_array) then
			virtual_enemy_array[(vplayer * 4) -3] = location		--location
			virtual_enemy_array[(vplayer * 4) -2] = timer			--delay-between (this is the value that the counter is reset to)
			virtual_enemy_array[(vplayer * 4) -1] = 1				--var-delay-between (this is the counter that counts down every second)
			virtual_enemy_array[(vplayer * 4) ] = game_play_index	--index in "game-play"
--		end
	end
	local looper=0
	--Remove any legacy "kill player" stuff
	if g_DeadPlayers == nil then
		g_DeadPlayers={}
	end
	for looper = 1, table.getn(g_DeadPlayers) do
		if g_DeadPlayers[looper] == "enemyS"..location or g_DeadPlayers[looper] == "enemyV"..location then 
			print("getting rid of the extra player death stuff")
			g_DeadPlayers[looper] = ""
		end
		if g_DeadPlayers[looper] == "tyranid_"..location.."deadgroup" then 
			print("getting rid of the extra player death stuff")
			g_DeadPlayers[looper] = ""
		end
	end
	g_alive_enemies = g_alive_enemies + 1
end


function add_wave()
	--We will loop through the list to add the players for the wave
	local looper = 0
	for looper = 1, (table.getn(g_GamePlay)/8) do
		if g_GamePlay[(looper * 8) - 7] == g_wave_number then
			g_last_vplayer = g_last_vplayer + 1
			add_player(g_last_vplayer, looper)
		end
	end
	--UIWarning_Show("Wave "..g_wave_number.." of "..g_end_wave.." has begun!")
	g_wave_number  = g_wave_number  + 1
	print("We just moved to wave "..g_wave_number)
end

function grant_all_research(player)
	local looper
	for looper = 1, table.getn(g_AllResearch) do
		Player_GrantResearch( player, g_AllResearch[looper] )
	end
end

function mymod(num1, num2)
	local tot=num1
	local value=0
--	while tot >= num2 do
--		tot = tot - num2
--	end
	value=math.floor(num1 / num2)
	tot= num1 - (value * num2)
	return tot
end

--Here we check to see how the game is progressing.  DO we need to start a timer?  Add a player?
function game_control()
	local count=0
	local testnum=table.getn(virtual_enemy_array) / 4
	local testnum2=virtual_enemy_array[ (1 * 4) -1 ]

	gametime()
	display_messages()
	--print("wave="..genstring(g_wave_number).." wave_timer="..genstring(g_wave_timer))
	if g_end_time > 0 then
		--we are in the end times.  Call the end_time program and keep counting
		if g_end_time == 1 then
			--clear out any rogue messages
			W40k_ShowSystemMessage("")
		end
		end_game()
		g_end_time=g_end_time + 1
	else
		do_all_rules()
		if g_alive_enemies > 0 then
			--we have alive enemies.  Do we need to do a wave or trickle?
			--UIWarning_Show("You have "..g_alive_enemies.." left")
			
			--Check the coundown variable
			local looper
			for looper = 1, (table.getn(virtual_enemy_array) / 4) do
				count=count + 1
				if virtual_enemy_array[ (looper * 4) - 3 ] ~= "-1" then -- They have a location if they are not dead
					--print("they have a location and are not dead")
					if virtual_enemy_array[ (looper * 4) -1 ] < 1 then
						--set the timer back to when the next time is.  This will take into consideration if it is a trickle or wave
						virtual_enemy_array[ (looper * 4) -1 ] = virtual_enemy_array[ (looper * 4) -2 ]
						--If it is a tricke, do a trickle.  If a wave, do a wave
						--print("do a wave or trickle")
						if g_GamePlay[ (virtual_enemy_array[ (looper * 4) ] * 8) -4 ] == "wave" then
							spawn_wave(g_Player2, looper, "squad")
							spawn_wave(g_Player2, looper, "vehicle")
							--UIWarning_Show("Dropping a wave!")
						elseif g_GamePlay[ (virtual_enemy_array[ (looper * 4) ] * 8) -4 ] == "trickle" then
							spawn_trickle(g_Player2, looper, "squad")
							spawn_trickle(g_Player2, looper, "vehicle")
						elseif g_GamePlay[ (virtual_enemy_array[ (looper * 4) ] * 8) -4 ] == "wave-trickle" then
							--set it to be a trickle from here on out
							g_GamePlay[ (virtual_enemy_array[ (looper * 4) ] * 8) -4 ] = "trickle"
							spawn_wave(g_Player2, looper, "squad")
							spawn_wave(g_Player2, looper, "vehicle")
							--UIWarning_Show("Dropping a wave!")

						end
					end
					virtual_enemy_array[ (looper * 4) -1 ] = virtual_enemy_array[ (looper * 4) -1 ] - 1
				end
			end
		else
			if g_already_spawning == true then
				if g_wave_timer > 0 then
					if g_wave_timer <= 60 then
						if mymod(g_wave_timer, 10) == 0 then
							UIWarning_Show("New wave in "..g_wave_timer.." seconds")
						end
					end
					if g_wave_timer < 10 then
						UIWarning_Show("New wave in "..g_wave_timer.." seconds")
					end
					g_wave_timer = g_wave_timer -1
				else
					--W40k_ShowSystemMessage("")
					g_already_spawning = false
					--spawn a wave
					if g_wave_number == g_end_wave then
						--Last wave
						Permitted_to_destroy_enemy=true
						--UIWarning_Show("You may attack the main base.")
					end
					add_wave()
				end
			else
				--set the timer to run
				if g_wave_number > g_end_wave then
					--W40k_ShowSystemMessage("")
					--We finished the last wave.  We are basically done
					if g_end_game_after_waves == true then
						--We are supposed to end the game when the waves are finished.
						--Start that process
						g_end_time=1
					end
				else
					--W40k_ShowSystemMessage("")
					--We have waves to go.  Let's start a timer for when it will happen
					g_already_spawning = true
					--We use g_WaveDelay if it is set
	--				if g_WaveDelay ~= nil then
						if table.getn(g_WaveDelay) >= g_wave_number then
							g_wave_timer=g_WaveDelay[g_wave_number]
							print("wave timer set from array")
						else	
							if table.getn(g_WaveDelay) > 0 then
								g_wave_timer=g_WaveDelay[table.getn(g_WaveDelay)]
								print("getting wave delay from last item in array")
							else
								--Nothing is set
								g_wave_timer = g_wave_timer_max
								print ("no wave delay array set so drawing from constant of "..g_wave_timer_max)
							end
						end
	--				else
	--					g_wave_timer = g_wave_timer_max
	--				end
					print("setting the wave ("..g_wave_number..") timer for "..g_wave_timer.." seconds")
					if g_debug == true then 
						--g_wave_timer = 10
					end
				end
			end
		end
		allow_actions()
		do_actions()
		check_ownership()
		virt_player_alive_check()
		--We will need to do this for all players.  Humans do not die appropriately either
		death_check(g_Player2)
		for looper = 1, table.getn(g_DeadPlayers) do
			if g_DeadPlayers[looper] ~= "" then
				if string.find(g_DeadPlayers[looper],"tyranid_") then
					if SGroup_Count(g_DeadPlayers[looper]) > 0 then
						local tmpval=SGroup_GetAvgHealth( g_DeadPlayers[looper]  )
						print("avg health for group "..genstring(g_DeadPlayers[looper]).." is "..genstring(tmpval))
						tmpval=tmpval - 0.05
						SGroup_SetAvgMorale(g_DeadPlayers[looper] ,0)
						--print("Morale invulnerable= "..SGroup_GetMoraleInvulnerable( g_DeadPlayers[looper] , false ))
						if tmpval < 0 then
							SGroup_SelfDestroy(g_DeadPlayers[looper],false)
						else
							SGroup_SetAvgHealth( g_DeadPlayers[looper],tmpval)
						end
					else
						g_DeadPlayers[looper]=""	
					end
				else
					if SGroup_Count(g_DeadPlayers[looper]) > 0 then
						SGroup_SelfDestroy(g_DeadPlayers[looper],false)
					end
				end
			end
		end
	end
end

function allow_actions()
	local action_num=0
	local looper=0
	local actions= table.getn(g_WaveActions) / 7
	local bonuses= table.getn(g_Bonus) / 6
	local bonus_base=0
	local doit_flag=false
	local t_action_allow={}
	if action_allow == nil then
		action_allow={}
	end
	for action_num=1, actions do
		--mark everything as being unset
		t_action_allow[action_num]=0
	end
--	print("checking for bonus to allow rules bonuses="..bonuses)
	--point,"player|enemy|any", "egroup|sgroup|squad|enable|disable|prefer-enable|prefer-disable","groupname", health|rulenum, timer
	for looking_for = 1, 4 do
		for looper=1, bonuses do
			bonus_base=(looper * 6) -5
			local markergroup=g_Bonus[bonus_base ]
			local whoto=g_Bonus[bonus_base+1 ]
			local targetgroup=g_Bonus[bonus_base + 2]
			local callit=g_Bonus[bonus_base+3 ]
			local rule=g_Bonus[bonus_base+4 ]
			local grouptimer=g_Bonus[bonus_base + 5 ]
			--print ("targetgroup = "..targetgroup)
			if targetgroup == "enable" or targetgroup == "disable" or targetgroup == "prefer-enable" or targetgroup == "prefer-disable" then
				--print("found a rule "..targetgroup)
				for player_looper = 0, World_GetPlayerCount() -1 do
					doit_flag=false
					if whoto == "enemy" then
						team = 1
						--print("team is enemy")
					elseif whoto == "player" then
						--print("team is player")
						team = 0
					else
						--print("we are not sure who the team is")
						team = Player_GetTeam(World_GetPlayerAt(player_looper))
					end
					if team == Player_GetTeam(World_GetPlayerAt(player_looper)) then
						correct_team=true
					else
						correct_team=false
					end
					if EGroup_Exists( markergroup ) and correct_team == true then
						--print("correct team for player "..player_looper)
						if EGroup_IsCapturedByPlayer( markergroup, World_GetPlayerAt(player_looper), false ) then
							--the point is captured and this rule applies to this player
							doit_flag=true
							--print (markergroup.." captured. doit=true ")
						end
						if looking_for == 1 and targetgroup == "enable" then
							--print ("found an enable rule")
							if doit_flag==true then
								t_action_allow[rule]=1
							else
								t_action_allow[rule]=2
							end
						end
						if looking_for == 2 and targetgroup == "disable" then
							--print ("found an disable rule")
							if doit_flag==true then
								t_action_allow[rule]=2
							else
								t_action_allow[rule]=1
							end
						end
						if looking_for == 3 and targetgroup == "prefer-enable" then
							--print ("found a prefer-enable rule, previously it was"..t_action_allow[rule])
							if doit_flag==true then
								t_action_allow[rule]=1
							else
								--if it is already set, we will not unset it.  We prefer it enabled
								if t_action_allow[rule] ~= 1 then
									t_action_allow[rule]=4
								end
							end
							--print ("we set it to be: "..t_action_allow[rule])
						end
						if looking_for == 4 and targetgroup == "prefer-disable" then
							--print ("found a prefer-disable rule, previously it was "..t_action_allow[rule])
							if doit_flag==true then
								t_action_allow[rule]=2
							else
								if t_action_allow[rule] ~= 2 then
									t_action_allow[rule]=3
								end
							end
							--print ("we set it to be: "..t_action_allow[rule])
						end	
--						if t_action_allow[rule]==true then
--							print("We decided to allow rule "..rule)
--						else
--							print("we decided to deny rule "..rule)
--						end
					end
				end
			end
		end
	end
	for action_num=1, actions do
		if t_action_allow[action_num]==0 or t_action_allow[action_num]==1 or t_action_allow[action_num]==3 then
			action_allow[action_num]=true
		else
			--2 or 4
			action_allow[action_num]=false
		end
	end

end

--g_WaveActions="before|during|not", wave#, "teleport|destroy|building-once|building|squad|squad-once", "enemy|player", "marker", "blueprint|dest-marker", timer
function do_actions()
	local action_num=1
	local base=1
	local do_action=false
	local tf=""
	local actions= table.getn(g_WaveActions) / 7
	--UIWarning_Show("Actions to check="..actions)
	if g_already_spawning == true then
		tf = "true"
	else
		tf="false"
	end
	for action_num=1, actions do
		do_action=false
		base=(action_num * 7) -6     --first chunk of the g_WaveActions array
		action_when=g_WaveActions[base]
		action_wave=g_WaveActions[base+1]
		action_what=g_WaveActions[base+2]
		action_who=g_WaveActions[base+3]
		action_where=g_WaveActions[base+4]
		action_with=g_WaveActions[base+5]
		action_delay=g_WaveActions[base+6]
		--The wave number is incremented once the buildings have landed.
		--The wave spawning is when we have realized the new wave is going to come and we start a countdown.  But the wave# has not increased yet
		
		--UIWarning_Show("Checking actions: currentwave"..g_wave_number.."  action wave "..g_WaveActions[base+1].." time="..g_WaveActions[base].."spawning="..tf)
		if action_wave == g_wave_number and g_already_spawning == true and action_when == "before" then
			--This is during the wave
			do_action=true
		elseif action_wave == (g_wave_number - 1) and g_already_spawning == false and action_when == "during" then
			--This is before the wave
			do_action=true
		elseif  not (action_wave == (g_wave_number - 1) and g_already_spawning == false) and action_when == "not" then
			--This is if we have a "not"
			do_action=true
		elseif action_when == "always" then
			--if we are told to always do this action for all waves, etc
			if action_wave ~= 0 then
				--We set the wave to 0 if the action is only supposed to happen once
				--You would think a "building-once" should not be set for "always" but
				--we check for it anyways
				do_action=true
			end
		end
		if action_allow[action_num] == false then
			--If there is a point that must be taken before this rule can fire
			do_action=false
		end
		if do_action == true then
			if g_ActionDelay[action_num] < 1 then
				--reset the action delay for this action
				g_ActionDelay[action_num] = action_delay
				--The time is right, now we see about implimenting it
				if action_what == "building-once" or action_what == "squad-once" or
				   action_what == "resources-once" or action_what=="fow-once" then
					g_WaveActions[base+1]=0  --set the wave number to 0 so it never happens again
				end
				if action_what == "building-once" or action_what == "building" then
					--We create a building at the correct location
					special_spawn_building(action_who, action_where, action_with, action_num)
				elseif action_what == "squad-once" or action_what == "squad" then
					--We generate a squad at the correct location
					special_spawn_squad(action_who, action_where, action_with, action_num)
				elseif action_what == "teleport" then
					--We teleport anyone near the given marker
					check_marker(action_who, action_where, action_with, "teleport")
				elseif action_what == "destroy" then
					check_marker(action_who, action_where, action_with, "destroy")
					--We destroy anything near a given marker
				elseif action_what == "save" then
					--see if there is anything to save near the marker
					check_marker(action_who, action_where, action_with, "save")
				elseif action_what == "fow" or action_what == "fow-once" then
					--set the fog of war
					--We also need to be able to turn it on and off for squads/entities/markers
					if action_where == "" or action_where == "map" then
						if action_who == "off" then
							print("revealing all (FOW off)")
							 FOW_RevealAll()
						else
							print("hiding everything (FOW on)")
							 FOW_UnRevealAll()
						end
					else
						--Is it a squad/entity/marker?
						if SGroup_Exists(action_where) then
							FOW_RevealSGroup( SGroup_FromName(action_where), action_delay +1 )
						end
						if EGroup_Exists(action_where) then
							FOW_RevealEGroup( EGroup_FromName(action_where), action_delay +1 )
						end
						if Marker_Exists(action_where, "basic_marker") then
							FOW_RevealMarker( action_where , action_delay + 1)
						end
					end
				elseif action_what == "spawn-entity" then
					--If it is hidden, show it
					g_WaveActions[base+1]=0
					if EGroup_Exists(action_where) then
						if EGroup_Count(action_where) > 0 then
							EGroup_ReSpawn(action_where)
						end
					end
				elseif action_what == "base" then
					--only build a base once
					g_WaveActions[base+1]=0
					--action_who, action_where (location), action_with(race)
					local player=0
					if action_who == "player" then
						action_who="player1"
					end
					if type(action_where) == "string" then
						action_where=tonumber(action_where)
					end
					if action_where > 0 then
						if action_with == "" then
							action_with="default"
						end
						player=string.sub(action_who,7)
						print ("we calculate the player to be "..player)
						base_for_player(player, action_where, action_with, "regular",1)
					end
				elseif action_what == "compact-base" or action_what== "reverse-compact-base" then
					--only build a base once
					g_WaveActions[base+1]=0
					--action_who, action_where (location), action_with(race)
					local player=0
					if action_who == "player" then
						action_who="player1"
					end
					if Marker_Exists(action_where,"basic_marker") then
						if action_with == "" then
							action_with="default"
						end
						player=string.sub(action_who,7)
						print ("we calculate the player to be "..player)
						if action_what == "compact-base" then
							base_for_player(player, action_where, action_with, "compact",1)
						else
							base_for_player(player, action_where, action_with, "compact",-1)
						end
					end
				elseif action_what == "despawn-entity" then
					--This effectively hides it until it is supposed to be there
					g_WaveActions[base+1]=0
					print ("Trying to despawn "..action_where)
					if EGroup_Exists(action_where) then
--						if EGroup_Count(action_where) > 0 then
							EGroup_DeSpawn(action_where)
							print ("Should have despawned the entity")
--						end
					end
				elseif action_what == "message" then
					--print a message one time for the time-period
					--We may have an "always" or something like that, so we have a counter
					--to make sure we only do it once per time-period
					if g_messagerule== nil then
						g_messagerule={}
						g_messagepos={}
					end
					if g_messagerule[action_num] == nil  then
						g_messagerule[action_num] = 0
						g_messagepos[action_num]=0
					end
--					print ("we are trying to print ("..g_messagerule[action_num]..") compared to "..(g_wave_number * 2))
					if g_messagerule[action_num] < (g_wave_number * 2) and 
					  (action_when == "before" or action_when == "always") then
							--print("original message="..action_where.."  startpos="..g_messagepos[action_num])
							action_where=string.sub(action_where, g_messagepos[action_num])
							--print("shortened message="..action_where)
							--We just grabbed everything after the last \n if there was one
							local nextpos=string.find( action_where, "\n")
							if nextpos ~= nil then
								--print("we found a newline at "..nextpos)
								action_where = string.sub(action_where, 0, nextpos)
								--print("new string is "..action_where)
								g_messagepos[action_num]= g_messagepos[action_num]+ nextpos+1 --skip the \n
							else
								g_messagepos[action_num] = g_messagepos[action_num] + string.len(action_where) +1
							end
							--at this time, action_where is just one line long
							--print("the final message is-"..action_where.."-")
							W40k_ShowSystemMessage( action_where )
							if action_where == "" then
								--we have finished printing it
								--print("that was the end.  We printed nothing")
								g_messagerule[action_num] = (g_wave_number * 2)
								g_messagepos[action_num] = 0 --reset in case we need to print it again
							end
					elseif g_messagerule[action_num] <= (g_wave_number * 2) and action_when == "during" or action_when == "always" then
							--print("printing (during) "..action_what)
							--g_messagerule[action_num] = (g_wave_number * 2) + 1
							--W40k_ShowSystemMessage( action_where )
							--UIWarning_Show( action_where )
							--print("original message="..action_where.."  startpos="..g_messagepos[action_num])
							action_where=string.sub(action_where, g_messagepos[action_num])
							--print("shortened message="..action_where)
							--We just grabbed everything after the last \n if there was one
							local nextpos=string.find( action_where, "\n")
							if nextpos ~= nil then
								--print("we found a newline at "..nextpos)
								action_where = string.sub(action_where, 0, nextpos)
								--print("new string is "..action_where)
								g_messagepos[action_num]= g_messagepos[action_num]+ nextpos+1 --skip the \n
							else
								g_messagepos[action_num] = g_messagepos[action_num] + string.len(action_where) +1
							end
							--at this time, action_where is just one line long
							--print("the final message is-"..action_where.."-")
							W40k_ShowSystemMessage( action_where )
							if action_where == "" then
								--we have finished printing it
								--print("that was the end.  We printed nothing")
								g_messagerule[action_num] = (g_wave_number * 2)+1
								g_messagepos[action_num] = 0 --reset in case we need to print it again
							end
					else
						--W40k_ShowSystemMessage( "" )
						--W40k_Letterbox( false, 1)
					end
				elseif action_what == "command" then
					--command to attack
				elseif action_what == "grant_research" then
					target=action_with
					g_WaveActions[base+1]=0  --set the wave number to 0 so it never happens again
					--Player_GrantResearch( PlayerID player, String researchName )
					if action_who == "enemy" then
						print("granting research "..target.." to enemy")
						if target == "all" then
							grant_all_research(g_Player2)
						else
							Player_GrantResearch( g_Player2, target )
						end
					else
						local looper=0
						for looper = 0, World_GetPlayerCount() -1 do
							if Player_GetTeam(World_GetPlayerAt(looper)) == 0 then
								if target == "all" then
									grant_all_research(World_GetPlayerAt(looper), target )
								else
									Player_GrantResearch( World_GetPlayerAt(looper), target )
								end 
							end
						end
					end
				elseif action_what == "uncapture" then
					print ("trying to uncapture "..action_where)
					if EGroup_Exists(action_where) then
						--EGroup_SelfDestroy( action_where, false)
						--EGroup_Uncapture(action_where)
						my_uncapture(action_where)
					end
				elseif action_what == "revoke_research" then
					g_WaveActions[base+1]=0  --set the wave number to 0 so it never happens again
					if action_who == "enemy" then
						Player_RestrictResearch( g_Player2, target )
					else
						local looper=0
						for looper = 0, World_GetPlayerCount() -1 do
							if Player_GetTeam(World_GetPlayerAt(looper)) == 0 then
								Player_RestrictResearch( World_GetPlayerAt(looper), target )
							end
						end
					end
				elseif action_what == "restrict-ai" or action_what== "restrict_ai" then
					print("thinking about restricting_ai  "..action_who)
					--restrict or unrestrict the AI
					if action_where == "on" then
						print("enabling CPU building")
						Cpu_EnableComponent( g_Player2, false, CT_BuildUnits)
						Cpu_EnableComponent( g_Player2, false, CT_BuildBuildings)
						Cpu_EnableComponent( g_Player2, false, CT_Resourcing)
						Cpu_EnableComponent( g_Player2, false, CT_BuildResearch)
						Cpu_EnableComponent( g_Player2, false, CT_BuildAddOns)
					elseif action_where == "off" then
						print("disabling CPU building")
						Cpu_EnableComponent( g_Player2, false, CT_BuildUnits)
						Cpu_EnableComponent( g_Player2, false, CT_BuildBuildings)
						Cpu_EnableComponent( g_Player2, false, CT_Resourcing)
						Cpu_EnableComponent( g_Player2, false, CT_BuildResearch)
						Cpu_EnableComponent( g_Player2, false, CT_BuildAddOns)
					end
				elseif action_what == "resources" or action_what == "resources-once" then
					--set the resource level for players
					print("trying to add resources")
					if action_who == "enemy" then
						if action_where == "ork" then
							--Player_SetResource( PlayerID player, Integer resourceType, Real amt )
							--RT_Requisition, RT_Power, RT_Pop.
							Player_SetResource( g_Player2, RT_Pop, action_with )
						elseif action_where == "power" then
							Player_SetResource( g_Player2, RT_Power, action_with )
						elseif action_where == "req" then
							Player_SetResource( g_Player2, RT_Requisition, action_with )
						else
							Player_SetResource( g_Player2, RT_Power, action_with )
							Player_SetResource( g_Player2, RT_Requisition, action_with )
							--for the ork-pop.  Power and req are in thousands, pop in hundreds
							action_with=action_with / 50 
							Player_SetResource( g_Player2, RT_Pop, action_with )
						end
					else
						for looper = 0, World_GetPlayerCount() -1 do
							if Player_GetTeam(World_GetPlayerAt(looper)) == 0 and Player_IsAlive(World_GetPlayerAt(looper)) then
								print("trying to add resource "..action_where.." to player amount="..action_with)
								if type(action_with) == "string"then
									action_with=tonumber(action_with)
								end
								if action_with == nil then
									action_with=0
								end
								if action_where == "ork" then
									--Player_SetResource( PlayerID player, Integer resourceType, Real amt )
									--RT_Requisition, RT_Power, RT_Pop.
									Player_SetResource( World_GetPlayerAt(looper), RT_Pop, action_with )
								elseif action_where == "power" then
									print("adding it to "..looper)
									Player_SetResource( World_GetPlayerAt(looper), RT_Power, action_with )
								elseif action_where == "req" or action_where=="requisition" then
									Player_SetResource( World_GetPlayerAt(looper), RT_Requisition, action_with )
								else -- set them all!
									Player_SetResource( World_GetPlayerAt(looper), RT_Power, action_with )
									Player_SetResource( World_GetPlayerAt(looper), RT_Requisition, action_with )
									--for the ork-pop.  Power and req are in thous, pop in hundreds
									local tempval=action_with / 50 
									Player_SetResource( World_GetPlayerAt(looper), RT_Pop, tempval )
								end
							end
						end
					end
				end
			else
				g_ActionDelay[action_num] = g_ActionDelay[action_num] - 1
			end
		else
			--print("Nothing to do!")
		end
	end
end


function my_uncapture(egroup)
	local pos
	local individ_ent
	
	local cu=function(groupid, itemindex, myentityID)
		local mypos
		local thisgroup=EGroup_CreateIfNotFound("focustest")
		local blueprintlist=Util_MakeBlueprintTable("chaos_listening_post", "eldar_listening_post",
			"guard_listening_post","necron_listening_post","ork_listening_post",
			"space_marine_listening_post","tau_listening_post")
		EGroup_Clear("focustest")
		EGroup_Add("focustest", myentityID)
		mypos=EGroup_GetPosition("focustest")
		print("looking at x="..mypos.x.."  y="..mypos.y.."  z="..mypos.z.." for a capped point")
		if mypos.x == pos.x and mypos.y == pos.y and mypos.z == pos.z then
			--print ("two entities..  Base="..individ_ent.." checking="..myentityID)
			--if EGroup_Compare(myentityID,individ_ent)  then
			if EGroup_ContainsBlueprints( thisgroup,blueprintlist, false ) == true then
				--we do not want to remove itself
				print("We have something on the point!  Remove it.")
				Entity_Destroy(myentityID)
			end
		else
			print ("nothing on the point")
		end
	end

	local fcu=function(groupid, itemindex, entityID )
		EGroup_CreateIfNotFound("cleartest")
		EGroup_Clear("cleartest")
		EGroup_Add("cleartest",entityID)
		pos=EGroup_GetPosition("cleartest")
		print("checking items for being capped! x="..pos.x.."  y="..pos.y)
		local player_looper
		local player_owner
		local doitflag=false
		for player_looper = 0, World_GetPlayerCount() -1 do
			if Entity_IsCapturedByPlayer( entityID, World_GetPlayerAt(player_looper)) then
				doitflag=true
				player_owner=player_looper
				print("the point is captured by player "..player_owner + 1)
			end
		end
		if entityID ~= nil and doitflag == true then
			print ("Someone owns the point")
			if Entity_GetWorldOwner(entityID) == false then
				print("  The world does not own it")
				--Someone owns it.  We can un-cap it
				local player_entities=Player_GetEntities( Entity_GetPlayerOwner( entityID ))
				individ_ent=entityID
				--print("base="..entityID)
				EGroup_ForEach(player_entities,cu)
			
--				local tempgroup EGroup_Create("UncapturePoint")
--				tempgroup=EGroup_FromName("UncapturePoint")
--				local testcount=10
--				local count = EGroup_Count( tempgroup )
--				print ("  we find "..count.." things in tempgroup.  Should be 1")
--				EGroup_Add(tempgroup, entityID )
--				if Entity_IsStrategicPoint( entityID ) then
--					print ("attempting individual uncapture")
--					EGroup_Uncapture(tempgroup)
--					if Entity_IsCapturedByPlayer( entityID, World_GetPlayerAt(player_owner)) then
--						print("the point is still captured")
--					end
--					print ("player "..(player_owner + 1).." was the one that owned it.  Testcount="..testcount)
--					while Entity_GetWorldOwner( entityID ) == false and testcount > 0 do
--						print ("trying to uncapture it again.  Testcount="..testcount)
--						EGroup_ResetPlayerOwner( tempgroup )
--						EGroup_Uncapture( tempgroup )
--						testcount = testcount -1
--					end
--				end
--				EGroup_Destroy(tempgroup)
				if Entity_IsStrategicPoint( entityID ) then
					local direction=0
					print ("UNCAP: Copying entity info")
					local blueprint=Entity_GetBlueprintName( entityID )
					local position=Entity_GetPosition( entityID )
					print ("UNCAP: disposing of the "..blueprint)
					EGroup_SelfDestroy(egroup,false)
					EGroup_DestroyAllEntities( egroup ) 
					print ("UNCAP: destroying the group "..egroup)
					EGroup_Destroy(egroup)
					EGroup_Create(egroup)
					print ("UNCAP: making a duplicate "..blueprint)
					--local newitem=Entity_Create( blueprint, g_Player2, position )
					position.z=position.z-1
					local diditwork=Entity_CreateBuildingPosition(g_Player2,egroup,blueprint,position,1.0)
					while not diditwork and direction < 6 do
						direction=direction+1
						print("It did not spawn.  We need to do some quick stepping")
						if direction==1 then
							position.x=position.x-1
						elseif direction ==2 then
							position.z=position.z+2
						elseif direction ==3 then
							position.x=position.x+2
						elseif direction ==4 then
							position.x=position.x-1
							position.z=position.z-1
						elseif direction ==5 then
							--We are in trouble.  We tried to spawn it and it did not work.  Try again
						elseif direction ==6 then
							--We are in trouble.  We tried to spawn it and it did not work.  Try again
						end
						diditwork=Entity_CreateBuildingPosition(g_Player2,egroup,blueprint,position,1.0)
					end
					--print ("the item is "..newitem)
					--if newitem==nil then
						--The item somehow failed to create. This is bad.  Try again.
					--	print("UNCAP: previous attempt failed.  Trying again")
					--	newitem=Entity_CreateBuildingMarker(g_Player2,egroup,blueprint,position,1.0)
					--end
					--print ("UNCAP: creating a new group "..egroup)
					--EGroup_Create(egroup)
					--print ("UNCAP: Re-Adding to the egroup "..egroup)
					--EGroup_Add(egroup, newitem)
				end
			else
				print("entity already owned by world")
			end
		end
	end
	local blueprintlist=Util_MakeBlueprintTable("strategic_point_flag", "relic_struct",
		"strategic_objective_struct")
	EGroup_ForEach(EGroup_FromName(egroup),fcu)
	local countofem=EGroup_Count(EGroup_FromName(egroup))
	--print ("trying to uncapture "..egroup.." contains "..countofem.." items")
	EGroup_Uncapture(egroup)
	--EGroup_ResetPlayerOwner(egroup)
end

function check_ownership()
--point,"player|enemy|any", "egroup|sgroup|squad|enable|disable|prefer-enable|prefer-disable","groupname", health|rulenum, timer
	local looper = 1;
	--print("checking ownership")
	local player_looper=0;
	local groups=0;
	local give_groups=0;
	local players=0;
	local printed_flag = false
	local captured = 0;
	local correct_team=false;
	while (looper * 6) <= table.getn(g_Bonus) do
		base=(looper * 6)-5
		local markergroup=g_Bonus[base ]
		local whoto=g_Bonus[base+1 ]
		local targetgroup=g_Bonus[base + 2]
		local callit=g_Bonus[base+3 ]
		local health=g_Bonus[base+4 ]
		local grouptimer=g_Bonus[base + 5 ]
		if targetgroup == "enable" or targetgroup=="disable" or targetgroup == "prefer-enable" or targetgroup=="prefer-disable" then
			--here we do nothing
		else
			for player_looper = 0, World_GetPlayerCount() -1 do
				if whoto == "enemy" then
					team = 1
					--print("team is enemy")
				elseif whoto == "player" then
					--print("team is player")
					team = 0
				else
					--print("we are not sure who the team is")
					team = Player_GetTeam(World_GetPlayerAt(player_looper))
				end
				if team == Player_GetTeam(World_GetPlayerAt(player_looper)) then
					correct_team=true
				else
					correct_team=false
				end
				if EGroup_Exists( markergroup ) and ( targetgroup == "endgame" or targetgroup == "end-game" ) then
					if EGroup_IsCapturedByPlayer( markergroup, World_GetPlayerAt(player_looper), false ) and correct_team == true then
						g_end_time=1
					end
				elseif EGroup_Exists( markergroup ) and ( targetgroup == "uncap" or targetgroup == "uncapture" ) then 
					print ("trying to uncapture "..callit)
					if EGroup_Exists(callit) then
						my_uncapture(callit)
					end
				elseif EGroup_Exists( markergroup ) and ( targetgroup == "killvplayer" or targetgroup == "kill-vplayer" ) then
					if EGroup_IsCapturedByPlayer( markergroup, World_GetPlayerAt(player_looper), false ) and correct_team == true then
						--the vplayer info is stored in the same number position that "health" is
						--print ("we are looking at a "..type(health))
						print("A point is taken, and killvplayer is set")
						if type(health) == "table" then
							--hey.  It is an array!
							local myloop=0
							for myloop = 1,table.getn(health) do
								destroy_vplayer(health[myloop])
							end
						else
							destroy_vplayer(health)
						end
					end
				elseif EGroup_Exists( markergroup ) and EGroup_Exists( targetgroup ) then
					groups=groups + 1;
					if EGroup_IsCapturedByPlayer( markergroup, World_GetPlayerAt(player_looper), false ) then
						--print("Egroup "..markergroup.." exists and egroup "..targetgroup.." exists.  giving it to player")
						if correct_team == true then
							EGroup_SetPlayerOwner( targetgroup, World_GetPlayerAt(player_looper) )
						else
							EGroup_ResetPlayerOwner( targetgroup )
						end
					end
				elseif EGroup_Exists( markergroup ) and SGroup_Exists( targetgroup ) then
					if EGroup_IsCapturedByPlayer( markergroup, World_GetPlayerAt(player_looper), false ) then
						--print("Egroup "..markergroup.." exists and sgroup "..targetgroup.." exists.  giving it to player")
						if correct_team == true then
							SGroup_SetPlayerOwner( targetgroup, World_GetPlayerAt(player_looper) )
						else
							SGroup_ResetPlayerOwner( targetgroup )
						end
					end
				elseif EGroup_Exists( markergroup ) then
					-- The second one may not be an egroup.  Try to spawn it for the player
					if EGroup_IsCapturedByPlayer( markergroup, World_GetPlayerAt(player_looper), false ) then
						--print("egroup "..markergroup.." exists and is captured")
						local groupname=markergroup.."_"..looper
						local marker_position=EGroup_GetPosition( EGroup_FromName( markergroup ))
						if SGroup_Exists( groupname ) then
							--If the item exists but is owned by someone else, kill it.
							local squad=SGroup_FromName( groupname )
							--The group exists, but the item may have died.  If dead, we can re-spawn..
							if  SGroup_Count( squad ) <  1 then
								if g_BonusDelay[looper] > 0 then
									--delay for now.  We will try again in a second
									g_BonusDelay[looper]=g_BonusDelay[looper] -1
								else
									if SBP_Exists(targetgroup) then
										print("the sgroup exists and a new one is needed")
										--The delay has transpired.  Give them the bonus
										if correct_team == true then
											--print("we think it is the correct team")
											--Protected against no blueprint
											local entity=Util_CreateSquadsAtPositionEx(World_GetPlayerAt(player_looper), groupname, targetgroup ,  marker_position, 1, 0)
											if health > 0 and health <= 1 then
												--set the health of the item spawned.  Mostly used for civilians which are so incredibly tough
												SGroup_SetAvgHealth( groupname , health)
											end
											if callit ~= "" then
												if not SGroup_Exists(callit) then
													SGroup_Create(callit)
												end
												SGroup_AddGroup(SGroup_FromName(callit), entity)
											end
											g_BonusDelay[looper]=grouptimer
										end
									else
										print("No such blueprint: "..targetgroup)
									end
								end
							else
								--print("the sgroup "..groupname.." exists")
								--it exists already.  We will set the ownership
								--in case the point just changed hands
								if correct_team == true then
									SGroup_SetPlayerOwner( groupname, World_GetPlayerAt(player_looper) )
								else
									--The other player cannot own it, so it dies!
									SGroup_SelfDestroy( groupname, false)
								end
							end
						else
							--The group does not exist yet.  Spawn it.
							--print("the group does not exist yet.  Try to create it")
							if SBP_Exists(targetgroup) then
								if correct_team == true then
									--print("We are creating it because we think it is the correct team")
									--pporitected from no such blueprint
									local entity=Util_CreateSquadsAtPositionEx(World_GetPlayerAt(player_looper), groupname, targetgroup ,  marker_position, 1, 0)
									if health > 0 and health <= 1 then
										--set the health of the item spawned.  Mostly used for civilians which are so incredibly tough
										SGroup_SetAvgHealth( groupname , health)
									end
									if callit ~= "" then
										if SGroup_Exists(callit) == false then
											SGroup_Create(callit)
										end
										SGroup_AddGroup(SGroup_FromName(callit), entity)
									end
									--Set the delay timer.  When the item is destroyed, we will wait for this timer-length before we give it back to them.
									g_BonusDelay[looper]=grouptimer
								end
							else
								print("No such blueprint: "..targetgroup)
							end
						end
					end
				end
			end
		end
		looper = looper + 1
	end
end


function death_check(player)
	local okflag=false
	local looper=1
	local count = 0
	if g_DestroyHQ == false then
		looper=1
		while looper <= table.getn(g_MilitaryList) do
			if Player_HasBuildingType( player , g_MilitaryList[looper] ) then
				--print ("player has a "..g_MilitaryList[looper])
				okflag=true
				count=count+1
			end
			looper = looper + 1
		end
	end
	looper=1
	while looper <= table.getn(g_HQList) do
		if Player_HasBuildingType( player , g_HQList[looper] ) then
			--print ("player has a "..g_HQList[looper])
			okflag=true
			count=count+1
		end
		looper = looper + 1
	end
	--print("the player has "..count.." buildings that are keeping them alive ")
	if count < 1 and g_wave_number > 1 then
		--Player_Kill( player )
		g_end_time=1
		print("we killed the player")
	elseif count < 1 then
		print("It seems the game is just starting.  No bases yet, so we will show some grace.")
	end
end

--This routine should run just once.  It will give us a list of all the buildings that we need to know about to know if the player is truly defeated.
function build_building_lists()
	local raceloop=0
	local looper=0
	local hqindex=1
	local militaryindex=1
	local temparray={}
	g_HQList={}
	g_MilitaryList={}
	
	--count for all races
	for raceloop=1,9 do
		if raceloop==1 then
			temparray=space_marine_buildings
		elseif raceloop==2 then
			temparray=chaos_buildings
		elseif raceloop==3 then
			temparray=necron_buildings
		elseif raceloop==4 then
			temparray=ork_buildings
		elseif raceloop==5 then
			temparray=tau_buildings
		elseif raceloop==6 then
			temparray=eldar_buildings
		elseif raceloop==7 then
			temparray=ig_buildings
		elseif raceloop==8 then
			temparray=dark_eldar_buildings
		elseif raceloop==9 then
			temparray=sisters_buildings
		end
		for looper =1,(table.getn(temparray)/3) do
			if temparray[(looper*3)-1] == "hq" then
				g_HQList[hqindex]=temparray[(looper*3)-2]
				print("adding "..temparray[(looper*3)-2].." as a HQ")
				hqindex=hqindex+1
			elseif temparray[(looper*3)-1] == "military" then
				g_MilitaryList[militaryindex]=temparray[(looper*3)-2]
				militaryindex=militaryindex+1
			end
		end
	end
	print("building lists:  number of HQ blueprints: "..hqindex-1)
	print("building lists:  number of military blueprints: "..militaryindex-1)
end

----------------------
--#####################################################
--#####################################################
--#####################################################
----------------------

VPlayerType={ 
			PlayerNum=0,     --virtual_player number
			Race="default",  --could be any of the races (ork_race, custom1_race, etc)
			Location="1",    --location on the map.  Need markers named 1-hq-1, 1-military-1, etc if base="wide"
			Base="wide",     --Base type.  wide|condensed|reverse-condensed
			VDifficulty=1,   --vehicle difficulty
			SDifficulty=1,   --squad difficulty
			Name="",		 --Name that it is called
			SCap=10,         --how many in the squad cap
			VCap=10,         --how many in the vehicle cap
			SpawnType="wave-trickle", --how the spawning works.  wave|trickle|wave-trickle
			Death="kill",    --trigger for when the vplayer is killed  kill|assisinate
			Alive=0,         --  1 is alive, -1 means they have been killed
			VirtualParent=-1 -- which AI controls this player.  -1 will assign it to the main enemy
							 -- define this if we try to have multi-player games with vplayers on different teams
							 --	Not recommended, but worth having the code in place in case we want this
		}
function VPlayerType:New(o)
	o=o or {};
	setmetatable(o,self)
	self.__index= self
	if self.Difficulty ~= nil then
		self.VDifficulty = self.Difficulty
		self.SDifficulty = self.Difficulty
	end
	return o
end
function DefineVPlayer(vplayer)
	if VPlayerArray == nil then
		VPlayerArray={}
	end
	local pos=table.getn(VPlayerArray)+1
	if vplayer.PlayerNum ~= nil then
		pos=vplayer.PlayerNum
	else
		vplayer.PlayerNum=pos
	end
	VPlayerArray[pos]=VPlayerType:New(vplayer)
	if VPlayerArray[pos].Name == "" then
		VPlayerArray[pos].Name="VPlayer"..pos
	end
	--now define the virtual parent.  Set to -1 to assign it to the default enemy
	if type(VPlayerArray[pos].VirtualParent) == string then
		local testnum=Util_GetTrailingNumber( VPlayerArray[pos].VirtualParent )
		if testnum > 0 then
			VPlayerArray[pos].VirtualParent=testnum
		else
			--we do not know what it is.  Change it to "default"
			VPlayerArray[pos].VirtualParent= -1
		end
	end
	if VPlayerArray[pos].VirtualParent == -1 then
		--This will be set up as we build the player list.  Right now we do not know
		--all the players, teams, etc.
	else
		--We have something defined.  Use it
		if VPlayerArray[pos].VirtualParent < 8 then
			--It is set up as 1,2,3,4,5,6,7,8, find the playerID
			if VPlayerArray[pos].VirtualParent <= World_GetPlayerCount() then
				VPlayerArray[pos].VirtualParent=World_GetPlayerAt(VPlayerArray[pos].VirtualParent)
			else
				--it is not a valid player
				VPlayerArray[pos].VirtualParent=-1
			end
		else
			--It may be a playerID.  Check it out
			if World_GetPlayerIndex( VPlayerArray[pos].VirtualParent ) then
				--it checks out.  Leave it
			else
				--we do not know who it is.  Set to -1 to be defined later
				VPlayerArray[pos].VirtualParent=-1
			end
		end
	end
end

function MatchPlayerList( players )
	local returnlist={}
	local k, v
	local looper
	local fpart=""
	local tlist={}
	if type(players)=="number" then
		returnlist= { players }
	elseif type(players) ~= "table" then
		returnlist=MatchPlayerList ( { players } )
	elseif type(players)=="table" and players[1]=="OwnerOf" and table.getn(players)==2 then
		if EGroup_Exists(players[2]) then
			tlist=EGroup_Owners(players[2])
			returnlist=combine(returnlist,tlist)
		end
		if SGroup_Exists(players[2]) then
			tlist=SGroup_Owners(players[2])
			returnlist=combine(returnlist,tlist)
		end
	else
		for k,v in pairs(players) do
			--Determine how many players fit the text:
			--The text could be: players, player, [v]player{1,2,3,4,5,6,7,8}, team{1,2,3,4,5,6,7,8}, enemy, all
			if type(v) == "string" then
				fpart=string.sub(v,1,4)
			end
			if type(v) == "number" then
				returnlist[table.getn(returnlist)+1]=v
			elseif v == "players" or v == "player" or v == "humans" then
				--print("player, players, or human")
				if g_AllPlayerList ~= nil then
					for looper=0,table.getn(g_AllPlayerList) do
						if g_AllPlayerList[looper].Team == 0 then
							--returnlist[table.getn(returnlist)+1]=g_AllPlayerList[looper].PlayerNum
							returnlist[table.getn(returnlist)+1]=looper
						end
					end
				end
			elseif SGroup_Exists(v)  then
				--print("found a sgroup in the list")
				returnlist[table.getn(returnlist)+1]=v
			elseif EGroup_Exists(v)  then
				--print("found an egroup in the list")
				returnlist[table.getn(returnlist)+1]=v
			elseif Marker_Exists(v,"basic_marker")  then
				--print("found an egroup in the list")
				returnlist[table.getn(returnlist)+1]=v
			elseif fpart == "play" or fpart == "vpla" then
				--print("first_part matches: '"..fpart.."' now looking for player "..v)
				if g_AllPlayerList ~= nil then
					for looper=0,table.getn(g_AllPlayerList) do
						if g_AllPlayerList[looper].PlayerName == v then
							--returnlist[table.getn(returnlist)+1]=g_AllPlayerList[looper].PlayerNum
							returnlist[table.getn(returnlist)+1]=looper
						end
					end
				end
			elseif fpart == "team" then
				if g_AllPlayerList ~= nil then
					local tempnum=Util_GetTrailingNumber( v ) - 1
--					--print("trailingnum of "..genstring(v).." is "..genstring(tempnum))
					for looper=0,table.getn(g_AllPlayerList) do
--						print("team for player "..looper.." is "..g_AllPlayerList[looper].Team)
						if g_AllPlayerList[looper].Team == tempnum then
							--returnlist[table.getn(returnlist)+1]=g_AllPlayerList[looper].PlayerNum
							returnlist[table.getn(returnlist)+1]=looper
						end
					end
				end
			elseif v == "enemy" then
				--if we have the enemy player defined
				--print("We have an enemy player")
				if g_PlayerEnemy ~= nil then
					returnlist[table.getn(returnlist)+1]=g_PlayerEnemy
				end
			elseif v == "all" or v == "any" or v == "anyone" then
				--print("all, any, or anyone")
				if g_AllPlayerList ~= nil then
					for looper=0,table.getn(g_AllPlayerList) do
						--returnlist[table.getn(returnlist)+1]=g_AllPlayerList[looper].PlayerNum
						returnlist[table.getn(returnlist)+1]=looper
					end
				end
			else
				--We have no idea who we are looking for.  Return nothing
			end
		end
	end

	if returnlist == nil then
		return nil
	end
	if genstring(returnlist) == genstring({ }) then
		return nil
	end
	--print("before uniquify: "..genstring(returnlist))
	local retlist=Uniqueify(returnlist)
	if type(players)=="table" and players.operator ~= nil then
		retlist.operator=players.operator
	end
	--print("unique players impacted: "..genstring(retlist))
	return retlist
end

function build_at_position(player, blueprint, pos, x, y, z, percent,direction, group)
	local mypos=pos
	x=x*direction
	y=y*direction
	z=z*direction
	local oldx = pos.x
	local oldy = pos.y
	local oldz = pos.z
	local max=x
	if max < y then
		max=y
	end
	if max < z then
		max=z
	end
	max = max / 2
	local shiftx=0
	local shifty=0
	local shiftz=0
	if max > 0 then
		shiftx=x / max
		shifty=y / max
		shiftz=z / max
	end
	local changecount = 10
	local dropflag
	mypos.x=mypos.x+x
	mypos.y=mypos.y+y
	mypos.z=mypos.z+z
--	print ("max = "..max.."  shiftx="..shiftx.."  shiftz="..shiftz)
	if EBP_Exists(blueprint) then
		print("Generating a "..blueprint.." at x="..mypos.x.."  z="..mypos.z)
		dropflag=Entity_CreateBuildingPosition( player, group, blueprint, mypos, percent)
		while dropflag == false and changecount > 0 and max > 0 do
			--if max=0 then all the shifts =0 also, which means we are not going anywhere
			mypos.x=mypos.x+shiftx
			mypos.y=mypos.y+shifty
			mypos.z=mypos.z+shiftz
			print("  retrying "..blueprint.." at x="..mypos.x.."  z="..mypos.z)
			--protected against no such blueprint
			dropflag=Entity_CreateBuildingPosition( player, group, blueprint, mypos, percent)
			changecount=changecount -1
		end
		mypos.x=oldx
		mypos.z=oldz
		mypos.y=oldy
	else
		print("No such blueprint: "..blueprint)
	end
end

function drop_buildings(player, location, building_type, array_of_buildings)
	local counter = 0
	local looper = 1
	local base = 0
	local countarray={}
	local marker_name = ""
	local flag=true
	local worked=true
	local excapeflag=false
	local groupname=""
	
--	UIWarning_Show( "checking out ".. building_type .. " " .. array_of_buildings[1])
	for counter = 1, table.getn(array_of_buildings) do
		countarray[counter]=0
	end
	groupname="buildings"..location
	if building_type == "hq" then
		groupname="buildings"..location.."hq"
	end 
	if building_type == "military" then
		groupname="buildings"..location.."military"
	end 
	if building_type == "webway" then
		groupname="buildings"..location.."webway"
	end 

	for counter = 1, 20 do 
		marker_name = location .. "-" .. building_type .. "-" .. counter
		if Marker_Exists (marker_name,"basic_marker") then
			flag=true
			excapeflag=false
			while flag == true do
				base=(looper * 3) -2
				if array_of_buildings[base + 1] == building_type then
					--It is the type of building we are interested in.  DO we make one?
					if EBP_Exists(array_of_buildings[base]) then
						if countarray[base] < array_of_buildings[base + 2] then
						--We have not filled our quota of this building
							if building_type == "post" then
								print ("Trying to put a post somewhere "..marker_name)
							end 
							--protected against no such blueprint
							worked = Entity_CreateBuildingMarker(player,groupname,array_of_buildings[base],marker_name,1.0)
							if worked then
								countarray[base] = countarray[base] + 1
								EGroup_SetPlayerOwner( groupname, player )
								if building_type == "post" then
									print("Post added..")
								end
								--entity_setplayerowner
								--Entity_Create(String blueprint, PlayerID player, Position pos )
							else
								if building_type == "post" then
									print("Post failed to be added!")
								end
							end

							flag=false
						end
					end
				end
				looper = looper + 1
				base=(looper * 3) -2
				if base >= table.getn(array_of_buildings) then
					if excapeflag then
						flag = false
					end
					excapeflag = true
					looper=1
				end
			end
		end
	end
	print("creating spawn-group")
	if EGroup_Exists(groupname) == true then
		if building_type=="military" or building_type=="hq" then
			local spawngroup="spawn"..location
			if EGroup_Exists(spawngroup) == false then
				EGroup_Create(spawngroup)
				print("creating group -"..spawngroup.."-")
			end
			EGroup_AddGroup( EGroup_FromName(spawngroup), EGroup_FromName(groupname))
			print ("group "..spawngroup.." contains ".. EGroup_Count(EGroup_FromName(spawngroup)).." entities")
		elseif building_type=="webway" then
			local spawngroup="spawn"..location.."webway"
			if EGroup_Exists(spawngroup) == false then
				EGroup_Create(spawngroup)
				print("creating group -"..spawngroup.."-")
			end
			EGroup_AddGroup( EGroup_FromName(spawngroup), EGroup_FromName(groupname))
			print ("group "..spawngroup.." contains ".. EGroup_Count(EGroup_FromName(spawngroup)).." entities")
		else
			print("wrong building_type "..building_type)
		end
	end
end


--drop_base(g_Player2, location, race_name, vplayer)
function drop_base(player, location, race_name, vplayer)
	local looper=0
	local race_array = tau_buildings
	local marker_name=""
	if race_name=="default" then
		race_name=Player_GetRaceName( player )
	end
	race_array=get_building_race_array(race_name)
	print("Putting an entire "..race_name.." base at location "..location)
	if type(location)=="string" and Marker_Exists(location,"basic_marker") then
		marker_name=location
		local dir=1
		if string.sub(location,-1) == "r" or string.sub(location,-1) == "R" then
			dir=-1
		end
		drop_compact_base(player, race_name, Marker_GetPosition(Marker_FromName(location,"basic_marker")), dir, location )
	else
		marker_name = location .. "-hq-1"
		drop_buildings(player , location ,"hq",race_array)
		drop_buildings(player , location ,"military",race_array)
		drop_buildings(player , location ,"webway",race_array)
		--It is possible for a marker not to have anything on it because it did not fit
		--We will try a second time to give a second chance (a smaller item may fit where the larger would not
		drop_buildings(player , location ,"military",race_array)	
		drop_buildings(player , location ,"power",race_array)
		drop_buildings(player , location ,"thermo",race_array)
		drop_buildings(player , location ,"turret",race_array)
		drop_buildings(player , location ,"minefield",race_array)
		drop_buildings(player , location ,"post",race_array)
	end
	if vplayer > 0 then
		--virtual_enemy_array[ (vplayer * 4) -3 ] = location 
		
		if Marker_Exists(marker_name, "basic_marker") then
			Ping_Marker(marker_name,false,"normal")
		end
	end
end


function drop_compact_base(player, race_name, pos, direction, location)
	--Entity_CreateBuildingPosition( PlayerID player, String egroupName, String blueprint, Position position, Real constructionPercent )
	local team = Player_GetTeam(player)
	local building_group=""
	local group
	if location == nil then
		if team == 1 then
			group="teambase"
		else
			group="enemybase"
		end
		location=group
	else
		group=location
	end
	group="buildings"..group
	if direction == nil then
		direction=1
	end
	if direction ~= -1 and direction ~= 1 then
		direction = 1
	end
	local printpos = function( egroupid, itemindex, entityID )
		local mypos=Entity_GetPosition( entityID )
		local myname=Entity_GetBlueprintName( entityID )
        print(myname.." is at x="..mypos.x.." z="..mypos.z)
	end
	if race_name=="default" then
		race_name=Player_GetRaceName( player )
	end
	print("dropping building:  race="..race_name.."  pos="..genstring(pos))
	--The dimentions used are X and Z (y is height)
	--X is next (right/left)
	--Z is forward/back
	if race_name == "chaos_marine_race" then
	    build_at_position( player,  "chaos_hq", pos,0,0,0,1,direction, group.."hq")
		build_at_position( player,  "chaos_temple", pos,0,0,19,1,direction, group.."military") 
		build_at_position( player,  "chaos_machine_pit", pos,14,0,20,1,direction, group.."military") 
		build_at_position( player,  "chaos_armoury", pos,-14,0,0,1,direction, group) 
		build_at_position( player,  "chaos_greater_sacrificial_circle", pos,-13,0,15,1,direction, group.."military") 
		build_at_position( player,  "chaos_plasma_generator", pos,5,0,-15,1,direction, group) 
		build_at_position( player,  "chaos_plasma_generator", pos,-5,0,-15,1,direction, group) 
		build_at_position( player,  "chaos_sacrificial_circle", pos, 14,0,0,1,direction, group.."military") 
	elseif race_name == "eldar_race" then
		build_at_position( player,  "eldar_hq", pos,0,0,0,1,direction,group.."hq")
		build_at_position( player,  "eldar_aspect_portal", pos,0,0,19,1,direction,group.."military") 
		build_at_position( player,  "eldar_support_portal", pos,14,0,20,1,direction,group.."military") 
		build_at_position( player,  "eldar_soul_shrine", pos,-14,0,0,1,direction, group)  
		build_at_position( player,  "eldar_warp_generator", pos,5,0,-15,1,direction, group) 
		build_at_position( player,  "eldar_warp_generator", pos,-5,0,-15,1,direction, group) 
		build_at_position( player,  "eldar_webway_gate", pos, 14,0,0,1,direction, group)  
	elseif race_name == "guard_race" then
		build_at_position( player,  "guard_hq", pos,0,0,0,1,direction,group.."hq")
		build_at_position( player,  "guard_infantry", pos,0,0,19,1,direction,group.."military") 
		build_at_position( player,  "guard_mechanized", pos,18,0,20,1,direction,group.."military") 
		build_at_position( player,  "guard_mechanized", pos,18,0,0,1,direction,group.."military") 
		build_at_position( player,  "guard_mars_pattern", pos,-20,0,0,1,direction, group) 
		build_at_position( player,  "guard_infantry", pos,-15,0,19,1,direction,group.."military") 
		build_at_position( player,  "guard_tactica", pos,0,0,-15,1,direction, group) 
		build_at_position( player,  "guard_plasma_generator", pos,-9,0,-15,1,direction, group) 
		build_at_position( player,  "guard_plasma_generator", pos,9,0,-15,1,direction, group) 
	elseif race_name == "ork_race" then
		build_at_position( player,  "ork_hq", pos,0,0,0,1,direction,group.."hq")
		build_at_position( player,  "ork_boy_hut", pos,0,0,19,1,direction,group.."military") 
		build_at_position( player,  "ork_mek_shop", pos,18,0,18,1,direction,group.."military") 
		build_at_position( player,  "ork_pile_o_guns", pos,-15,0,0,1,direction, group) 
		build_at_position( player,  "ork_boy_hut", pos,-15,0,19,1,direction,group.."military") 
		build_at_position( player,  "ork_generator", pos,5,0,-15,1,direction, group) 
		build_at_position( player,  "ork_generator", pos,-5,0,-15,1,direction, group) 
		build_at_position( player,  "ork_waagh_banner", pos,8,0,30,1,direction, group) 
		build_at_position( player,  "ork_waagh_banner", pos,0,0,30,1,direction, group) 
		build_at_position( player,  "ork_waagh_banner", pos,-8,0,30,1,direction, group) 
	elseif race_name == "space_marine_race" then
	    build_at_position( player,  "space_marine_hq", pos,0,0,0,1,direction,group.."hq")
		build_at_position( player,  "space_marine_barracks", pos,0,0,19,1,direction,group.."military") 
		build_at_position( player,  "space_marine_vehicle_building", pos,14,0,20,1,direction,group.."military") 
		build_at_position( player,  "space_marine_armoury", pos,-14,0,0,1,direction,group, group) 
		build_at_position( player,  "space_marine_orbital_relay", pos,-13,0,15,1,direction,group.."military") 
		build_at_position( player,  "space_marine_generator", pos,5,0,-15,1,direction, group) 
		build_at_position( player,  "space_marine_generator", pos,-5,0,-15,1,direction, group) 
		build_at_position( player,  "space_marine_ability_building", pos, 14,0,0,1,direction, group) 
	elseif race_name == "necron_race" then
	    build_at_position( player,  "monolith", pos,0,0,15,1,direction,group.."hq")
		build_at_position( player,  "necron_forbidden_archive", pos,15,0,0,1,direction, group) 
		build_at_position( player,  "necron_greater_summoning_core", pos,-15,0,15,1,direction,group.."military") 
		build_at_position( player,  "necron_summoning_core", pos,0,0,0,1,direction,group.."military") 
		build_at_position( player,  "necron_energy_core", pos, 15,0,15,1,direction, group) 
		build_at_position( player,  "necron_plasma_generator", pos,8,0,-10,1,direction, group) 
		build_at_position( player,  "necron_plasma_generator", pos,0,0,-10,1,direction, group) 
		build_at_position( player,  "necron_plasma_generator", pos,-8,0,-10,1,direction, group) 
	elseif race_name == "tau_race" then
	    build_at_position( player,  "tau_hq", pos,0,0,0,1,direction,group.."hq")
		build_at_position( player,  "tau_barracks", pos,0,0,19,1,direction, group.."military") 
		build_at_position( player,  "tau_shrine_of_montka", pos,-14,0,19,1,direction, group)
		build_at_position( player,  "tau_vehicle_building", pos,14,0,20,1,direction,group.."military") 
		build_at_position( player,  "tau_research_building", pos,-14,0,0,1,direction, group) 
		build_at_position( player,  "tau_kroot_nest", pos,15,0,0,1,direction,group.."military") 
		build_at_position( player,  "tau_plasma_generator", pos,5,0,-15,1,direction, group) 
		build_at_position( player,  "tau_plasma_generator", pos,-5,0,-15,1,direction, group) 
		build_at_position( player,  "tau_shrine_of_kauyon", pos, 15,0,-18,1,direction, group) 
		build_at_position( player,  "tau_shrine_of_purpose", pos, -15,0,-18,1,direction, group) 
	elseif race_name == "dark_eldar_race" then
	    build_at_position( player,  "dark_eldar_hq", pos,0,0,0,1,direction,group.."hq")
		build_at_position( player,  "dark_eldar_hall_of_blood", pos,0,0,19,1,direction, group.."military") 
		build_at_position( player,  "dark_eldar_wych_cult_arena", pos,-14,0,19,1,direction, group)
		build_at_position( player,  "dark_eldar_soul_cage", pos,14,0,20,1,direction,group.."military") 
		build_at_position( player,  "dark_eldar_skimmer_shop", pos,-14,0,0,1,direction, group) 
		build_at_position( player,  "dark_eldar_haemonculus_laboratory", pos,15,0,0,1,direction,group.."military") 
		build_at_position( player,  "dark_eldar_plasma_generator", pos,5,0,-15,1,direction, group) 
		build_at_position( player,  "dark_eldar_plasma_generator", pos,-5,0,-15,1,direction, group) 
		build_at_position( player,  "dark_eldar_slave_caravel", pos, 15,0,-18,1,direction, group) 
		build_at_position( player,  "dark_eldar_slave_caravel", pos, -15,0,-18,1,direction, group)
		build_at_position( player,  "dark_eldar_slave_caravel", pos, 15,0,-28,1,direction, group) 
		build_at_position( player,  "dark_eldar_slave_caravel", pos, -15,0,-28,1,direction, group)
	elseif race_name == "sisters_race" then
	    build_at_position( player,  "sisters_hq", pos,0,0,0,1,direction,group.."hq")
		build_at_position( player,  "sisters_infantry", pos,0,0,19,1,direction, group.."military") 
		build_at_position( player,  "sisters_holy_reliquary", pos,-14,0,19,1,direction, group)
		build_at_position( player,  "sisters_vehicle_building", pos,14,0,20,1,direction,group.."military") 
		build_at_position( player,  "sisters_sanctuary", pos,-14,0,0,1,direction, group) 
		build_at_position( player,  "sisters_shrine", pos,15,0,0,1,direction,group.."military") 
		build_at_position( player,  "sisters_plasma_generator", pos,5,0,-15,1,direction, group) 
		build_at_position( player,  "sisters_plasma_generator", pos,-5,0,-15,1,direction, group) 
		build_at_position( player,  "sisters_infantry", pos, 15,0,-18,1,direction, group) 
	end
	EGroup_CreateIfNotFound("spawn"..location)
	if EGroup_Exists(group.."hq") then
		EGroup_AddGroup("spawn"..location, group.."hq")
	end
	if EGroup_Exists(group.."military") then
		EGroup_AddGroup("spawn"..location, group.."military")
	end
end

function Uniqueify(checklist)
	local newlist={}
	local returnlist={}
	local looper=0
	local isperson=false
	local k, v
	if type(checklist) ~= "table" then
		returnlist=Uniqueify( { checklist } )
	else
		for k,v in pairs( checklist ) do
			if type(v) == "table" then
				if v.id ~= nil then
					--it is a person
					newlist[""..v.id]=1;
					isperson=true;
				end
			else
				if type(v) == "number" then
					newlist[""..v]=1;
				else
					newlist[v]=2;
				end
			end
		end
		looper=0
		for k, v in pairs( newlist ) do
			if isperson then
				returnlist[looper]={};
				returnlist[looper].id=tonumber(k)
			else
				if v==1 then
					returnlist[looper]=tonumber(k);
				else
					returnlist[looper]=k;
				end
			end
			looper=looper+1
		end
	end
	return returnlist
end


function queue_message(Command)
	local answer=false
	local firstpart=""
	local whole=""
	local orig_who
	local marker=0
	if g_message_list==nil then
		g_message_list={}
	end
	--if message has \n, break it into chunks as multiple messages
	if type(Command)~="table" then
		print ('Message must be in form of: { WHO, "message" }')
		return false
	end
	if table.getn(Command)==2 and Command.action_who== nil and Command.action_what==nil then
		Command.action_who=Command[1]
		Command.action_what=Command[2]
	end
	if Command.action_who == nil then
		--default to a message for everyone
		Command.action_who="all"
	end
	if Command.WhoList == nil then
		Command.WhoList = MatchPlayerList(Command.action_who)
	end
	if Command.WhoList==nil then
		print("The message is not for anyone!")
		return false
	end
	if Command.timeout == nil then
		Command.timeout=30
	end
	if Command.duration==nil then
		Command.duration=5
	end
	if Command.mcounter == nil then
		Command.mcounter=Command.duration
	end
--	print("WhoList="..genstring(Command.WhoList).."  text="..genstring(Command.action_what))
	orig_who=Command.WhoList
	local k,v, mystring, l, m, tanswer
	if type(Command.action_what) == "table" then
--		print("Message is a table.  Making many of them")
		for k,v in pairs(Command.action_what) do
			Command.action_what = v
			Command.WhoList=orig_who
			tanswer=queue_message(copy_table(Command))
			answer=answer or tanswer
		end
	elseif type(Command.WhoList) == "table" then
--		print("WhoList is a table.  Looping through users")
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			tanswer=queue_message(copy_table(Command))
			answer=answer or tanswer
		end
--		if Command.action_what == "Dem's takin too long!  Let's help out!" then
--			genscarerror()
--		end
	else
		--We have a string.  Break it up into individual messages if we find a \n
		local cr=string.find( Command.action_what, "\n")
		if cr==nil then
			cr=string.len(Command.action_what)+1
		end
		--this was a while, but it is recursive
		if cr ~= nil and cr > 0 then
			whole=Command.action_what
			firstpart=string.sub(Command.action_what, 0, cr -1)
			Command.action_what=firstpart
			--File the message
			--set message ID
			if Command.id == nil then
				if g_message_list.nid == nil then
					g_message_list.nid=1
				else
					g_message_list.nid=g_message_list.nid+1
				end
				Command.id = g_message_list.nid
			end
			if g_message_list.next_id == nil then
				g_message_list.next_id=1
			end

			marker=g_message_list.next_id
			g_message_list.next_id = g_message_list.next_id + 1
--			if g_message_list.next_id > 150 then
--				g_message_list.next_id = 1
--			end
			print("adding a message to position "..marker.." for "..genstring(Command.WhoList))
			g_message_list[marker]=copy_table(Command)
			g_message_list[marker].action_who=Command.WhoList
--			print("Filing the message: "..genstring(Command))
			answer=true
			--grab the rest of the message
			Command.action_what=string.sub(whole,cr + 1)
			--If there is more to the message, file it
			if Command.action_what ~= "" then
				--Increase the timeout for each consecutive portion of the message
				Command.timeout=Command.timeout + Command.duration
				tanswer=queue_message(Command)
				answer=answer or tanswer
				cr=string.find( Command.action_what, "\n")
			end
		end
	end
	return answer
end


--The following function should not be called manually.  It is called
--every second from "game control"
function display_messages()
	local delete_message=true --Do we delete the message (are we done with it?)
	local mid=0 --Message index
	local cid=0 --current message ID
	local current_priority=0
	local k, v, looper, player
	local lockon=0 
	--This will look at what the next message in the list is
	--and display it if it belongs to the local player
	--W40k_ShowSystemMessage( action_where )
	--print("Starting dislay_messages")
	if g_message_list == nil then
		g_message_list={}
	end
	--Loop through all the messages to see if there is a high-priority item.  Lock onto the highest priority
--	print ("Number of messages possible: "..genstring(table.getn(g_message_list)))
	for player = 0,7 do
		for k,v in pairs(g_message_list) do
			if type(v) == "table" and v.priority ~= nil then
				if (v.priority > current_priority and v.action_who == player) or 
				   (v.priority == current_priority and cid==v.id and v.action_who == player) then
					lockon = k
					current_priority=v.priority
					cid=v.id
					print("Found a priority message: "..k.." "..v.id.." player"..player.." "..v.action_what)
				end
			end
		end
		--For each user, loop through the messages to see if there are any to print for them
		mid=0 --This is the message we are going to show for this user
		if lockon == 0 then
			for k,v in pairs(g_message_list) do
				if type(v) == "table" then
					if type(k)=="number" and mid == 0 and v.action_who == player then
						mid=k
						print("Found a message: "..k.." "..mid.." player"..player.." "..v.action_what)
					end
				end
			end
		else
			mid = lockon 
			--We are "locked" into one message
		end
		--Now we know which message to do for this user
		--print the message, if there is one.  Decrement the counter for that message messagelist.counter--
		if mid > 0 and g_message_list[mid] ~= nil and g_message_list[mid].action_who == player then
			g_message_list[mid].mcounter = g_message_list[mid].mcounter -1
			if g_message_list[mid].mcounter > 0 then
				--If local player
				print("printing message "..mid.." for player "..player.." = "..genstring(g_message_list[mid].action_what))
				if Misc_GetLocalPlayerID() == Player_GetID(g_AllPlayerList[player].PlayerNum) then
					W40k_ShowSystemMessage(g_message_list[mid].action_what)
					--UIWarning_Show("Message here"..genstring(g_message_list[mid].action_what))
				end
			else
				--if local player
				if Misc_GetLocalPlayerID() == Player_GetID(g_AllPlayerList[player].PlayerNum) then
--					W40k_ShowSystemMessage("")
					W40k_ShowSystemMessage("")
				end
				g_message_list[mid].deleteme=true
			end
		end
		--print "" if the message is done, and mark the message for deletion g_messagelist[mid].deleteme=true
		--loop through the "to delete" list and remove all the message#brs in it
	end

	--loop through all the messages, decrement the timeout, and delete anything
	for k,v in pairs(g_message_list) do
		if type(v) == "table" then
			if v.timeout == nil or v.timeout < 1 or v.deleteme==true then
				print("Removing message #"..genstring(k).." Because timeout="..genstring(v.timeout).." deleteme="..genstring(v.deleteme))
				v.timeout = v.timeout - 1
				--table.remove(g_message_list,k)
				g_message_list[k]=nil
			else
				v.timeout = v.timeout - 1
			end
		end
	end
	k=0
	v=0
--	print ("Number of messages after cleanup: "..genstring(table.getn(g_message_list)))
	return true
end


function SGroup_Except(sgroup1, sgroup2)
	--Remove any squads from sgroup1 that are in sgroup2
	local sgroup1id=SGroup_FromName(sgroup1)
	local sgroup2id=SGroup_FromName(sgroup2)

	local removethem = function( sgroupid, itemindex, squadID )
		if SGroup_ContainsSquad(sgroup2id, squadID) then
			SGroup_Remove( sgroupid, squadID )
		end
    end
    SGroup_ForEach( sgroup1, removethem )
end

function build_player_list()
	g_AllPlayerList={}
	g_AllPlayerLookup={}
	local looper
	local teststring
	local nextnum
	local enemy=-1
	for looper = 0, World_GetPlayerCount() -1 do
		g_AllPlayerList[looper]={}	
		g_AllPlayerList[looper].PlayerNum=World_GetPlayerAt(looper)
		g_AllPlayerList[looper].IsCPU=Cpu_IsCpuPlayer( g_AllPlayerList[looper].PlayerNum )
		g_AllPlayerList[looper].Team=Player_GetTeam( g_AllPlayerList[looper].PlayerNum )
		g_AllPlayerList[looper].Race=Player_GetRaceName( g_AllPlayerList[looper].PlayerNum )
		g_AllPlayerList[looper].PlayerName="player"..(looper + 1)
		teststring=Player_GetDisplayName( g_AllPlayerList[looper].PlayerNum )
		g_AllPlayerList[looper].Name=teststring[1]
		print("Player Name: "..g_AllPlayerList[looper].Name.."  "..genstring(g_AllPlayerList[looper]))
		g_AllPlayerLookup[g_AllPlayerList[looper].PlayerName] = looper
		if g_AllPlayerList[looper].IsCPU and g_AllPlayerList[looper].Team== 1 then
			enemy=looper
		end
	end
	if VPlayerArray == nil then
		VPlayerArray={}
	end
	if enemy ~= -1 then
		for looper = 0, table.getn(VPlayerArray) do
			if VPlayerArray[looper]~= nil then
				nextnum=table.getn(g_AllPlayerList)+1
				g_AllPlayerList[nextnum]={}	
				if VPlayerArray[looper].VirtualParent == -1 then
					g_AllPlayerList[nextnum].PlayerNum=World_GetPlayerAt(enemy)
				else
					g_AllPlayerList[nextnum].PlayerNum=VPlayerArray[looper].VirtualParent
				end
				g_AllPlayerList[nextnum].IsCPU=true
				g_AllPlayerList[nextnum].Team=Player_GetTeam( g_AllPlayerList[nextnum].PlayerNum )
				g_AllPlayerList[nextnum].Race=VPlayerArray[looper].Race
				g_AllPlayerList[nextnum].PlayerName="vplayer"..looper
				g_AllPlayerList[nextnum].Name=VPlayerArray[looper].Name
				print("Player Name: "..g_AllPlayerList[nextnum].Name.."  "..genstring(g_AllPlayerList[nextnum]))
				g_AllPlayerLookup[g_AllPlayerList[nextnum].PlayerName] = looper
			end
		end
		g_PlayerEnemy=enemy
	else
		g_PlayerEnemy=-1
	end
end


function genstring (o)
	 local mystring=""
	 local comma=""
	  
	  if type(o) == "number" then
		mystring=o
	  elseif type(o) == "string" then
		mystring=string.format("%q", o)
	  elseif type(o) == "function" then
		mystring="FUNC"
	  elseif o == nil then
		mystring="nil"
	  elseif type(o) == "boolean" then
		if o then
			mystring="true"
		else
			mystring="false"
		end
	  elseif type(o) == "table" then
		mystring=comma.."{ "
		for k,v in pairs(o) do
			if type(k) == "number" then
			  mystring=mystring..comma.."  "..genstring(v)
			elseif type(k) == "string" then
			  mystring=mystring..comma.."  "..k.."="..genstring(v)
			end
			comma=","
		end
		mystring=mystring.." }"
	  else
		print("GENSTRING: cannot serialize a " .. type(o))
	  end
	  return mystring
end

function big_genstring (o,n)
	 local mystring=""
	 local comma=""
	if n> 10 then
		return "{...}"
	end
	  if type(o) == "number" then
		mystring=o
	  elseif type(o) == "string" then
		mystring=string.format("%q", o)
	  elseif type(o) == "function" then
		mystring="FUNC"
	  elseif o == nil then
		mystring="nil"
	  elseif type(o) == "boolean" then
		if o then
			mystring="true"
		else
			mystring="false"
		end
	  elseif type(o) == "table" then
		mystring=comma.."{ "
		for k,v in pairs(o) do
			if type(k) == "number" then
			  mystring=mystring..comma.."  "..big_genstring(v,n+1)
			elseif type(k) == "string" then
			  mystring=mystring..comma.."  "..k.."="..big_genstring(v,n+1)
			end
			comma=","
		end
		mystring=mystring.." }"
	  else
		print("GENSTRING: cannot serialize a " .. type(o))
	  end
	  return mystring
end


function combine(table1, table2)
	local ttable=table2
	local v, k
	local nextone=table.getn(table2)+1
	for k,v in ipairs(table1) do
		ttable[nextone]=v
		nextone=nextone+1
	end
	return ttable
end

function SGroup_Owners(sgroup)
	local myvar
	local ownerlist={}
	local mytemp
	if type(sgroup)=="string" then
		myvar=SGroup_FromName(sgroup)
	else
		myvar=sgroup
	end
	local checkown = function( sgroupid, itemindex, squadID )
		mytemp=World_GetPlayerIndex( Squad_GetPlayerOwner(squadID) )
        ownerlist[table.getn(ownerlist)+1]=mytemp
    end

    SGroup_ForEach( myvar, checkown )

	ownerlist=Uniqueify(ownerlist)
	--print("SGroup ownership looks like: "..genstring(ownerlist))
	return ownerlist
end

function EGroup_Owners(sgroup)
	local myvar
	local ownerlist={}
	local mytemp
	if type(sgroup)=="string" then
		myvar=EGroup_FromName(sgroup)
	else
		myvar=sgroup
	end
	local checkown = function( egroupid, itemindex, entityID )
		mytemp=World_GetPlayerIndex( Entity_GetPlayerOwner(entityID) )
        ownerlist[table.getn(ownerlist)+1]=mytemp
    end

    EGroup_ForEach( myvar, checkown )

	ownership=Uniqueify(ownerlist)
	--print("EGroup ownership looks like: "..genstring(ownerlist))
	return ownerlist
end

function gensgroup(my_sgroupname)
	local teststring=""
	local space=""
	local SquadPrint = function( sgroupid, itemindex, squadID )
        teststring=teststring..space..Squad_GetBlueprintName( squadID )
--		teststring=teststring..space..Squad_GetBaseUnitName( squadID )
		space=", "
    end
	if SGroup_Exists(my_sgroupname) then
	    SGroup_ForEach( SGroup_FromName(my_sgroupname), SquadPrint )
	else
		teststring="No such Group: "..my_sgroupname
	end
	return teststring
end

function genegroup(my_egroupname)
	local teststring=""
	local space=""
	local EntityPrint = function( egroupid, itemindex, entityID )
--        teststring=teststring..space..Squad_GetBlueprintName( entityID )
		teststring=teststring..space..Entity_GetBlueprintName( entityID )
		space=", "
    end
	if EGroup_Exists(my_egroupname) then
	    EGroup_ForEach( EGroup_FromName(my_egroupname), EntityPrint )
	else
		teststring="No such Group: "..my_egroupname
	end
	return teststring
end

--------------------------------------------
--############### Actions ##################
--------------------------------------------
function f_end_game(Command)
	print("EndingTheGame")
	g_end_time=1
	return true
end

function f_do_intel(Command)
	if Command.intel == nil then
		return false
	end
	if type(Command.intel) == "table" then
		CONVERSATION=Command.intel
		Util_StartIntel( EVENT.PlayConversation )
		return true
	elseif type(Command.intel) == "function" then
		Util_StartIntel( Command.intel )
		return true
	end
	return false
end

--Create an egroup
function f_create_egroup(Command)
	local k,v
	local answer=false
	local localoperator=Command.operator
	local isnot=false
	local orig_what=Command.action_what
	if type(Command.action_what) == "table" and table.getn(Command.action_what) < 0 then
		return nil
	end
	if Command.action_what == nil then
		return nil
	end
	--print("entering create_EGroup")
	if Command.firsttime == nil then
		print("first-time")
		Command.firsttime = 2
		if type(Command.group_name)=="table" then
			local what=Command.group_name
			for k,v in pairs(Command.group_name) do
				Command.group_name=v
				f_create_egroup(Command)
			end
			Command.group_name=what
		else
			if EGroup_Exists(Command.group_name) then
				EGroup_Clear(Command.group_name)
			else
				EGroup_Create(Command.group_name)
			end
		end
		Command.firsttime=1
	end
	if Command.firsttime == 2 then
		if type(Command.group_name)=="table" then
			local what=Command.group_name
			for k,v in pairs(Command.group_name) do
				Command.group_name=v
				f_create_egroup(Command)
			end
			Command.group_name=what
		else
			if EGroup_Exists(Command.group_name) then
				EGroup_Clear(Command.group_name)
			else
				EGroup_Create(Command.group_name)
			end
		end
		return
	end
	--Now all the groups are emptied out
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	if Command.WhoList == nil then
		return false
	end
	--From here, we want to add everyone to the lists
	--So we will "combine" them instead of emptying them out every time.
	if type(Command.WhoList) == "table"  then
		local tanswer=false
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			Command.action_what=orig_what
			tanswer = f_create_egroup(Command)
			answer = answer or tanswer
		end
	--This is where it gets sticky.  
	--Unless we have a "not" we want to combine grouplists of all the blueprints
	--Otherwise, we want to combine all the blueprints and combine all squads from affected players
	--then do an "except" on them
	--We can add blueprints, EGroups, or "All"
	elseif type(Command.action_what) == "table" then
		local tanswer=false
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			if type(v) ~= "table" and (v == "not" or v == "Not") then
				Command.operator="not"
			else
				tanswer = f_create_egroup(Command)
				answer = answer or tanswer
			end
		end
		--reset it to what it was before
		Command.operator=localoperator
	else
		local templist=EGroup_CreateIfNotFound("EGroupTemp")
		local notlist=EGroup_CreateIfNotFound("NotEGroupTemp")
		EGroup_Clear(templist)
		if localoperator == "not" then
			if EGroup_Exists(Command.action_what) then
--				print("we have a EGroup.  Adding all but these:"..genegroup(Command.action_what))
				--We just want to add the squad group to the list
				local allgroup=Player_GetEntities(  g_AllPlayerList[Command.WhoList].PlayerNum )
				local temp2=EGroup_CreateIfNotFound("EGroupTemp2")
				EGroup_AddGroup(temp2,allgroup)
				--now we need to subtract our group.
				EGroup_Except("EGroupTemp2",Command.action_what)
				EGroup_AddGroup(templist,EGroup_FromName(Command.action_what))
				answer = true
			elseif EBP_Exists(Command.action_what) then
--				print("we have a blueprint")
				--Get all the squads for a player & put in a temp group
				local allgroup=Player_GetEntities(  g_AllPlayerList[Command.WhoList].PlayerNum )
				local temp2=EGroup_CreateIfNotFound("EGroupTemp2")
				local temp4=EGroup_CreateIfNotFound("EGroupTemp4")
				EGroup_AddGroup(temp2,allgroup)
				print("Player entities: "..genegroup("EGroupTemp4"))
				--Find all squads of type "blueprint" and put into EGroupTemp
				Util_GetEntitiesByBP( "EGroupTemp4", "EGroupTemp2", Command.action_what )
				print("Subtracting blueprint from rest")
				EGroup_Except("EGroupTemp4","EGroupTemp2")
				--Now we add these to our group
				--
				--We are here
				--
				--Get rid of our temp group
				EGroup_Destroy(temp2)
				answer = true
			else
--				print("We do not know what this is: "..genstring(Command.action_what))
			end
--			print("we think our group should contain: "..genegroup("EGroupTemp"))
		else
			if EGroup_Exists(Command.action_what) then
--				print("we have a EGroup.  Adding these:"..genegroup(Command.action_what))
				--We just want to add the squad group to the list
				EGroup_AddGroup(templist,EGroup_FromName(Command.action_what))
				answer = true
			elseif EBP_Exists(Command.action_what) then
--				print("we have a blueprint")
				--Get all the squads for a player & put in a temp group
				local allgroup=Player_GetEntities(  g_AllPlayerList[Command.WhoList].PlayerNum )
				local temp2=EGroup_CreateIfNotFound("EGroupTemp2")
				EGroup_AddGroup(temp2,allgroup)
--				print("Player entities: "..genegroup("EGroupTemp2"))
				--Find all squads of type "blueprint" and put into EGroupTemp
				Util_GetEntitiesByBP( "EGroupTemp2", "EGroupTemp", Command.action_what )
				--Get rid of our temp group
				EGroup_Destroy(temp2)
				answer = true
			else
--				print("We do not know what this is: "..genstring(Command.action_what))
			end
--			print("we think our group should contain: "..genegroup("EGroupTemp"))
		end
		--At this point in time, we have our group in EGroupTemp2.
		--Now we want to set the group-names specified to that.
		--Doing this recursively can be tricky.
		if type(Command.group_name) == "table" then
			local temp2
			for k,v in pairs(Command.group_name) do
				temp2=EGroup_CreateIfNotFound("EGroupTemp3")
				EGroup_Clear(temp2)
				EGroup_AddGroup(temp2,templist)
				Command.group_name=v
				f_create_egroup(Command)
				--this clears out our temp squad.  Rebiuld it
				templist=EGroup_CreateIfNotFound("EGroupTemp")
				EGroup_AddGroup(templist,temp2)
				--If we have multiple levels of recursion, we need to rebuild our test group every time.
				EGroup_Destroy(temp2)
				answer = true
			end
		else
			EGroup_CreateIfNotFound(Command.group_name)
			EGroup_AddGroup(EGroup_FromName(Command.group_name),templist)
			answer = true
		end
		if EGroup_Exists("EGroupTemp") then
			EGroup_Destroy(templist)
		end
		if EGroup_Exists("NotEGroupTemp") then
			EGroup_Destroy(notlist)
		end
	end
	return answer
end

--Create an sgroup
function f_create_sgroup(Command)
	local k,v
	local localoperator=Command.operator
	local isnot=false
	local answer=false
	local orig_what=Command.action_what
	if type(Command.action_what) == "table" and table.getn(Command.action_what) < 0 then
		return nil
	end
	if Command.action_what == nil then
		return nil
	end
	if Command.firsttime == nil then
		print("first-time")
		Command.firsttime = 2
		if type(Command.group_name)=="table" then
			local what=Command.group_name
			for k,v in pairs(Command.group_name) do
				Command.group_name=v
				f_create_sgroup(Command)
			end
			Command.group_name=what
		else
			if SGroup_Exists(Command.group_name) then
				SGroup_Clear(Command.group_name)
			else
				SGroup_Create(Command.group_name)
			end
--			print("clearing out sgroup: "..genstring(Command.group_name))
		end
		Command.firsttime=1
	end
	if Command.firsttime == 2 then
		if type(Command.group_name)=="table" then
			local what=Command.group_name
			for k,v in pairs(Command.group_name) do
				Command.group_name=v
				f_create_sgroup(Command)
			end
			Command.group_name=what
		else
			if SGroup_Exists(Command.group_name) then
				SGroup_Clear(Command.group_name)
			else
				SGroup_Create(Command.group_name)
			end
		end
		return
	end
	--Now all the groups are emptied out
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	if Command.WhoList == nil then
		return false
	end
	--From here, we want to add everyone to the lists
	--So we will "combine" them instead of emptying them out every time.
	if type(Command.WhoList) == "table"  then
		local tanswer = false
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			Command.action_what=orig_what
			tanswer = f_create_sgroup(Command)
			answer = answer or tanswer
		end
	--This is where it gets sticky.  
	--Unless we have a "not" we want to combine grouplists of all the blueprints
	--Otherwise, we want to combine all the blueprints and combine all squads from affected players
	--then do an "except" on them
	--We can add blueprints, sgroups, or "All"
	elseif type(Command.action_what) == "table" then
		local tanswer= false
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			answer = false
			if type(v) ~= "table" and (v == "not" or v == "Not") then
				Command.operator="not"
			else
				tanswer = f_create_sgroup(Command)
				answer = answer or tanswer
			end
		end
		--reset it to what it was before
		Command.operator=localoperator
	else
		local templist=SGroup_CreateIfNotFound("SGroupTemp")
		local notlist=SGroup_CreateIfNotFound("NotSGroupTemp")
		SGroup_Clear(templist)
		if localoperator == "not" then
			if SGroup_Exists(Command.action_what) then
--				print("we have a sgroup.  Adding all but these:"..gensgroup(Command.action_what))
				--We just want to add the squad group to the list
				local allgroup=Player_GetSquads(  g_AllPlayerList[Command.WhoList].PlayerNum )
				local temp2=SGroup_CreateIfNotFound("SGroupTemp2")
				SGroup_Clear(temp2)
				SGroup_AddGroup(temp2,allgroup)
				--now we need to subtract our group.
				SGroup_Except("SGroupTemp2", Command.action_what)
				SGroup_AddGroup(templist,temp2)
				answer=true
			elseif SBP_Exists(Command.action_what) then
--				print("we have a blueprint")
				--Get all the squads for a player & put in a temp group
				local allgroup=Player_GetSquads(  g_AllPlayerList[Command.WhoList].PlayerNum )
				local temp2=SGroup_CreateIfNotFound("SGroupTemp2")
				local temp4=SGroup_CreateIfNotFound("SGroupTemp4")
				SGroup_AddGroup(temp2,allgroup)
--				print("Player squads: "..gensgroup("SGroupTemp4"))
				--Find all squads of type "blueprint" and put into SGroupTemp
				Util_GetSquadsByBP( "SGroupTemp4", "SGroupTemp2", Command.action_what )
--				print("Subtracting blueprint from rest")
				SGroup_Except("SGroupTemp4","SGroupTemp2")
				--Now we add these to our group
				SGroup_AddGroup(templist,temp4)
				--Get rid of our temp group
				SGroup_Destroy(temp2)
				SGroup_Destroy(temp4)
				answer=true
			elseif Marker_Exists(Command.action_what,"basic_marker") then
				local allgroup=Player_GetSquads(  g_AllPlayerList[Command.WhoList].PlayerNum )
				local temp2=SGroup_CreateIfNotFound("SGroupTemp2")
				SGroup_Clear(temp2)
				local temp4=SGroup_CreateIfNotFound("SGroupTemp4")
				SGroup_AddGroup(temp2,allgroup)
				Player_GetAllSquadsNearMarker(g_AllPlayerList[Command.WhoList].PlayerNum, "SGroupTemp4", Command.action_what)
				SGroup_Except("SGroupTemp2","SGroupTemp4")
				SGroup_AddGroup(templist,temp2)
				--Get rid of our temp group
				SGroup_Destroy(temp2)
				SGroup_Destroy(temp4)
				answer=true				
			else
--				debug_print("f_create_sgroup: We do not know what this is: "..genstring(Command.action_what))
			end
--			print("we think our group should contain: "..gensgroup("SGroupTemp"))
		else
--			print("Seeing what we have.. : "..genstring(Command.action_what))
			if SGroup_Exists(Command.action_what) then
--				print("we have a sgroup.  Adding these:"..gensgroup(Command.action_what))
				--We just want to add the squad group to the list
				SGroup_AddGroup(templist,SGroup_FromName(Command.action_what))
				answer=true
			elseif SBP_Exists(Command.action_what) then
--				print("we have a blueprint")
				--Get all the squads for a player & put in a temp group
				local allgroup=Player_GetSquads(  g_AllPlayerList[Command.WhoList].PlayerNum )
				local temp2=SGroup_CreateIfNotFound("SGroupTemp2")
				SGroup_AddGroup(temp2,allgroup)
--				print("Player squads: "..gensgroup("SGroupTemp2"))
				--Find all squads of type "blueprint" and put into SGroupTemp
				Util_GetSquadsByBP( "SGroupTemp2", "SGroupTemp", Command.action_what )
				--Get rid of our temp group
				SGroup_Destroy(temp2)
				answer=true
			elseif Marker_Exists(Command.action_what,"basic_marker") then
				--Just get all the squads near the marker
				Player_GetAllSquadsNearMarker(g_AllPlayerList[Command.WhoList].PlayerNum, "SGroupTemp", Command.action_what)
			else
--				print("We do not know what this is: "..genstring(Command.action_what))
			end
--			print("we think our group should contain: "..gensgroup("SGroupTemp"))
		end
		--At this point in time, we have our group in SGroupTemp2.
		--Now we want to set the group-names specified to that.
		--Doing this recursively can be tricky.
--		print("setting table values")
		if type(Command.group_name) == "table" then
			local temp2
			for k,v in pairs(Command.group_name) do
				temp2=SGroup_CreateIfNotFound("SGroupTemp3")
				SGroup_Clear(temp2)
				SGroup_AddGroup(temp2,templist)
				Command.group_name=v
				f_create_sgroup(Command)
				--this clears out our temp squad.  Rebiuld it
				templist=SGroup_CreateIfNotFound("SGroupTemp")
				SGroup_AddGroup(templist,temp2)
				--If we have multiple levels of recursion, we need to rebuild our test group every time.
				SGroup_Destroy(temp2)
				answer=true
			end
		else
			SGroup_CreateIfNotFound(Command.group_name)
			SGroup_AddGroup(SGroup_FromName(Command.group_name),templist)
			answer=true
		end
		if SGroup_Exists("SGroupTemp") then
			SGroup_Destroy(templist)
		end
		if SGroup_Exists("NotSGroupTemp") then
			SGroup_Destroy(notlist)
		end
	end
	return answer
end

function f_destroy(Command)
	--print("entering f_destroy")
	local k,v
	local answer=false
	local who={}
	local twho={}
	local orig_where=Command.action_where
	local mywhere=Command.action_to
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	if Command.WhoList == nil then
		print("Wholist was nothing.  Exiting")
		return false
	end
	if type(Command.WhoList) == "table"  then
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			Command.action_where=orig_where
			answer = answer or f_destroy(Command)
		end
	elseif type(Command.action_where) == "table" then
		for k,v in pairs(Command.action_where) do
			Command.action_where=v
			answer = answer or f_destroy(Command)
		end
	else
--		print("Trying to destroy stuff")
--		print("checking if wholist is a sgroup")
		--At this time we are looking at one player and one point
		if SGroup_Exists(Command.WhoList) then
			--We have a sgroup that may contain many squads.
			--Return any that are in proximity to the marker
			print("Attempting to destroy sgroup: "..genstring(Command.WhoList).." with Marker="..genstring(Command.action_where))
			local looper
			if Command.action_where ~= nil and Marker_Exists(Command.action_where,"basic_marker") then
				for looper=0, World_GetPlayerCount()-1 do
					if Player_AreSquadsNearMarker(g_AllPlayerList[looper].PlayerNum , Command.action_where ) then
						answer=true
						SGroup_CreateIfNotFound("tempGroup")
						SGroup_Clear("tempGroup")
						Player_GetAllSquadsNearMarker( g_AllPlayerList[looper].PlayerNum, "tempGroup", Command.action_where );
						local group=SGroup_FromName("tempGroup")
						--We just found all the squads near the marker.  Now limit it to the sgroup
						SGroup_Intersection(group, SGroup_FromName(Command.WhoList))
						if SGroup_Count(group) > 0 then
							World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", "tempGroup")
							--We found who we need to destroy, now do it!
							SGroup_SelfDestroy( "tempGroup", false )
						end
					end
				end
				answer = true
			else
				--There is no marker, destroy the whole group!
				World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", Command.WhoList)
				SGroup_SelfDestroy( Command.WhoList, false )
				answer = true
			end
		elseif EGroup_Exists(Command.WhoList) then
			--We have a egroup that may contain many entities.
			--Return any that are in proximity to the marker
			print("Attempting to destroy egroup: "..genstring(Command.WhoList).." with Marker="..genstring(Command.action_where))
			local looper
			if Command.action_where ~= nil and Marker_Exists(Command.action_where,"basic_marker") then
				for looper=0, World_GetPlayerCount()-1 do
					EGroup_CreateIfNotFound("tempGroup")
					EGroup_Clear("tempGroup")
					Player_GetAllEntitiesNearMarker( g_AllPlayerList[looper].PlayerNum, "tempGroup", Command.action_where );
					local group=EGroup_FromName("tempGroup")
					--We just found all the entities near the marker.  Now limit it to the egroup
					EGroup_Intersection(group, EGroup_FromName(Command.WhoList))
					if EGroup_Count(group) > 0 then
						--We found who we need to destroy, now do it!
						EGroup_SelfDestroy( "tempGroup", false )
					end
				end
				answer = true
			else
				--There is no marker, destroy the whole group!
				EGroup_SelfDestroy( Command.WhoList, false )
				answer = true
			end
		elseif Command.WhoList >=0 and Command.WhoList <= table.getn(g_AllPlayerList) then	
			--We do not have a sgroup or egroup.  It must be a player
			if Command.action_where ~= nil and Marker_Exists(Command.action_where,"basic_marker") then
				local group = Player_GetAllEntitiesNearMarker( g_AllPlayerList[Command.WhoList].PlayerNum, "tempGroup", Command.action_where );
				EGroup_SelfDestroy( "tempGroup", false )
				EGroup_Clear("tempGroup")
				if Misc_GetLocalPlayerID() == Player_GetID(g_AllPlayerList[Command.WhoList].PlayerNum) and Command.message ~= nil  then
					UIWarning_Show( Command.message )
				end
				answer=true
			else
				--here we would destroy everything belonging to the player.
				--At this moment, I do not have the heart to write that code
				--Perhaps the programmer forgot to add a marker
			end
		else
			print("We do not know what to destroy: "..genstring(Command.WhoList))
		end
	end
	return answer
end

function f_damage(Command)
	local k,v
	local answer=false
	local who={}
	local twho={}
	local orig_where=Command.action_where
	local mywhere=Command.action_to
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	if Command.WhoList == nil then
		return false
	end
	--If there is no amount, or the amount is a table
	if type(Command.action_what)=="table" then
		print("ERROR: You cannot specify multiple amounts for the Damage command")
		return false
	end
	print("original damage to give="..genstring(Command.action_what))
	if type(Command.action_what) ~= "number" then
		Command.action_what=0.01
	end
	if Command.action_what > 1.0 then
		Command.action_what = Command.action_what / 100
	end
	print("now damage to give="..genstring(Command.action_what))
	if type(Command.WhoList) == "table"  then
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			Command.action_where=orig_where
			answer = answer or f_damage(Command)
		end
	elseif type(Command.action_where) == "table" then
		for k,v in pairs(Command.action_where) do
			Command.action_where=v
			answer = answer or f_damage(Command)
		end
	else
--		print("checking if wholist is a sgroup")
		--At this time we are looking at one player and one point
		if SGroup_Exists(Command.WhoList) then
			--We have a sgroup that may contain many squads.
			--Return any that are in proximity to the marker
			print("Attempting to damage sgroup: "..genstring(Command.WhoList).." with Marker="..genstring(Command.action_where))
			local looper
			if Command.action_where ~= nil and Marker_Exists(Command.action_where,"basic_marker") then
				for looper=0, World_GetPlayerCount()-1 do
					if Player_AreSquadsNearMarker(g_AllPlayerList[looper].PlayerNum , Command.action_where ) then
						answer=true
						SGroup_CreateIfNotFound("tempGroup")
						SGroup_Clear("tempGroup")
						Player_GetAllSquadsNearMarker( g_AllPlayerList[looper].PlayerNum, "tempGroup", Command.action_where );
						local group=SGroup_FromName("tempGroup")
						--We just found all the squads near the marker.  Now limit it to the sgroup
						SGroup_Intersection(group, SGroup_FromName(Command.WhoList))
						if SGroup_Count(group) > 0 then
							answer=true
							if Command.fx=="zap" then
								World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", "tempGroup")
							end
							--We found who we need to destroy, now do it!
							if SGroup_Count("tempGroup") > 0 then
								local tmpval=SGroup_GetAvgHealth( "tempGroup"  )
								tmpval=tmpval - Command.action_what
								if Command.morale ~= nil and Command.morale then
									SGroup_SetAvgMorale("tempGroup" ,0)
								end
								if tmpval < 0 then
									SGroup_SelfDestroy("tempGroup",false)
								else
									SGroup_SetAvgHealth( "tempGroup",tmpval)
								end
							end
						end
					end
				end
			else
				--There is no marker, damage the whole group!
				if SGroup_Count(Command.WhoList) > 0 then
					if Command.fx=="zap" then
						World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", Command.WhoList)
					end
					answer=true
					local tmpval=SGroup_GetAvgHealth( Command.WhoList  )
					tmpval=tmpval - Command.action_what
					if Command.morale ~= nil and Comand.morale then
						SGroup_SetAvgMorale(Command.WhoList ,0)
					end
					if tmpval < 0 then
						SGroup_SelfDestroy(Command.WhoList,false)
					else
						SGroup_SetAvgHealth( Command.WhoList,tmpval)
					end
				end
			end
		elseif EGroup_Exists(Command.WhoList) then
			--We have a egroup that may contain many entities.
			--Return any that are in proximity to the marker
			print("Attempting to damage egroup: "..genstring(Command.WhoList).." with Marker="..genstring(Command.action_where))
			local looper
			if Command.action_where ~= nil and Marker_Exists(Command.action_where,"basic_marker") then
				for looper=0, World_GetPlayerCount()-1 do
					EGroup_CreateIfNotFound("tempGroup")
					EGroup_Clear("tempGroup")
					Player_GetAllEntitiesNearMarker( g_AllPlayerList[looper].PlayerNum, "tempGroup", Command.action_where );
					local group=EGroup_FromName("tempGroup")
					--We just found all the entities near the marker.  Now limit it to the egroup
					EGroup_Intersection(group, EGroup_FromName(Command.WhoList))
					if EGroup_Count(group) > 0 then
						answer=true
						--We found who we need to destroy, now do it!
						local tmpval=EGroup_GetAvgHealth( "tempGroup"  )
						tmpval=tmpval - Command.action_what
						if tmpval < 0 then
							EGroup_SelfDestroy("tempGroup",false)
						else
							EGroup_SetAvgHealth( "tempGroup",tmpval)
						end
					end
				end
			else
				--There is no marker, damage the whole group!
				if EGroup_Count(EGroup_FromName(Command.WhoList)) > 0 then
					answer=true
					--We found who we need to destroy, now do it!
					local origval=EGroup_GetAvgHealth( Command.WhoList  )
					local tmpval=origval
					tmpval=tmpval - Command.action_what
					if tmpval < 0 then
						EGroup_SelfDestroy(Command.WhoList,false)
					else
						print("Setting average egroup health of "..Command.WhoList.." to "..tmpval.." from "..origval.."  difference="..Command.action_what)
						EGroup_SetAvgHealth( Command.WhoList,tmpval)
					end
				end
			end
		elseif Command.WhoList >=0 and Command.WhoList <= table.getn(g_AllPlayerList) then	
			--We do not have a sgroup or egroup.  It must be a player
			answer=true
			if Command.action_where ~= nil and Marker_Exists(Command.action_where,"basic_marker") then
				local group = Player_GetAllEntitiesNearMarker( g_AllPlayerList[Command.WhoList].PlayerNum, "tempGroup", Command.action_where );
				if EGroup_Count(group) > 0 then
					--We found who we need to destroy, now do it!
					local tmpval=EGroup_GetAvgHealth( "tempGroup"  )
					tmpval=tmpval - Command.action_what
					if tmpval < 0 then
						EGroup_SelfDestroy("tempGroup",false)
					else
						EGroup_SetAvgHealth( "tempGroup",tmpval)
					end
				end
				EGroup_Clear("tempGroup")
				if Misc_GetLocalPlayerID() == Player_GetID(g_AllPlayerList[Command.WhoList].PlayerNum) and Command.message ~= nil  then
					UIWarning_Show( Command.message )
				end
			else
				--here we would destroy everything belonging to the player.
				--At this moment, I do not have the heart to write that code
				--Perhaps the programmer forgot to add a marker
			end
		end
	end
	return answer
end

function f_teleport(Command)
	local k,v
	local worked
	local answer=false
	local who={}
	local twho={}
	local orig_from=Command.action_from
	local mywhere=Command.action_to
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
		--print("in teleport with wholist: "..genstring(Command.WhoList).." Action_who:"..genstring(Command.action_who))
	end
	if Command.WhoList == nil then
		return false
	end
	--A playerID is a table that looks like: { id=1001 }
	if type(Command.WhoList) == "table"  then
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			Command.action_from=orig_from
			answer = answer or f_teleport(Command)
		end
	elseif type(Command.action_from) == "table" then
		for k,v in pairs(Command.action_from) do
			Command.action_from=v
			answer = answer or f_teleport(Command)
		end
	else
--		print("checking if wholist is a sgroup")
		--At this time we are looking at one player and one point
		if SGroup_Exists(Command.WhoList) then
			--We have a sgroup that may contain many squads.
			--Return any that are in proximity to the marker
			local looper
			for looper=0, World_GetPlayerCount()-1 do
				if Player_AreSquadsNearMarker(g_AllPlayerList[looper].PlayerNum , Command.action_from ) then
					answer=true
					Player_GetAllSquadsNearMarker( g_AllPlayerList[looper].PlayerNum, "tempGroup", Command.action_from );
					local group=SGroup_FromName("tempGroup")
					--We just found all the squads near the marker.  Now limit it to the sgroup
					SGroup_Intersection(group, SGroup_FromName(Command.WhoList))
					--Is there an exclude? 
					--   Util_GetSquadsByBP( String sourcegroup, String destgroup, String bpname ) 
					--   remove all squads that have the blueprint
					if SGroup_Count(group) > 0 then
						World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", "tempGroup")
						SGroup_DeSpawn("tempGroup")
						print("Troops close to teleport marker "..Command.action_from.."  DeSpawning")
						mywhere=return_marker(Command,2)
						if Marker_Exists(mywhere, "basic_marker") then
							SGroup_ReSpawnMarker("tempGroup", mywhere)
							SGroup_ReSpawn("tempGroup")
							print("ReSpawning them at "..mywhere)
							World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", "tempGroup")
						else
							print("end marker "..mywhere.." does not exist.  Attempting to re-spawn at home base")
							SGroup_ReSpawnPosition("tempGroup", Player_GetStartPosition(  g_AllPlayerList[looper].PlayerNum ))
							SGroup_ReSpawn("tempGroup")
							World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", "tempGroup")
						end
						--Clear the temp group so we can reuse it later
						SGroup_Clear("tempGroup")
						if Misc_GetLocalPlayerID() == Player_GetID(g_AllPlayerList[looper].PlayerNum) and Command.message ~= nil  then
							UIWarning_Show( Command.message )
						end
					end
				end
			end
		elseif Command.WhoList >=0 and Command.WhoList <= table.getn(g_AllPlayerList) then
			if Marker_Exists(Command.action_from, "basic_marker") then
				if Player_AreSquadsNearMarker(g_AllPlayerList[Command.WhoList].PlayerNum , Command.action_from ) then
					answer=true
					local group = Player_GetAllSquadsNearMarker( g_AllPlayerList[Command.WhoList].PlayerNum, "tempGroup", Command.action_from );
					World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", "tempGroup")
					SGroup_DeSpawn("tempGroup")
					print("Troops close to teleport marker "..Command.action_from.."  DeSpawning")
					mywhere=return_marker(Command,2)
					if Marker_Exists(mywhere, "basic_marker") then
						SGroup_ReSpawnMarker("tempGroup", mywhere)
						SGroup_ReSpawn("tempGroup")
						print("ReSpawning them at "..mywhere)
						World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", "tempGroup")
					else
						print("end marker "..mywhere.." does not exist.  Attempting to re-spawn at home base")
						SGroup_ReSpawnPosition("tempGroup", Player_GetStartPosition(  g_AllPlayerList[Command.WhoList].PlayerNum ))
						SGroup_ReSpawn("tempGroup")
						World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", "tempGroup")
					end
					--Clear the temp group so we can reuse it later
					SGroup_Clear("tempGroup")
					if Misc_GetLocalPlayerID() == Player_GetID(g_AllPlayerList[Command.WhoList].PlayerNum) and Command.message ~= nil  then
						UIWarning_Show( Command.message )
					end
				end
			else
				print("ERROR: The marker "..genstring(Command.action_from).."does not exist.")
			end
		end
	end
	return answer
end

function findindex(item,array)
	local v,k
	local position=-1
	for k,v in pairs(array) do
		if v == item and position == -1 then
			position=k
		end
	end
	if position == -1 then
		for k,v in ipairs(array) do
			if v == item and position == -1 then
				position=k
			end
		end
	end
	return position
end

function f_add_vplayer(Command)
	local k,v
	local answer=false
	local inuse=false
	local looper
	print ("In add vplayer")
	if type(Command.action_where) == "table"  then
		for k,v in pairs(Command.action_where) do
			Command.action_where=v
			answer = answer or f_add_vplayer(Command)
		end
	else
		print("Not a table")
		if Command.action_where ~= nil then
			print("adding vplayer: "..Command.action_where)
			local nextone=(table.getn(virtual_enemy_array)/4)
			--virtual_enemy_array[(vplayer * 4) -3] = location
			for looper = 1, nextone do
				if g_GamePlay[((looper*4)-3)] == Command.action_where then
					inuse=true
				end
			end
			print ("Is it inuse?"..genstring(inuse))
			if not inuse then
				local base=(table.getn(g_GamePlay)+1)
				g_GamePlay[base]=Command.wave or 1  --wave number.
				g_GamePlay[base+1]=Command.race or Command.action_what or "default"
				g_GamePlay[base+2]=Command.action_where 
				g_GamePlay[base+3]=Command.wavetype or "wave-trickle"
				g_GamePlay[base+4]=Command.difficulty or 1
				g_GamePlay[base+5]=Command.scap or Command.squad_cap or 20
				g_GamePlay[base+6]=Command.vcap or Command.vehicle_cap or 20
				g_GamePlay[base+7]=Command.timer or Command.delay or 10
				g_last_vplayer = g_last_vplayer + 1
				add_player(g_last_vplayer, nextone+1)
				answer=true
			end
		end
	end
	return answer
end


function f_patrol(Command)
	local k,v
	local answer=false
	local who={}
	local twho={}
	local looper
	local patrol_hash=""
	if type(Command.action_where) ~= "table"  then
		--make sure it is an array of markers.
		Command.action_where={ Command.action_where }
		answer = answer or f_patrol(Command)
	elseif type(Command.action_who) == "table"  then
		for k,v in pairs(Command.action_who) do
			Command.action_who=v
			answer = answer or f_patrol(Command)
		end
	else
		--print("entering Patrol")
		--Basically, we have one squad-group and a table of markers/sgroups/egroups
		--We do not want the squad to need to group together.  So we need
		--to basically have a table of each squad within the group,
		--where they are going, and what they are doing.  We basically will
		--list each squad and the marker they are heading towards.  When they
		--reach that marker, they get sent to the next marker in the group.
		--Cmd_AttackMoveMarker( String sgroupname, String markername )
		--markerID  Cmd_MoveToClosestMarker( String sgroupName, StringTable markerNameTable )
		--string  Marker_GetName( MarkerID marker )

		if g_PatrolArray == nil then
			g_PatrolArray={}
		end
		--Erase any values that should not be there.  Squads that died or are missing somehow
		for k,v in pairs(g_PatrolArray) do
			if SGroup_Exists(k) then
				if SGroup_Count(SGroup_FromName(k)) < 1 then
					g_PatrolArray[k]=nil
				end
			else
				g_PatrolArray[k]=nil
			end
		end
		for k,v in pairs(Command.action_where) do
			if type(v) == "string" then
				patrol_hash=patrol_hash..v
			end
		end
		--Now, itterate for each one
			local movegroups = function( sgroupid, itemindex, squadID )
				local samepos=false
				local newpos
				local k,v
				local WeAreThere
				local lastpos
				--If the squad is not controlled on this computer
				if not is_local_player(Squad_GetPlayerOwner( squadID)) then
					return true
				end
				--If there is a squad group for them, see what marker they walk to
				--If they are at the marker, move to the next
				--Otherwise, move to their marker/egroup/sgroup
				--If there is no group for them, make one and find the nearest thing to move to
				local mygroup="patrol_"..squadID.id
				--print("Telling individual squad to patrol: "..mygroup)

				--If we are patrolling a different area, zero out this patrol path
				if g_PatrolArray[mygroup] ~= nil and g_PatrolArray[mygroup].patrol_hash ~= patrol_hash then
					g_PatrolArray[mygroup]=nil
				end
				if SGroup_Exists(mygroup) and SGroup_Count(SGroup_FromName(mygroup)) > 0 and g_PatrolArray[mygroup] ~= nil then
					--g_PatrolArray[mygroup].counter=tonumber(g_PatrolArray[mygroup].counter)
					g_PatrolArray[mygroup].counter=g_PatrolArray[mygroup].counter - 1
					if g_PatrolArray[mygroup].counter < 1 then
						g_PatrolArray[mygroup].counter=g_PatrolArray[mygroup].delay
						newpos=Squad_GetPosition(squadID)
						lastpos=g_PatrolArray[mygroup].lastpos
						samepos= (newpos.x==lastpos.x and newpos.y==lastpos.y and newpos.z==lastpos.z)
						--print("positions: lastpos="..genstring(lastpos).."  newpos="..genstring(lastpos))
						if samepos and not SGroup_IsUnderAttack(mygroup,false)then
							print("The group is in the same position as last time!")
							g_PatrolArray[mygroup].stalldelay=g_PatrolArray[mygroup].stalldelay-1
							if g_PatrolArray[mygroup].stalldelay < 1 then
								g_PatrolArray[mygroup].stalldelay=g_PatrolArray[mygroup].delay
								samepos=true
							else
								samepos=false
							end
						else
							g_PatrolArray[mygroup].stalldelay=g_PatrolArray[mygroup].delay
						end
						--Determine if we are at the point.  If a marker, egroup, sgroup
						WeAreThere=false
						print("Looking at position: "..genstring(g_PatrolArray[mygroup].marker))
						print("Looking for marker: "..genstring(Command.action_where[g_PatrolArray[mygroup].marker]))
						if Marker_Exists(Command.action_where[g_PatrolArray[mygroup].marker], "basic_marker" ) then
							if Prox_AllSquadsNearMarker( mygroup, Command.action_where[g_PatrolArray[mygroup].marker] ) then
								WeAreThere=true
							end
						elseif EGroup_Exists(Command.action_where[g_PatrolArray[mygroup].marker]) then
							if Prox_SquadsInProximityOfEntities( mygroup, Command.action_where[g_PatrolArray[mygroup].marker], 15, false ) then
								WeAreThere=true
							end
						elseif SGroup_Exists(Command.action_where[g_PatrolArray[mygroup].marker]) then
							if Prox_SquadsInProximityOfSquads( mygroup, Command.action_where[g_PatrolArray[mygroup].marker], 15, false ) then
								WeAreThere=true
							end
						end
						--If we have arrived and are ready to move on..
						if WeAreThere or samepos then
							local markerindex=g_PatrolArray[mygroup].marker
							markerindex = markerindex + 1
							if markerindex > table.getn(Command.action_where) then
								markerindex=1
							end
							g_PatrolArray[mygroup].marker=markerindex
						end
						--get the position of the next item
						local mypos
						if Marker_Exists(Command.action_where[g_PatrolArray[mygroup].marker], "basic_marker") then
							mypos=Marker_GetPosition(Marker_FromName(Command.action_where[g_PatrolArray[mygroup].marker],"basic_marker"))
						elseif EGroup_Exists(Command.action_where[g_PatrolArray[mygroup].marker]) then
							mypos=EGroup_GetPosition(Command.action_where[g_PatrolArray[mygroup].marker])
						elseif SGroup_Exists(Command.action_where[g_PatrolArray[mygroup].marker]) then
							mypos=SGroup_GetPosition(Command.action_where[g_PatrolArray[mygroup].marker])
						end
						--Walk to the next egroup, sgroup, or marker
						if Command.action == nil or Command.action ~= "walk" then
							Cmd_AttackMovePos( mygroup, mypos)
							local squadpos=SGroup_GetPosition(mygroup)
							print("attack move pos.  squadpos: "..genstring(squadpos).."mypos: "..genstring(mypos))
						else
							local mywhere=Command.action_where[g_PatrolArray[mygroup].marker]
							if Marker_Exists(mywhere, "basic_marker") then
								Cmd_MoveToMarker(mygroup,mywhere)
								print("Is marker:"..mywhere)
							elseif EGroup_Exists(mywhere) then
								Cmd_MoveToEGroup(mygroup,mywhere)
								print("Is egroup:"..mywhere)
							elseif SGroup_Exists(mywhere) then
								Cmd_MoveToSGroup(mygroup,mywhere)
								print("Is sgroup:"..mywhere)
							else
								print("Woah!  We don't know what we are supposed to be patrolling to! "..mywhere)
							end
						end
						g_PatrolArray[mygroup].lastpos=Squad_GetPosition(squadID)
						print ("Telling group "..mygroup.." to patrol to marker: "..Command.action_where[g_PatrolArray[mygroup].marker].."  "..g_PatrolArray[mygroup].marker)
					end
				else
					--create/empty a group
					SGroup_CreateIfNotFound(mygroup)
					SGroup_Clear(SGroup_FromName(mygroup))
					--add the one squad to that group
					SGroup_Add(SGroup_FromName(mygroup), squadID)
					--Tell the group to move to the nearest marker/item & remember that marker
					local closestindex=-1
					local closestpos=nil
					local closestdistance=999
					local closestitem=""
					local tdistance
					local tpos
					local squadpos=SGroup_GetPosition(mygroup)
					for k,v in ipairs(Command.action_where) do
						tdistance=999
						if Marker_Exists(v, "basic_marker") then
							tpos=Marker_GetPosition(Marker_FromName(v,"basic_marker")) 
						elseif EGroup_Exists(v) then
							tpos=EGroup_GetPosition(EGroup_FromName(v))
						elseif SGroup_Exists(v) then
							tpos=SGroup_GetPosition(SGroup_FromName(v))
						end
						tdistance=World_DistancePointToPoint(squadpos , tpos)
						if tdistance < closestdistance then
							closestindex=k
							closestitem=v
							closestpos=tpos
							closestdistance=tdistance
						end
					end
					if closestdistance == 999 then
						--If we have not found a closest item
						return false
					end
					print("closest item is: "..closestitem)
					if Marker_Exists(closestitem, "basic_marker") then
						Cmd_MoveToMarker(mygroup,closestitem)
					elseif EGroup_Exists(closestitem) then
						Cmd_MoveToEGroup(mygroup,closestitem)
					elseif SGroup_Exists(closestitem) then
						Cmd_MoveToSGroup(mygroup,closestitem)
					else
						print("Woah!  We don't know what we are supposed to be patrolling to!")
					end
					g_PatrolArray[mygroup]={}
					g_PatrolArray[mygroup].marker=closestindex
					g_PatrolArray[mygroup].patrol_hash=patrol_hash
					if Command.action_where.delay == nil and Command.delay == nil then
						g_PatrolArray[mygroup].delay=3  -- We do not need to tell them where to go every second
					else
						if Command.delay == nil then
							g_PatrolArray[mygroup].delay=Command.action_where.delay
						else
							g_PatrolArray[mygroup].delay=Command.delay
						end
					end
					g_PatrolArray[mygroup].lastpos=Squad_GetPosition(squadID)
					print ("Telling group "..mygroup.." to patrol to the item: "..Command.action_where[g_PatrolArray[mygroup].marker].."  index:"..g_PatrolArray[mygroup].marker)
					g_PatrolArray[mygroup].counter=1
					g_PatrolArray[mygroup].stalldelay=g_PatrolArray[mygroup].delay
				end
			end
			if SGroup_Exists(Command.action_who) and SGroup_CountSpawned(SGroup_FromName(Command.action_who)) > 0 then
				Cpu_LockSGroupAcrossPlayers( Command.action_who )
				SGroup_ForEach( SGroup_FromName(Command.action_who), movegroups )
			end
		end
	return answer
end

function f_building_do_default(Command)
	local k,v
	local answer=false
	local who={}
	local twho={}
	local looper
	local orig_what=Command.action_what
	local orig_where=Command.action_where
	local mywhere=return_marker(Command,0)
	if type(Command.action_who) == "table"  then
		for k,v in pairs(Command.action_who) do
			Command.action_who=v
			Command.action_what=orig_what
			Command.action_where=orig_where
			answer = answer or f_building_do_default(Command)
		end
	elseif type(Command.action_what) == "table"  then
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			Command.action_where=orig_where
			answer = answer or f_building_do_default(Command)
		end
	elseif type(Command.action_where) == "table"  then
		for k,v in pairs(Command.action_where) do
			Command.action_where=v
			answer = answer or f_building_do_default(Command)
		end
	else
		Command.action_what=CMD_DefaultAction
		print("action_where: "..genstring(Command.action_where))
		if Command.action_who ~= nil and EGroup_Exists(Command.action_who) then
			if Command.action_what ~= nil then
				--We have no idea who owns it, so we try them all
				for looper = 0, (World_GetPlayerCount())-1 do
					if Command.action_where ~= nil and EGroup_Exists(Command.action_where) then
						Command_EntityEntity( World_GetPlayerAt(looper), EGroup_FromName(Command.action_who), 
							Command.action_what, EGroup_FromName(Command.action_where) )
						print("Commanding "..Command.action_who.." to do default action on an entity "..Command.action_where)
					elseif Command.action_where ~= nil and SGroup_Exists(Command.action_where) then
						Command_EntitySquad( World_GetPlayerAt(looper), EGroup_FromName(Command.action_who), 
							Command.action_what, SGroup_FromName(Command.action_where) )
						print("Commanding "..Command.action_who.." to do default action on a squad "..Command.action_where)
					elseif Command.action_where ~= nil and Marker_Exists(Command.action_where,"basic_marker") then
						Command_EntityPos( World_GetPlayerAt(looper), EGroup_FromName(Command.action_who), 
							Command.action_what, Marker_GetPosition(Marker_FromName(Command.action_where,"basic_marker") ) )
						print("Commanding "..Command.action_who.." to do default action on a position "..Command.action_where)
					elseif Command.action_where == "" then
						--Try just giving the command.  This might work for a gate or something
						Command_Entity( World_GetPlayerAt(looper), EGroup_FromName(Command.action_who), 
							Command.action_what)
						print("Commanding "..Command.action_who.." to do default action")
					end
				end
			end
		end
	end
	return answer
end


function player_add_mut(player, mut_name, mut_type, mut_method, mut_amount)
	local curmax=0
	local toamount=0
	local modifier
	print ("player_add_mut: player="..genstring(player).." mut_name="..genstring(mut_name).." amount="..genstring(mut_amount))
	if g_player_mod == nil then
		g_player_mod={}
	end
	if g_player_mod[player] == nil then
		g_player_mod[player] = {}
	end
	if mut_type == "max_squad_cap_player_modifier" then
		curmax=Player_GetMaxSquadCap(g_AllPlayerList[player].PlayerNum,CT_SquadCap)
	elseif mut_type == "max_support_cap_player_modifier" then
		curmax=Player_GetMaxSquadCap(g_AllPlayerList[player].PlayerNum,CT_SupportCap)
	elseif mut_type == "squad_cap_player_modifier" then
		curmax=Player_GetCurrentSquadCap(g_AllPlayerList[player].PlayerNum,CT_SquadCap)
	elseif mut_type == "support_cap_player_modifier" then
		curmax=Player_GetCurrentSquadCap(g_AllPlayerList[player].PlayerNum,CT_SupportCap)
	elseif mut_type == "population_cap_player_modifier" then
		curmax=100
		--There is no way to "get" this amount
	else
		curmax=mut_amount
		method="set"
	end
	--If we have a previous mod, revoke it
	if g_player_mod[player][mut_name] ~= nil then
		Modifier_Remove(g_player_mod[player][mut_name])
		g_player_mod[player][mut_name] = nil
	end
	--Generate a new mod
	if mut_method == "add" then
		toadd=curmax + mut_amount
	elseif mut_method == "sub" then
		toadd=curmax - mut_amount
	elseif mut_method == "set" then
		toadd=mut_amount
	else
		toadd=curmax
	end
	modifier = Modifier_Create(MAT_Player, mut_type, MUT_Addition, false, toadd,"")
	--Apply the new mod
	if method ~= "remove" and method ~= "revoke" then
		g_player_mod[player][mut_name] = Modifier_ApplyToPlayer(modifier, g_AllPlayerList[player].PlayerNum)
	end
end

function f_grant(Command)
	local k,v
	local answer=false
	local tanswer
	local who={}
	local twho={}
	local looper
	local orig_what=Command.action_what
	local orig_amount=Command.action_amount
	local mywhere=return_marker(Command,0)
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	if Command.WhoList == nil then
		return false
	end

	print ("f_grant: granting "..genstring(Command.WhoList).." "..genstring(Command.action_what).." "..genstring(Command.action_amount))
	if type(Command.WhoList) == "table"  then
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			Command.action_what=orig_what
			Command.action_amount=orig_amount
			Command.action_counter=k
			tanswer = f_grant(Command)
			answer = answer or tanswer
		end
	elseif type(Command.action_what) == "table"  then
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			Command.action_amount=orig_amount
			local tcount= k
			if type(Command.action_amount) == "table" then
				while tcount > table.getn(Command.action_amount) do
					tcount = tcount - table.getn(Command.action_amount)
				end
				Command.action_amount = Command.action_amount[tcount]
			end
			tanswer = f_grant(Command)
			answer = answer or tanswer
		end
	else
		debug_print ("f_grant applying: granting "..genstring(Command.WhoList).." "..genstring(Command.action_what).." "..genstring(Command.action_amount))
		--Here we grant stuff.  We have one player, one item, and one amount
		if Command.method == nil then
			Command.method = "set"
		end
		local setval
		if Command.action_what == "req" or Command.action_what == "resource" then
			setval=Player_GetResource(g_AllPlayerList[Command.WhoList].PlayerNum, RT_Requisition)
			if Command.method == "add" then
				setval = setval + Command.action_amount
			elseif Command.method == "sub" then
				setval = setval - Command.action_amount
			else
				setval=Command.action_amount
			end
			Player_SetResource(g_AllPlayerList[Command.WhoList].PlayerNum, RT_Requisition, setval)
		end
		if Command.action_what == "power" or Command.action_what == "resource" then
			setval=Player_GetResource(g_AllPlayerList[Command.WhoList].PlayerNum, RT_Power)
			if Command.method == "add" then
				setval = setval + Command.action_amount
			elseif Command.method == "sub" then
				setval = setval - Command.action_amount
			else
				setval=Command.action_amount
			end
			Player_SetResource(g_AllPlayerList[Command.WhoList].PlayerNum, RT_Power, setval)
		end
		if Command.action_what == "ork" or Command.action_what == "resource" then
			setval=Player_GetResource(g_AllPlayerList[Command.WhoList].PlayerNum, RT_Pop)
			local tamt=Command.action_amount
			if Command.action_what == "resource" then
				--resource is measured in thousands and pop in the hundreds
				tamt = tamt / 50
			end
			if Command.method == "add" then
				setval = setval + tamt
			elseif Command.method == "sub" then
				setval = setval - tamt 
			else
				setval = tamt
			end
			Player_SetResource(g_AllPlayerList[Command.WhoList].PlayerNum, RT_Pop, setval)
		end
		if Command.action_what == "scap" or Command.action_what == "cap" then
			Command.action_name="scap"
			player_add_mut(Command.WhoList, Command.action_name.."max","max_squad_cap_player_modifier" , Command.method, Command.action_amount)
			player_add_mut(Command.WhoList, Command.action_name.."current","squad_cap_player_modifier" , Command.method, Command.action_amount)
		end
		if Command.action_what == "vcap" or Command.action_what == "cap" then
			Command.action_name="vcap"
			player_add_mut(Command.WhoList, Command.action_name.."max","max_support_cap_player_modifier" , Command.method, Command.action_amount)
			player_add_mut(Command.WhoList, Command.action_name.."current","support_cap_player_modifier" , Command.method, Command.action_amount)
		end
		if Command.action_what == "pop" or Command.action_what == "cap" then
			Command.action_name="pop"
			player_add_mut(Command.WhoList, Command.action_name,"population_cap_player_modifier" , Command.method, Command.action_amount)
		end
		if Command.action_what == "research" then
			--In this case, "amount" should be a research name
			if type(Command.action_amount) == "string" then
				if Command.action_amount == "all" then
					for looper = 1, table.getn(g_AllResearch) do
						Player_GrantResearch( player, g_AllResearch[looper] )
					end
				else
					Player_GrantResearch( g_AllPlayerList[Command.WhoList].PlayerNum, Command.action_amount )
				end
				answer=true
			elseif type(Command.action_amount) == "table" then
				local k,v 
				for k,v in pairs(Command.action_amount) do
					if type(v)=="string" and v == "all" then
						for looper = 1, table.getn(g_AllResearch) do
							Player_GrantResearch( player, g_AllResearch[looper] )
							answer=true
						end
					elseif type(v)=="string" then
						Player_GrantResearch( g_AllPlayerList[Command.WhoList].PlayerNum, v )
						answer=true
					end
				end
			else
				print ("WARNING: research name is not a name!  "..genstring(Command.action_amount))
			end
		end
	end
	return answer
end

function f_summon(Command)
	local k,v
	local answer=false
	local who={}
	local twho={}
	local mywhere=return_marker(Command,0)
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	if Command.WhoList == nil then
		return false
	end
	if Command.fx == nil then
		Command.fx="zap"
	end
	--A playerID is a table that looks like: { id=1001 }
	if type(Command.WhoList) == "table"  then
		local tanswer
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			tanswer = f_summon(Command)
			answer = answer or tanswer
		end
	else
		if Command.fx == "instant" then
			if not SGroup_Exists(Command.WhoList) then
				if type(Command.WhoList)=="number" and Command.WhoList < table.getn(g_AllPlayerList) then	
					local tmp=SGroup_CreateIfNotFound("summonTemp")
					SGroup_Clear("summonTemp")
					local tmp2=Player_GetSquads( g_AllPlayerList[Command.WhoList].PlayerNum )
					SGroup_AddGroup(tmp1,tmp2)
					Command.WhoList="summonTemp"
				end
			end
			if SGroup_Exists(Command.WhoList) then
				World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", Command.WhoList)
				SGroup_DeSpawn(Command.WhoList)
				if type(mywhere) == "string" and Marker_Exists(mywhere, "basic_marker") then
					--At this time we are looking at one player and one point
					if SGroup_Exists(Command.WhoList) and SGroup_Count(SGroup_FromName(Command.WhoList)) then 
						SGroup_ReSpawnPosition( Command.WhoList,  Marker_GetPosition(Marker_FromName(mywhere,"basic_marker")))
						World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", Command.WhoList)
						answer=true
					end
				elseif type(mywhere) == "string" and SGroup_Exists(mywhere) then
					if SGroup_Exists(Command.WhoList) and SGroup_Count(SGroup_FromName(Command.WhoList)) then 
						SGroup_ReSpawnPosition( Command.WhoList,  SGroup_GetPosition(SGroup_FromName(mywhere,"basic_marker")))
						World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", Command.WhoList)
						answer=true
					end
				elseif type(mywhere) == "string" and EGroup_Exists(mywhere) then
					if SGroup_Exists(Command.WhoList) and SGroup_Count(SGroup_FromName(Command.WhoList)) then 
						SGroup_ReSpawnPosition( Command.WhoList,  EGroup_GetPosition(EGgoup_FromName(mywhere,"basic_marker")))
						World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", Command.WhoList)
						answer=true
					end
				elseif is_position(mywhere) then
					if SGroup_Exists(Command.WhoList) and SGroup_Count(SGroup_FromName(Command.WhoList)) then 
						SGroup_ReSpawnPosition( Command.WhoList, mywhere)
						World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", Command.WhoList)
						answer=true
					end
				end
			end
		else
			if Command.fx == "zap" then
				World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", Command.WhoList)
			end
			if not SGroup_Exists(Command.WhoList) then
				if type(Command.WhoList)=="number" and Command.WhoList < table.getn(g_AllPlayerList) then	
					local tmp=SGroup_CreateIfNotFound("summonTemp")
					SGroup_Clear("summonTemp")
					local tmp2=Player_GetSquads( g_AllPlayerList[Command.WhoList].PlayerNum )
					SGroup_AddGroup(tmp1,tmp2)
					Command.WhoList="summonTemp"
				end
			end
			if SGroup_Exists(Command.WhoList) then
				if type(mywhere) == "string" and Marker_Exists(mywhere, "basic_marker") then
					--At this time we are looking at one player and one point
					if SGroup_Exists(Command.WhoList) and SGroup_Count(SGroup_FromName(Command.WhoList)) then 
						Util_Summon( Command.WhoList,  Marker_GetPosition(Marker_FromName(mywhere,"basic_marker")))
						answer=true
					end
				elseif type(mywhere) == "string" and SGroup_Exists(mywhere) then
					if SGroup_Exists(Command.WhoList) and SGroup_Count(SGroup_FromName(Command.WhoList)) then 
						Util_Summon( Command.WhoList,  SGroup_GetPosition(SGroup_FromName(mywhere,"basic_marker")))
						answer=true
					end
				elseif type(mywhere) == "string" and EGroup_Exists(mywhere) then
					if SGroup_Exists(Command.WhoList) and SGroup_Count(SGroup_FromName(Command.WhoList)) then 
						Util_Summon( Command.WhoList,  EGroup_GetPosition(EGgoup_FromName(mywhere,"basic_marker")))
						answer=true
					end
				elseif is_position(mywhere) then
					if SGroup_Exists(Command.WhoList) and SGroup_Count(SGroup_FromName(Command.WhoList)) then 
						Util_Summon( Command.WhoList, mywhere)
						answer=true
					end
				end
			end
		end
	end
	return answer
end

function f_fow(Command)
	local k,v
	local answer=false
	local who={}
	local twho={}
	local fow_off=(Command.action_what == "off" or Command.action_what== "Off" or Command.action_what=="OFF")
	local time=1
	if Command.time ~= nil then
		time=Command.time
	end
	if type(Command.action_where) =="table" then
		local tanswer
		for k,v in pairs(Command.action_where) do
			Command.action_where=v
			tanswer = f_fow(Command)
			answer = answer or tanswer
		end
	else
		if Command.action_where ~= nil and SGroup_Exists(Command.action_where) then
			answer=true
			print("Setting FOW on/off for sgroup "..Command.action_where)
			if fow_off then
				FOW_RevealSGroup( SGroup_FromName(Command.action_where), time )
			else
				--There is no "unreveal" but this will basically negate it when time is 1
			end
		elseif Command.action_where ~= nil and EGroup_Exists(Command.action_where) then
			print("Setting FOW on/off for entity "..Command.action_where)
			answer=true
			if fow_off then
				FOW_RevealEGroup( EGroup_FromName(Command.action_where), time )
			else
				--There is no "unreveal" but this will basically negate it when time is 1
			end
		elseif Command.action_where ~= nil and Marker_Exists(Command.action_where,"basic_marker") then
			print("Setting FOW on/off for marker "..Command.action_where)
			answer=true
			if fow_off then
				FOW_RevealMarker( Command.action_where, time )
			else
				--There is no "unreveal" but this will basically negate it when time is 1
			end
		elseif Command.action_where == nil or Command.action_where == "all" or Command.action_where == "" or Command.action_where == "All" then
			print("Setting FOW on/off for map")
			answer=true
			if fow_off then
				FOW_RevealAll()
			else
				FOW_UnRevealAll()
			end
		end
	end
	return answer
end

function f_base(Command)
	--Drop a base at the locations expected
	--Dropping a base for multiple players on the same location will not work
	--So, if multiple players are specified, we will drop as many bases as we have locations for,
	--cycling through players until we run out of players or locations.  We will cycle through
	--races as well, or, if just one race is specified, we will use that one for all bases.
	local k,v,m
	local answer=false
	local who
	local looper
	local race
	local where
	local twhere
	local i_who
	local i_race
	local i_where
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	if Command.WhoList == nil then
		return false
	end
	who=Command.WhoList
	if type(who) ~= "table" then
		who = { who }
	end
	--print("Command="..genstring(Command))
	where=Command.action_where
	if type(where) ~= "table" then
		where = { where }
	end
	race=Command.action_race
	if type(race) ~= "table" then
		race = { race }
	end
	i_who=0
	i_race=1
	for k,i_where in pairs(where) do
		--Call the various base-creation scripts
		--We should also look for 1-military-1, 1-minefield-1, and 1-turret-1
		print("i_where="..genstring(i_where).."  where="..genstring(where))
		twhere=i_where
		for m, looper in pairs({ "military","minefield","webway","power","turret","post","hq" }) do
			if Marker_Exists(i_where.."-"..looper.."-1","basic_marker") then
				twhere=i_where.."-"..looper.."-1"
			end
		end
		if Marker_Exists(twhere,"basic_marker") then
			if Command.action_what == "regular" then
				print("dropping a base at"..twhere)
				--base_for_player(who[i_who], where[i_where], race[i_race], "compact",1)
				drop_compact_base(g_AllPlayerList[who[i_who]].PlayerNum, race[i_race], Marker_GetPosition(Marker_FromName( twhere, "basic_marker" )),1, i_where)
				answer=true
			elseif Command.action_what == "reverse" then
				print("dropping a reverse base at"..twhere.." race="..i_race)
				drop_compact_base(g_AllPlayerList[who[i_who]].PlayerNum, race[i_race], Marker_GetPosition(Marker_FromName( twhere, "basic_marker" )),-1, i_where)
				--base_for_player(who[i_who], where[i_where], race[i_race], "compact",-1)
				answer=true
			elseif Command.action_what == "spread" then
				print("dropping a spread base at"..i_where)
				drop_base(g_AllPlayerList[who[i_who]].PlayerNum, i_where, race[i_race], -1)
				answer=true
			else 
				print("ERROR: unknown type of base: "..genstring(Command.action_what))
			end
		else
			print("Marker does not exist: "..twhere)
			answer=false
		end
		i_who=i_who+1
		if i_who > (table.getn(who)-1) then
			i_who=0
		end
		i_race=i_race +1
		if i_race > table.getn(race)-1 then
			i_race=1
		end
	end
	return answer
end

function f_jump_to_wave(Command)
	local answer=true
	g_wave_number=tonumber(Command.action_what)
	UIWarning_Show( "Jumping to wave "..g_wave_number )
	if table.getn(g_WaveDelay) >= g_wave_number then
		g_wave_timer=g_WaveDelay[g_wave_number]
		print("wave timer set from array")
	else	
		if table.getn(g_WaveDelay) > 0 then
			g_wave_timer=g_WaveDelay[table.getn(g_WaveDelay)]
			print("getting wave delay from last item in array")
		else
			--Nothing is set
			g_wave_timer = g_wave_timer_max
			print ("no wave delay array set so drawing from constant of "..g_wave_timer_max)
		end
	end
	return answer
end

function f_respawn(Command)
	local k,v
	local tanswer
	local answer=false
	if type(Command.action_what)=="table" then
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			tanswer=f_respawn(Command)
			answer=answer or tanswer
		end
	else
		if Command.action_where ~= nil then
			if type(Command.action_where) == "table" then
				Command.action_where=Command.action_where[1]
				return f_respawn(Command)
			end
			if type(Command.action_where)=="string" and Marker_Exists(Command.action_where, "basic_marker") then
				Command.action_where=Marker_GetPosition(Marker_FromName(Command.action_where,"basic_marker"))
			end
			if is_position(Command.action_where) then
				if EGroup_Exists(Command.action_what) then
					EGroup_ReSpawnPosition(Command.action_what,Command.action_where)
					answer=true
				elseif SGroup_Exists(Command.action_what) then
					SGroup_ReSpawnPosition(Command.action_what,Command.action_where)
					answer=true
				end
			end
		else
			if EGroup_Exists(Command.action_what) then
				EGroup_ReSpawn(Command.action_what)
				answer=true
			elseif SGroup_Exists(Command.action_what) then
				SGroup_ReSpawn(Command.action_what)
				answer=true
			end
		end
	end
	return answer
end

function f_seed_random(Command)
	local k,v
	local answer=false
	print("setting seed: "..genstring(Command.action_what))
	if type(Command.action_what)=="table" then
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			answer=answer or f_seed_random(Command)
		end
	else
		if type(Command.action_what) == "number" then
			seed_random(Command.action_what)
			answer=true
		end
	end
	return answer
end


function f_despawn(Command)
	local k,v
	local answer=false
	local tanswer
	if type(Command.action_what)=="table" then
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			tanswer=f_despawn(Command)
			answer=answer or tanswer 
		end
	else
		if EGroup_Exists(Command.action_what) then
			EGroup_DeSpawn(Command.action_what)
			answer=true
		elseif SGroup_Exists(Command.action_what) then
			if Command.fx=="zap" then
				World_FXEventSquad( "data:Art/Events/eldar_unit_fx/warp_fx", Command.action_what)
			end
			SGroup_DeSpawn(Command.action_what)
			answer=true
		end
	end
	return answer
end

function f_set_invulnerable(Command)
	local k,v
	local answer=false
	local tanswer
	local turnon=false
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_what)
	end
	if Command.WhoList == nil then
		return false
	end
	if type(Command.WhoList)=="table" then
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			tanswer=f_set_invulnerable(Command)
			answer=answer or tanswer 
		end
	else
		if Command.action_to == "on" or Command.action_to == "On" or Command.action_to == nil then
			turnon = true
		end
		if type(Command.WhoList)=="string" and EGroup_Exists(Command.WhoList) then
			--set the egroup invulnerable
			EGroup_SetHealthInvulnerable( Command.WhoList, turnon )
			answer=true
		elseif type(Command.WhoList)=="string" and SGroup_Exists(Command.WhoList) then
			--Set the sgroup invulnerable
			SGroup_SetHealthInvulnerable( Command.WhoList, turnon )
			answer=true
			if turnon then
				print("Setting "..genstring(Command.WhoList).." invulnerable ")
			else
				print("Setting "..genstring(Command.WhoList).." to be vulnerable ")
			end
		elseif type(Command.WhoList) == "number" then
			--This should be a player...
			--Here we should make an sgroup of all their squads
			--and an egroup of all their entities
			--then call action_what on those.
			Player_GetEntities( g_AllPlayerList[Command.WhoList].PlayerNum )
			Player_GetSquads( g_AllPlayerList[Command.WhoList].PlayerNum )
			Command.WhoList={ "__Player".. Command.WhoList .."Entities","__Player".. Command.WhoList .."Squads" }
			answer=f_set_invulnerable(Command)
		end
	end
	return answer
end

function f_lock_from_ai(Command)
	local k,v
	local answer=false
	local tanswer
	local dolock=false
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_what)
	end
	if Command.WhoList == nil then
		return false
	end
	if type(Command.WhoList)=="table" then
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			tanswer=f_lock_from_ai(Command)
			answer=answer or tanswer 
		end
	else
		if Command.action_what_to == "on" or Command.action_what_to == "On" or Command.action_what_to == nil then
			dolock = true
		end
		if type(Command.WhoList)=="string" and EGroup_Exists(Command.WhoList) then
			--set the egroup invulnerable
			if turnon then
				 Cpu_LockEGroupAcrossPlayers( Command.WhoList )
			else
				Cpu_UnlockEGroupAcrossPlayers( Command.WhoList ) 
			end
			answer=true
		elseif type(Command.WhoList)=="string" and SGroup_Exists(Command.WhoList) then
			--Set the sgroup invulnerable
			if turnon then
				 Cpu_LockSGroupAcrossPlayers( Command.WhoList)
			else
				Cpu_UnlockSGroupAcrossPlayers( Command.WhoList ) 
			end
			answer=true
		elseif type(Command.WhoList) == "number" then
			--This should be a player...
			--Here we should make an sgroup of all their squads
			--and an egroup of all their entities
			--then call action_what on those.
			Player_GetEntities( g_AllPlayerList[Command.WhoList].PlayerNum )
			Player_GetSquads( g_AllPlayerList[Command.WhoList].PlayerNum )
			Command.WhoList={ "__Player".. Command.WhoList .."Entities","__Player".. Command.WhoList .."Squads" }
			answer=f_lock_from_ai(Command)
		end
	end
	return answer
end

--This function does not exist in scar, so we needed to add it
function SGroup_ResetPlayerOwner(sgroup)
	--Squad_SetWorldOwner( SquadID squad ) 
	local ResetSquad = function( sgroupid, itemindex, squadID )
        Squad_SetWorldOwner( squadID ) 
    end
	if SGroup_Exists(sgroup) then
	    SGroup_ForEach( SGroup_FromName(sgroup), ResetSquad )
	end
end

function f_change_ownership(Command)
	local k,v
	local answer=false
	local ownedby={}
	local tanswer
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	if type(Command.action_what)=="table" then
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			tanswer=f_change_ownership(Command)
			answer=answer or tanswer 
		end
	elseif type(Command.WhoList) == "table"  then
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			tanswer = f_change_ownership(Command)
			answer = answer or tanswer 
	end
	elseif type(Command.action_who)=="table" then
		print("You cannot change ownership of one item to multiple players!")
	else
		--ownedby should equal an array
		--print("Trying to change ownership of "..genstring(Command.action_what).." to player "..genstring(Command.WhoList))
		if Command.action_who == nil or (type(Command.action_who)=="string" and (Command.action_who=="none" or
				Command.action_who=="world")) then
			if EGroup_Exists(Command.action_what) then
				ownedby=EGroup_GetPlayers(Command.action_what)
				if ownedby == nil or genstring(table.getn(ownedby)) ~= genstring({}) then 
					EGroup_ResetPlayerOwner(Command.action_what)
					answer=true
				end
			elseif SGroup_Exists(Command.action_what) then
				ownedby=SGroup_GetPlayers(Command.action_what)
				if ownedby == nil or genstring(table.getn(ownedby)) ~= genstring({}) then 
					SGroup_ResetPlayerOwner(Command.action_what)
					answer=true
				end
			else
				print(genstring(Command.action_what).." is neither an existing sgroup or egroup.  Cannot change ownership")
			end
		else

			if type(Command.WhoList) == "number" then
				if EGroup_Exists(Command.action_what) and Command.WhoList > -1 and Command.WhoList <= table.getn(g_AllPlayerList) then
					ownedby=EGroup_GetPlayers(Command.action_what)
					--print("ownedby is: "..genstring(ownedby))
					if ownedby == nil or table.getn(ownedby) > 0 or ownedby[0] ~= Command.WhoList then
						EGroup_SetPlayerOwner( Command.action_what, g_AllPlayerList[Command.WhoList].PlayerNum )
						answer=true
					end
				elseif SGroup_Exists(Command.action_what) and Command.WhoList > -1 and Command.WhoList <= table.getn(g_AllPlayerList) then 
					ownedby=SGroup_GetPlayers(Command.action_what)
					if ownedby == nil or table.getn(ownedby) > 0 or ownedby[0] ~= Command.WhoList then
						SGroup_SetPlayerOwner( Command.action_what, g_AllPlayerList[Command.WhoList].PlayerNum )
						answer=true
					end
				else
					print(genstring(Command.action_what).." is neither an existing sgroup or egroup.  Cannot change ownership")
				end
			end
		end
		if Command.WhoList ~= nil and g_AllPlayerList[Command.WhoList] ~= nil then
			if answer and Misc_GetLocalPlayerID() == Player_GetID(g_AllPlayerList[Command.WhoList].PlayerNum) and Command.message ~= nil  then
				UIWarning_Show( Command.message )
			end
		end
	end
	return answer
end

function f_message(Command)
	local k,v
	local answer=false
	local tanswer
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	if type(Command.action_what)=="table" then
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			tanswer=f_message(Command)
			answer=answer or tanswer
		end
	else
		print("Calling queue_message")
		answer=queue_message(Command)
	end
	return answer
end



function explodetest( )
	print("Doing explodetest")
--	Command_EntitySquad(g_Player2,EGroup_FromName("BigGun"),CMD_DefaultAction,SGroup_FromName("mysquad"))
	Command_EntityEntity(g_Player2,EGroup_FromName("BigGun"),CMD_DefaultAction,EGroup_FromName("myentity"))
	--World_FXEvent("data:art/fx/titan/weapons/titan_cannon_big_fire_combo", Marker_GetPosition(Marker_FromName("1-military-1","basic_marker")))
end

--return the players in proximity to something
function players_in_prox(item)
	local playerlist={}
	local k, v, m, n
	local templist
	local looper
	if type(item) == "table" and not is_position(item) then
		for k,v in pairs(item) do
			templist = players_in_prox(v)
			for m,n in pairs(templist) do
				playerlist[table.getn(playerlist) + 1] =n
			end
		end
		Uniqueify(playerlist)
	else
		for looper=0,7 do
			if is_position(item) then
				print("Oops.  Haven't coded the player/position proximity")
			else if type(item)=="string" then
				if Marker_Exists(item,"basic_marker") and looper <= table.getn(g_AllPlayerList) then
					if Player_AreSquadsNearMarker( g_AllPlayerList[looper].PlayerNum, item ) then
						playerlist[table.getn(playerlist) + 1] = looper
					end
				end
				elseif SGroup_Exists(item) then
					if Prox_PlayerSquadsInProximityOfSquads(g_AllPlayerList[looper].PlayerNum, item, 10, false) then
						playerlist[table.getn(playerlist) + 1] = looper
					end
				elseif EGroup_Exists(item) then
					if Prox_PlayerSquadsInProximityOfEntities(g_AllPlayerList[looper].PlayerNum, item, 10, false) then
						playerlist[table.getn(playerlist) + 1] = looper
					end
				end
			end
		end
	end
	return playerlist
end

function getval( WhatToGet )
	local retval = WhatToGet
	local templist = {}
	local teststring=""
	local k, v
	local command
	local param
	local playerlist
	local commands = [[ "PlayerType|PlayerName|PlayerRace|PlayerNumber|PlayerWon|StartingPosition|
						 Score|NumKills|NumDeaths|ReqGathered|PowerGathered|PopGathered|ReqSpent|
						 PowerSpent|PopSpent|StructuresLost|StructuresRaised|OwnerOf|SquadStance|SquadMorale|
						 Health|PlayersInProx|JoinString|Random|Math|Count|Index|Difficulty" ]]
--	print("Entering getval "..genstring(WhatToGet))

	if type(WhatToGet) == "table" then
		--print("WhatToGet is a table")
		--First, we determine if the val is a series of values (table of tables)
		--or something we can compute off.
		retval={}
		--Go through and process any recursive variables
		for k,v in pairs(WhatToGet) do
			if type(v)=="table" then
				templist[k]=getval(v)
			else
				templist[k]=v
			end
		end
		command=templist[1]
		param=templist[2]
		--print("command="..genstring(command).."  param="..genstring(param))
		if param ~= nil then
			--translate "player1" or "team1" to basic numbers...
			playerlist = MatchPlayerList(param)
		end
		--print("after player-translation  command="..genstring(command).."  param="..genstring(param).."  playerlist="..genstring(playerlist))
		if command ~= nil and type(command) == "string" then
--			print("templist = "..genstring(templist))
			if string.find(commands,command) then
				--param is the un-playerified parameter
				--playerlist is a table containing any player numbers {0, 1, 2, 3, etc.}
				--print("We found a command! "..command) 
				--print("templist = "..genstring(templist))
				if command == "PlayerType" and playerlist ~= nil then
					-- Cpu_IsCpuPlayer( PlayerID player )
					for k,v in pairs(playerlist) do
						--print("looking for one player: "..v)
--						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
--							if Cpu_IsCpuPlayer(g_AllPlayerList[v].PlayerNum) then
--								print("Looking up player type of"..genstring(v).." playernum: "..genstring(g_AllPlayerList[v].PlayerNum).."=AI")
--								retval[table.getn(retval)+1]="AI"
--							else
--								print("Looking up player type of"..genstring(v).." playernum: "..genstring(g_AllPlayerList[v].PlayerNum).."=Human")
--								retval[table.getn(retval)+1]="Human"
--							end
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							--print("Looking up player type of"..genstring(v).." playernum: "..genstring(g_AllPlayerList[v].PlayerNum)..string.sub(g_AllPlayerList[v].Name,1,8))
							if string.sub(g_AllPlayerList[v].Name,1,8) == "Computer" then
								retval[table.getn(retval)+1]="AI"
							else
								retval[table.getn(retval)+1]="Human"
							end
							--print("Player Name="..genstring(g_AllPlayerList[v].Name))
						end
						print("player type is: "..genstring(retval))
					end
				elseif command == "PlayersInProx" then
					--make a table of all the player numbers of players in proximity
					retval=players_in_prox(param)
				elseif command == "PlayerName"  and playerlist ~= nil then
					-- Get from player_array
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							retval[table.getn(retval)+1]=g_AllPlayerList[v].Name
							--print("Player name is "..g_AllPlayerList[v].Name)
							--print("Player Name="..genstring(g_AllPlayerList[v].Name))
						else
							print("Cannot determine player name: v is "..genstring(v).."type: "..type(v))
						end
					end
				elseif command == "PlayerRace"  and playerlist ~= nil then
					-- Player_GetRace( PlayerID player )
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							retval[table.getn(retval)+1]=Player_GetRaceName( g_AllPlayerList[v].PlayerNum )
						end
					end
				elseif command == "PlayerNumber"  and playerlist ~= nil then
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							retval[table.getn(retval)+1]=v
						end
					end
				elseif command == "PlayerWon"  and playerlist ~= nil then
					-- Stats_PlayerWon( Integer playerID ) 
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							retval[table.getn(retval)+1]=Stats_PlayerWon( g_AllPlayerList[v].PlayerNum ) 
						end
					end
				elseif command == "StartingPosition"  and playerlist ~= nil  then
					-- Player_GetStartPosition( PlayerID player ) 
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							retval[table.getn(retval)+1]=Player_GetStartPosition( g_AllPlayerList[v].PlayerNum ) 
						end
					end
				elseif command == "Score"  and playerlist ~= nil then
					-- Stats_PlayerResScore( Integer playerID, Integer resourceType ) 
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							retval[table.getn(retval)+1]=Stats_PlayerResScore(  Player_GetID(g_AllPlayerList[v].PlayerNum), RT_Requisition )
							retval[table.getn(retval)]=retval[table.getn(retval)] + Stats_PlayerResScore(  Player_GetID(g_AllPlayerList[v].PlayerNum), RT_Pop ) 
							retval[table.getn(retval)]=retval[table.getn(retval)] + Stats_PlayerResScore(  Player_GetID(g_AllPlayerList[v].PlayerNum), RT_Power ) 
						end
					end
				elseif command == "NumKills"  and playerlist ~= nil then
					-- Stats_PlayerUnitsKilled( Integer playerID ) 
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							retval[table.getn(retval)+1]=Stats_PlayerUnitsKilled(  Player_GetID(g_AllPlayerList[v].PlayerNum)) 
						end
					end
				elseif command == "NumDeaths"  and playerlist ~= nil then
					-- Stats_PlayerUnitsLost( Integer playerID ) 
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							--Stats_PlayerUnitsLost( Player_GetID(playerID) )
							retval[table.getn(retval)+1]=Stats_PlayerUnitsLost( Player_GetID(g_AllPlayerList[v].PlayerNum)) 
						end
					end
				elseif command == "ReqGathered"  and playerlist ~= nil then
					-- Stats_PlayerResGathered( Integer playerID, Integer resourceType ) 
					-- Possible resource types are RT_Requisition, RT_Power and RT_Pop. 
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							retval[table.getn(retval)+1]=Stats_PlayerResGathered( g_AllPlayerList[v].PlayerNum, RT_Requisition)
						end
					end
				elseif command == "PowerGathered"  and playerlist ~= nil  then
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							retval[table.getn(retval)+1]=Stats_PlayerResGathered(g_AllPlayerList[v].PlayerNum, RT_Power)
						end
					end
				elseif command == "PopGathered"  and playerlist ~= nil then
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							retval[table.getn(retval)+1]=Stats_PlayerResGathered(g_AllPlayerList[v].PlayerNum, RT_Pop)
						end
					end
				elseif command == "ReqSpent"  and playerlist ~= nil then
					-- Stats_PlayerResSpent( Integer playerID, Integer resourceType ) 
					-- Possible resource types are RT_Requisition, RT_Power and RT_Pop. 
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							retval[table.getn(retval)+1]=Stats_PlayerResSpent( g_AllPlayerList[v].PlayerNum, RT_Requisition)
						end
					end
				elseif command == "PowerSpent"  and playerlist ~= nil then
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							retval[table.getn(retval)+1]=Stats_PlayerResSpent( g_AllPlayerList[v].PlayerNum, RT_Power)
						end
					end
				elseif command == "PopSpent"  and playerlist ~= nil then
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							retval[table.getn(retval)+1]=Stats_PlayerResSpent( g_AllPlayerList[v].PlayerNum, RT_Pop)
						end
					end
				elseif command == "StructuresLost"  and playerlist ~= nil then
					--Stats_PlayerStructuresLost( Integer playerID ) 
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							retval[table.getn(retval)+1]=Stats_PlayerStructuresLost(g_AllPlayerList[v].PlayerNum)
						end
					end
				elseif command == "StructuresRaised"  and playerlist ~= nil then
					--Stats_PlayerStructuresRazed( Integer playerID ) 
					for k,v in pairs(playerlist) do
						if type(v) == "number" and v <= table.getn(g_AllPlayerList) then
							retval[table.getn(retval)+1]=Stats_PlayerStructuresRaised(g_AllPlayerList[v].PlayerNum)
						end
					end
				elseif command == "Random" then
					retval=World_GetRand(1,param)
				elseif command == "Difficulty" then
					retval=Community_Cpu_GetDifficulty()
				elseif command == "Math" then
					retval={}
					teststring='g_tempassert = '
--					print("Math: the math originates from: "..genstring(templist))
					for k, v in pairs(templist) do
						--print ("Math: K V="..k.." "..genstring(v))
						if type(k)=="number" and k ~= 1 and type(v) ~= "table" then
							teststring=teststring.." "..v
						end
					end
					--This can add all sorts of errors
					print("Math: Gulp.  About to do math: "..genstring(teststring))
					assert(loadstring(teststring))()
					retval=g_tempassert
				elseif command == "Count" then
--					print("trying to count "..genstring(param))
					if type(param) ~= "table" then
						param = { param }
					end
					if param.what == nil then
						param.what = "items"
					end
--					print("count: param.what = "..genstring(param.what))
					if param.what == "existing" then
						retval=0
						for k,v in pairs(param) do
							--Just in case there is both a sgroup and egroup with the same name
--							print("checking "..genstring(v))
							if EGroup_Exists(v) then
								if EGroup_Count(EGroup_FromName(v)) > 0 then
--									print("It is an egroup")
									retval=retval + 1 
								end
							end
							if SGroup_Exists(v) then
--								print("sgroup exists.  Count=" ..genstring(SGroup_Count(SGroup_FromName(v))))
								if SGroup_Count(SGroup_FromName(v)) > 0 then
--									print("It is an sgroup")
									retval=retval + 1 
								end
							end
							--print("count="..retval)
						end
					elseif param.what == "list" then
						retval=table.getn(param)
					elseif param.what == "items" or param.what== "total" then
						retval=0
						for k,v in pairs(param) do
							--Just in case there is both a sgroup and egroup with the same name
							if EGroup_Exists(v) then
--								print("It is an egroup")
								retval=retval + EGroup_Count(EGroup_FromName(v))
							end
							if SGroup_Exists(v) then
--								print("It is an sgroup")
								retval=retval + SGroup_Count(SGroup_FromName(v))
							end
						end
					end
					print("Counted "..genstring(retval).."items from: "..genstring(param))
				elseif command == "Index" then
					retval={}
					--print("finding an index: "..genstring(templist))
					if templist[2]~= nil and templist[3] ~= nil and type(templist[3])=="table" then
						if type(templist[2]) ~= "table" then
							templist[2]= { templist[2] }
							--print("converting templist2 to a table." ..genstring(templist[2]))
						end
						for k,v in pairs(templist[2]) do
							if templist[3][v] == nil and type(v)=="string" then
								retval[table.getn(retval)+1]=templist[3][tonumber(v)]
							elseif templist[3][v] == nil and type(v)=="number" then
								retval[table.getn(retval)+1]=templist[3][tostring(v)]
							else
								retval[table.getn(retval)+1]=templist[3][v]
							end
						end
					end
				elseif command == "OwnerOf" then
--					print("trying to find owner of "..genstring(param))
					if type(param) ~= "table" then
						param = { param }
					end
--					print("param= "..genstring(param))
					for k,v in pairs(param) do
						print("Checking out "..genstring(v))
						if EGroup_Exists(v) then
							print("It is an egroup")
							retval[table.getn(retval)+1]=EGroup_Owners(v)
						elseif SGroup_Exists(v) then
							print("It is an sgroup")
							retval[table.getn(retval)+1]=SGroup_Owners(v)
						else
							print("We do not know what it is")
							--We do not know what it is.  Maybe it will be made into a group sometime
						end
					end
					print("We think owner is: "..genstring(retval))
				elseif command == "SquadStance" then
					if type(param) ~= "table" then
						param = { param }
					end
					for k,v in pairs(param) do
						if SGroup_Exists(v) then
							--Here we would get the stance
							--It could be mixed, etc...
							--retval[table.getn(retval)+1]=EGroup_Owners(v)
						else
							--We do not know what it is.  Maybe it will be made into a group sometime
						end
					end
				elseif command == "SquadMorale" then
					if type(param) ~= "table" then
						param = { param }
					end
					for k,v in pairs(param) do
						if SGroup_Exists(v) then
							--retval[table.getn(retval)+1]=EGroup_Owners(v)
							--Squad_GetMorale( SquadID squad ) 
						else
							--We do not know what it is.  Maybe it will be made into a group sometime
						end
					end
				elseif command == "Health" then
					if type(param) ~= "table" then
						param = { param }
					end
					retval=nil
					for k,v in pairs(param) do
--						print("health: looking at "..genstring(v))
						if type(v)=="string" and SGroup_Exists(v) then
							--retval[table.getn(retval)+1]=SGroup_Owners(v)
							--Squad_GetHealth( SquadID squad ) 
							 retval = SGroup_GetTotalHealthCurrent( v )
						elseif type(v)=="string" and EGroup_Exists(v) then
							 retval = EGroup_GetTotalHealthCurrent( v ) 
						else
							--We do not know what it is.  Maybe it will be made into a group sometime
						end

					end
					print("health of "..genstring(param).." = "..genstring(retval))
				elseif command == "JoinString" then
					local mytemp=""
					for k,v in pairs(templist) do
						if (type(k) == "string" and k == "optimize") or (type(k)=="number" and k==1)  then
							--Do nothing.  We do not want to add "optimize" to the resulting string
						elseif type(v)=="table" then
							--we join all the parts of the table
							--Insert the command "JoinString" into the table, and join that table
							table.insert (v,1, "JoinString")
							mytemp=mytemp..getval( v )
						elseif type(v) == "string" or type(v)=="number" then
							mytemp=mytemp..v
						else
							mytemp=mytemp..genstring(v)
						end
					end
					retval[1]=mytemp
				else
				end
			elseif string.find(command,"^var_") then
				--A variable used in this map
				--print("We have a var")
				if g_variables ~= nil then
					--print("Variable name: "..genstring(command))
					retval=g_variables[command]
				else
					--print("variable list was nil")
					retval=nil
				end
--				print("found var: "..genstring(command).."="..genstring(retval))
--				print("from "..genstring(g_variables))
			elseif string.find(command,"^profile_") then
				retval[2]=param
				--A variable that should be stored in the profile
				--Proper use would have a "profile_{map_}variable".
				--if no player is specified, then it will use a "global"
				--if a player is specified, it should insert the player name in the var
			elseif string.find(command,"^campaign_") then
				retval[2]=param
				--A campaign variable that should be stored in the profile
				--A campaign variable should be constructed similar to the following:
				--campaign_{map_}value
				--It will automatically be adjusted to the player specified.
				--For example, in the EZScar campaign and with a player named "Mike":
				--		{ "campaign_DarkFortress_HonorGuard","player1" }
				-- will actually check the profile variable:
				-- "[campaign_EZScar]_DarkFortress_Mike_HonorGuard"
				-- (though, the [campaign_EZScar] is computed a little more complexly for use with multiplayer)
				-- It needs to have the names of all players and the campaign hashed together
			else
				--It is not a commnd or variable.  Put it back together
				retval=templist
			end
		else
			--retval[1]=command
			--retval[2]=param

			return templist
		end
	else
		if type(retval)=="string" then
			if string.find(retval,"^var_") then
				print("Should the variable "..retval.." be inside {} ?")
			elseif string.find(retval,"^profile_") then
				print("Should the profile variable "..retval.." be inside {} ?")
			elseif string.find(retval,"^campaign_") then
				print("Should the campaign variable "..retval.." be inside {} ?")
			end
		end
		return retval
	end
	--If there is just one value, return it.  Otherwise, return the whole table
	if type(retval) == "table" and table.getn(retval) == 1 then
		debug_print("getval: returning "..genstring(retval[1]))
		return retval[1]
	elseif genstring(retval) == genstring({}) then
		debug_print("getval: returning: nil ")
		return nil
	else
		debug_print("getval: returning "..genstring(retval))
		return retval
	end
end

function f_set(Command)
	--2 parameters, variable, value
	local k,v
	local isdone=false
	if type(Command.variable) == "table" then
		for k,v in pairs(Command.variable) do
			Command.variable=v
			f_set(Command)
		end
	else
		if type(Command.variable) == "string" then
			if string.find(Command.variable,"^var_") then
				if g_variables == nil then
					g_variables={}
				end
				print("setting "..genstring(Command.variable).." to "..genstring(Command.value))
				g_variables[Command.variable]=Command.value
				isdone=true
			elseif string.find(Command.variable,"^profile_") then
				--Not done yet
			elseif string.find(Command.variable,"^campaign_") then
				--Not done yet
			else
				print("Error: variable ("..Command.variable..") not set.  Must begin with 'var_', 'profile_', or 'campaign_'")
			end
		end
	end
	return isdone
end

function f_function(Command)
	--action_func is a function
	if type(Command.action_func) == "function" then
		return Command.action_func()
	else
		print("ERROR: the custom function call was not passed a valid function"..type(Command.action_func)) 
	end
end

function f_set_stance(Command)
	--we have action_who, action_what
	local k,v
	local answer=false
	local tanswer
	local who={}
	local twho={}
	local mypos=1
	local orig_what=Command.action_what
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	if Command.WhoList == nil then
		return false
	end
	print("Setting stance: "..genstring(Command.WhoList))
	if type(Command.action_what) == "table" and type(Command.WhoList) == "table" and table.getn(Command.action_what) > 0 then
		--We need to do something with this.  Round-robin?
		for k,v in pairs(Command.WhoList) do
			if type(k) == "number" then
				Command.WhoList=v
				Command.action_what=orig_what[mypos]
				tanswer=f_set_stance(Command)
				answer = answer or tanswer
				mypos=mypos + 1
				if mypos > table.getn(orig_what) then
					mypos=1
				end
			end
		end
	elseif type(Command.WhoList) == "table"  then
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			--Command.action_where=orig_where
			tanswer = f_set_stance(Command)
			answer = answer or tanswer
		end
	else
		--At this time we are looking at one player and one stance
		if SGroup_Exists(Command.WhoList) then
			Cmd_SetStance( Command.WhoList, Command.action_what ) 
			answer=true
		elseif type(Command.WhoList)=="number" and Command.WhoList >=0 and Command.WhoList <= table.getn(g_AllPlayerList) then
			--We need to tell the player's squads to hold-fire
			if Player_IsAlive(g_AllPlayerList[Command.WhoList].PlayerNum) then
				local tgroup=Player_GetSquads( g_AllPlayerList[Command.WhoList].PlayerNum )
				Command.WhoList="stance_"..Command.action_what.."source"
				local ngroup=SGroup_CreateIfNotFound(Command.WhoList)
				SGroup_Clear(ngroup)
				SGroup_AddGroup(ngroup,tgroup)
				f_set_stance(Command)
				--SGroup_Clear(tgroup)
			end
		end
	end
	return answer
end

function f_fx(Command)
	--we have action_who, action_what
	local k,v
	local answer=false
	local tanswer
	local who={}
	local twho={}
	local mypos=1
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	local orig_who=Command.WhoList
	if Command.WhoList == nil then
		return false
	end
	print("Setting stance: "..genstring(Command.WhoList))
	if type(Command.action_what) == "table"  then
		--We need to do something with this.  Round-robin?
		for k,v in pairs(Command.action_what) do
			if type(k) == "number" then
				Command.WhoList=orig_who
				Command.action_what=v
				tanswer=f_fx(Command)
				answer = answer or tanswer
			end
		end
	elseif type(Command.WhoList) == "table"  then
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			--Command.action_where=orig_where
			tanswer = f_fx(Command)
			answer = answer or tanswer
		end
	else
		--At this time we are looking at one player and one stance
		if type(Command.action_what)=="string" and Command.action_what ~= "" then
			if SGroup_Exists(Command.WhoList) then
				World_FXEventSquad( Command.action_what, Command.WhoList)
				answer=true
			elseif is_position(Command.WhoList) then
				answer=true
				World_FXEvent( Command.action_what, Command.WhoList) 
			elseif EGroup_Exists(Command.WhoList) then
				World_FXEvent( Command.action_what, EGroup_GetPosition(EGroup_FromName(Command.WhoList) ))
				answer=true
			elseif Marker_Exists(Command.WhoList,"basic_marker") then
				Util_MarkerFX( Command.WhoList, Command.action_what)  
				answer=true
			elseif type(Command.WhoList)=="number" and Command.WhoList >=0 and Command.WhoList <= table.getn(g_AllPlayerList) then
				--We need to tell the player's squads to hold-fire
				if Player_IsAlive(g_AllPlayerList[Command.WhoList].PlayerNum) then
					local tgroup=Player_GetSquads( g_AllPlayerList[Command.WhoList].PlayerNum )
					Command.WhoList="stance_"..Command.action_what.."source"
					local ngroup=SGroup_CreateIfNotFound(Command.WhoList)
					SGroup_Clear(ngroup)
					SGroup_AddGroup(ngroup,tgroup)
					f_set_stance(Command)
					--SGroup_Clear(tgroup)
				end
			end
		end
	end
	return answer
end

function f_scatter(Command)
	local k,v
	local answer=false
	local who={}
	local twho={}
	local proximity
	local orig_where=Command.action_where
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	if Command.WhoList == nil then
		return false
	end
	--A playerID is a table that looks like: { id=1001 }
	if type(Command.WhoList) == "table"  then
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			Command.action_where=orig_where
			answer = answer or f_scatter(Command)
		end
	elseif type(Command.action_where) == "table" and not is_position(Command.action_where) then
		for k,v in pairs(Command.action_where) do
			Command.action_where=v
			answer = answer or f_scatter(Command)
		end
	else
		--At this time we are looking at one player and one point
		if SGroup_Exists(Command.WhoList) then
			--We have a sgroup that may contain many squads.
			--Return any that are in proximity to the marker
			--SGroup_Except(sgroup1, sgroup2)
--			if Player_AreSquadsNearMarker(g_AllPlayerList[Command.WhoList].PlayerNum , Command.action_where ) then
				answer=true
				local looper
				local group
				local keepgroup
				local tempgroup
				group=SGroup_CreateIfNotFound( "scatterGroup" )
				SGroup_Clear(group)
				keepgroup=SGroup_CreateIfNotFound( "nonscatterGroup" )
				SGroup_Clear(keepgroup)
				tempgroup=SGroup_CreateIfNotFound( "tmpScatterGroup" )
				SGroup_Clear(tempgroup)
				if not is_position(Command.action_where) then
					for looper = 0, table.getn(g_AllPlayerList) do
						Player_GetAllSquadsNearMarker( g_AllPlayerList[looper].PlayerNum , "tmpScatterGroup", Command.action_where )
						SGroup_AddGroup(group, tempgroup)
					end
				else
					proximity=10
					if Command.proximity ~= nil then
						proximity=Command.proximity
					end
					for looper = 0, table.getn(g_AllPlayerList) do
						Player_GetAllSquadsNearPos( g_AllPlayerList[looper].PlayerNum , "tmpScatterGroup", Command.action_where, proximity )
						SGroup_AddGroup(group, tempgroup)
					end
				end
				SGroup_Clear(tempgroup)
				--remove anything in wholist from the group
				SGroup_Except("scatterGroup",Command.WhoList)
				if not is_position(Command.action_where) then
					print("telling everyone near"..genstring(Command.action_where).." to scatter.")
					World_ScatterSquadsMarkerExcept( Command.action_where, group )
				else
					World_ScatterSquadsPositionExcept( Command.action_where, proximity, group )
				end
				SGroup_Clear(group)
				if Command.morale == true then
					for looper = 0, table.getn(g_AllPlayerList) do
						Player_GetAllSquadsNearMarker( g_AllPlayerList[looper].PlayerNum , "tmpScatterGroup", Command.action_where )
						SGroup_AddGroup(group, tempgroup)
					end
					SGroup_Intersection(group, Command.WhoList)
					SGroup_SetAvgMorale( "scatterGroup", 0 )
				end
				SGroup_Destroy("scatterGroup")
				SGroup_Destroy("nonscatterGroup")
--				if Misc_GetLocalPlayerID() == Player_GetID(g_AllPlayerList[Command.WhoList].PlayerNum) and Command.message ~= nil  then
--					UIWarning_Show( Command.message )
--				end
--			end
		elseif type(Command.WhoList)=="number" and Command.WhoList >=0 and Command.WhoList <= table.getn(g_AllPlayerList) then
			if Player_AreSquadsNearMarker(g_AllPlayerList[Command.WhoList].PlayerNum , Command.action_where ) then
				answer=true
				local looper
				local group
				local keepgroup
				group=SGroup_CreateIfNotFound( "scatterGroup" )
				SGroup_Clear(group)
				keepgroup=SGroup_CreateIfNotFound( "nonscatterGroup" )
				SGroup_Clear(keepgroup)
				for looper = 0, table.getn(g_AllPlayerList) do
					if looper ~= Command.WhoList then
						--print ("adding "..looper.." to do not add list "..genstring(g_AllPlayerList[Command.WhoList].PlayerNum))
						SGroup_AddGroup(group, Player_GetSquads( g_AllPlayerList[looper].PlayerNum ))
					end
				end
				print("telling everyone near"..Command.action_where.." to scatter.")
				World_ScatterSquadsMarkerExcept( Command.action_where, group )
				--World_ScatterSquadsMarker( Command.action_where )
				--SGroup_SelfDestroy("scatterGroup",false)
				if Command.morale == true then
					Player_GetAllSquadsNearMarker( g_AllPlayerList[Command.WhoList].PlayerNum , "nonscatterGroup", Command.action_where )
					SGroup_SetAvgMorale( "nonscatterGroup", 0 )
				end
				SGroup_Destroy("scatterGroup")
				SGroup_Destroy("nonscatterGroup")
				if Misc_GetLocalPlayerID() == Player_GetID(g_AllPlayerList[Command.WhoList].PlayerNum) and Command.message ~= nil  then
					UIWarning_Show( Command.message )
				end
			end
		end
	end
	return answer
end

function f_squad(Command)
	local k,v
	local answer=false
	local who={}
	local twho={}
	local mywhere=Command.action_to
	local mypos
	local orig_what=Command.action_what
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	--	print("returned wholist= "..genstring(Command.WhoList).." from "..genstring(Command.action_who))
	end
	if Command.WhoList == nil then
		return false
	end
	if Command.method == nil then
		Command.method="kill"
	end
	--A playerID is a table that looks like: { id=1001 }
	mywhere=return_marker(Command,0)
--	print("FSquad: where="..genstring(mywhere))
	if is_position(mywhere) then
		mypos=mywhere
		local metatable=getmetatable(item)
		local temppos
		local doit=true
		if metatable ~= nil and metatable.__scartype=="simscarpos" then
			doit=false
		end
		if doit then
			temppos=Util_ScarPos(mypos.x, mypos.y)
			temppos.x=mypos.x
			temppos.y=mypos.y
			temppos.z=mypos.z
			mypos=temppos
		end
	else
		mypos=Marker_GetPosition(Marker_FromName(mywhere,"basic_marker"))
	end
	if type(Command.WhoList) == "table"  then
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			Command.action_what=orig_what
			answer = answer or f_squad(Command)
		end
	elseif type(Command.action_what) == "table"  then
		if Command.action_what.loadout ~= nil then
			Command.loadout=Comand.action_what.loadout
		end
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			answer = answer or f_squad(Command)
		end
	else
		if Command.group_name == nil then
			if is_position(mywhere) then
				Command.group_name = genstring(mywhere).."SpawnSquad"..genstring(Command.action_what)
			else
				Command.group_name = mywhere.."SpawnSquad"..genstring(Command.action_what)
			end
		end
		--print("We are spawning at: "..genstring(mywhere).." for: "..genstring(Command.WhoList))
		if SBP_Exists(Command.action_what) then
			if Command.loadout == nil then
				Command.loadout=0
			end
			if Command.health== nil then
				Command.health=1
			end
			if Command.health > 100 then
				Command.health = 1
			end
			if Command.health > 1 then
				Command.health = Command.health / 100
			end
			if Command.WhoList <= table.getn(g_AllPlayerList) and Player_IsAlive(g_AllPlayerList[Command.WhoList].PlayerNum) == true then
				--print("Player "..Command.WhoList.." is alive to spawn for")
				if is_position(mywhere) or Marker_Exists (mywhere,"basic_marker") then
					--print("marker "..mywhere.." exists")
					--Use a groupname that allows multiple ones to be given to the same or different players
					--print("values in f_squad are: "..genstring(Command))
					local groupname
					if Command.method == "coexist" then
						groupname=Command.group_name.."-"..Command.WhoList
					else
						groupname=Command.group_name
					end
					--print("Groupname ="..groupname)
					if SGroup_Exists(groupname) then
						--print("Sgroup exists: "..Command.group_name)
						--We grab the squad ownership
						local group_ownership=SGroup_Owners(groupname)
						if type(group_ownership) == "table" then
							group_ownership=group_ownership[0]
						end
						--print ("Sgroup owned by: "..genstring(group_ownership))
						--print ("player checking against="..genstring(Command.WhoList))
						if group_ownership ~= Command.WhoList then
							--The wrong player owns the squad.  What do we do about it?
							if Command.method == "kill" then
								debug_print("Ownership does not match. killing old squad")
								SGroup_SelfDestroy(groupname, false)
							elseif Command.method == "change" then
								debug_print("Ownership does not match. Changing ownership of old one")
								SGroup_SetPlayerOwner(groupname, g_AllPlayerList[Command.WhoList].PlayerNum)
							end
						end
						if SGroup_Count(  SGroup_FromName( groupname )) < 1 then
							--print("Sgroup count > 1: "..SGroup_Count(  SGroup_FromName( Command.group_name )))
							if Command.command_table.counter > 0 then
								Command.command_table.counter = Command.command_table.counter -1
								return false
							end
							if type(Command.command_table.delay) == "table" then
								if Command.command_table.next_delay == nil then
									Command.command_table.next_delay=0
								end
								Command.command_table.counter=Command.command_table.delay[Command.command_table.next_delay]
								Command.command_table.next_delay=Command.command_table.next_delay+1
								if Command.command_table.next_delay > table.getn(Command.command_table.delay) then
									Command.command_table.next_delay=table.getn(Command.command_table.delay)
								end
							else
								Command.command_table.counter=Command.command_table.delay
							end
							--print("Just about to Spawn")
							--protected against no blueprint
							Util_CreateSquadsAtPositionEx(g_AllPlayerList[Command.WhoList].PlayerNum, groupname, Command.action_what, mypos, 1,Command.loadout)
							SGroup_SetAvgHealth( groupname, Command.health ) 
							--print("Spawned.  Create new group if does not exist: " .. Command.group_name)
							if group_name ~= Command.group_name then
								SGroup_CreateIfNotFound( Command.group_name )
								--print("Add the new entities to the group")
								SGroup_AddGroup(Command.group_name, groupname)
							end
							answer=true
						end
					else
						print("First time trying to spawn them.  Spawning...")
						print("groupname: "..genstring(groupname).."  what="..genstring(Command.action_what).."  pos="..genstring(mypos))
						--Force it to be a position
						--mypos=(Util_ScarPos(mypos.x,mypos.y))
						Util_CreateSquadsAtPositionEx(g_AllPlayerList[Command.WhoList].PlayerNum, groupname, Command.action_what, mypos, 1, Command.loadout)
						SGroup_SetAvgHealth( groupname, Command.health ) 
						--print("Making an sgroup "..Command.group_name)
						SGroup_CreateIfNotFound( Command.group_name )
						--print("Adding to the group")
						SGroup_AddGroup(Command.group_name, groupname)
						--print("Setting counter = delay ("..Command.command_table.delay..")")
						Command.command_table.counter=Command.command_table.delay
						answer=true
					end
				end
			end
		else
			print("Blueprint does not exist! "..genstring(Command.action_what))
		end
	end
	--print("f_squad returning an answer of: "..genstring(answer))
	return answer
end

function f_building(Command)
	local k,v
	local answer=false
	local who={}
	local twho={}
	local mywhere=Command.action_to
	local mypos
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	--	print("returned wholist= "..genstring(Command.WhoList).." from "..genstring(Command.action_who))
	end
	if Command.WhoList == nil then
		return false
	end
	if Command.method == nil then
		Command.method="kill"
	end
	--A playerID is a table that looks like: { id=1001 }
	mywhere=return_marker(Command,0)
	if is_position(mywhere) then
		mypos=mywhere
	else
		mypos=Marker_GetPosition(Marker_FromName(mywhere,"basic_marker"))
	end
	if type(Command.WhoList) == "table"  then
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			answer = answer or f_building(Command)
		end
	else
		if Command.group_name == nil then
			if is_position(mywhere) then
				Command.group_name = genstring(mywhere).."SpawnEntity"..genstring(Command.action_what)
			else
				Command.group_name = mywhere.."SpawnEntity"..genstring(Command.action_what)
			end
		end
		--print("We are spawning at: "..genstring(mywhere).." for: "..genstring(Command.WhoList))
		if EBP_Exists(Command.action_what) then
			if Player_IsAlive(g_AllPlayerList[Command.WhoList].PlayerNum) == true then
				--print("Player "..Command.WhoList.." is alive to spawn for")
				if Command.health== nil then
					Command.health=1
				end
				if Command.health > 100 then
					Command.health = 1
				end
				if Command.health > 1 then
					Command.health = Command.health / 100
				end
				if is_position(mywhere) or Marker_Exists (mywhere,"basic_marker") then
					--print("marker "..mywhere.." exists")
					--Use a groupname that allows multiple ones to be given to the same or different players
					--print("values in f_building are: "..genstring(Command))
					local groupname
					if Command.method == "coexist" then
						groupname=Command.group_name.."-"..Command.WhoList
					else
						groupname=Command.group_name
					end
					--print("Groupname ="..groupname)
					if EGroup_Exists(groupname) then
						--print("Egroup exists: "..Command.group_name)
						--We grab the squad ownership
						local group_ownership=EGroup_Owners(groupname)
						if type(group_ownership) == "table" then
							group_ownership=group_ownership[0]
						end
						--print ("Egroup owned by: "..genstring(group_ownership))
						--print ("player checking against="..genstring(Command.WhoList))
						if group_ownership ~= Command.WhoList then
							--The wrong player owns the squad.  What do we do about it?
							if Command.method == "kill" then
								print("Ownership does not match. killing old squad")
								EGroup_SelfDestroy(groupname, false)
							elseif Command.method == "change" then
								print("Ownership does not match. Changing ownership of old one")
								EGroup_SetPlayerOwner(groupname, g_AllPlayerList[Command.WhoList].PlayerNum)
							end
						end
						if EGroup_Count(  EGroup_FromName( groupname )) < 1 then
							--print("Egroup count > 1: "..EGroup_Count(  EGroup_FromName( Command.group_name )))
							if Command.command_table.counter > 0 then
								Command.command_table.counter = Command.command_table.counter -1
								return false
							end
							if type(Command.command_table.delay) == "table" then
								if Command.command_table.next_delay == nil then
									Command.command_table.next_delay=0
								end
								Command.command_table.counter=Command.command_table.delay[Command.command_table.next_delay]
								Command.command_table.next_delay=Command.command_table.next_delay+1
								if Command.command_table.next_delay > table.getn(Command.command_table.delay) then
									Command.command_table.next_delay=table.getn(Command.command_table.delay)
								end
							else
								Command.command_table.counter=Command.command_table.delay
							end
							--print("Just about to Spawn")
							--protected against no blueprint
							if Entity_CreateBuildingPosition(g_AllPlayerList[Command.WhoList].PlayerNum, groupname, Command.action_what, mypos, 1) then
								EGroup_SetAvgHealth(groupname, Command.health)
								--print("Spawned.  Create new group if does not exist: " .. Command.group_name)
								if group_name ~= Command.group_name then
									EGroup_CreateIfNotFound( Command.group_name )
									--print("Add the new entities to the group")
									EGroup_AddGroup(Command.group_name, groupname)
								end
								answer=true
							end
						end
					else
						print("First time trying to spawn them.  Spawning...")
						if Entity_CreateBuildingPosition(g_AllPlayerList[Command.WhoList].PlayerNum, groupname, Command.action_what, mypos, 1) then
							EGroup_SetAvgHealth(groupname, Command.health)
							--print("Making an sgroup "..Command.group_name)
							EGroup_CreateIfNotFound( Command.group_name )
							--print("Adding to the group")
							EGroup_AddGroup(Command.group_name, groupname)
							--print("Setting counter = delay ("..Command.command_table.delay..")")
							Command.command_table.counter=Command.command_table.delay
							answer=true
						end
					end
				end
			end
		else
			print("Blueprint does not exist! "..genstring(Command.action_what))
		end
	end
	--print("f_building returning an answer of: "..genstring(answer))
	return answer
end

function f_command(Command)
	local k,v
	local answer=false
	local who={}
	local twho={}
	local tanswer=false
	--we have action_who, action_what, action_where
	--who is player, egroup, sgroup
	--what is an integer
	--where is a target (egroup, sgroup, marker, position, nil)
	local orig_what=Command.action_what
	local orig_where=Command.action_where
	local orig_wherelist
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	if Command.WhoList == nil then
--		print("we got nothing from "..genstring(Command.action_who))
		return false
	end
	if Command.WhereList == nil then
		Command.WhereList={}
--		print("building wherelist from:"..genstring(Command.action_where))
		Command.WhereList=MatchPlayerList(Command.action_where)
--		print("wherelist is:"..genstring(Command.WhereList))
		if Command.WhereList == nil then
			Command.WhereList = ""
		end
--		print("wherelist is:"..genstring(Command.WhereList))
		orig_wherelist=Command.WhereList
	end
--	print("who="..genstring(Command.WhoList).."  where="..genstring(Command.WhereList))
--	print("orig who="..genstring(Command.action_who).."  where="..genstring(Command.action_where))
	if type(Command.WhoList) == "table"  then
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			Command.action_what=orig_what
			Command.action_where=orig_where
			Command.WhereList=orig_wherelist
			tanswer = f_command(Command)
			answer = answer or tanswer
		end
	elseif type(Command.action_what) == "table"  then
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			Command.action_where=orig_where
			Command.WhereList=orig_wherelist
			tanswer = f_command(Command)
			answer = answer or tanswer
		end
	elseif type(Command.WhereList) == "table"  then
		for k,v in pairs(Command.WhereList) do
			Command.WhereList=v
			tanswer = f_command(Command)
			answer = answer or tanswer
		end
	else
		print("Commanding something to do something!"..genstring(Command.WhoList))
		if EGroup_Exists(Command.WhoList) then
			--command an entity
			print("egroup wherelist="..genstring(Command.WhereList))
			local myloop
			for myloop=0,World_GetPlayerCount()-1 do
				if Player_IsAlive(World_GetPlayerAt(myloop)) and is_local_player(Squad_GetPlayerOwner( squadID)) then
					if type(Command.WhereList) == "string" and EGroup_Exists(Command.WhereList) and SGroup_Count(SGroup_FromName(Command.WhoList)) > 0  then
						Command_EntityEntity( World_GetPlayerAt(myloop), EGroup_FromName(Command.WhoList), Command.action_what, EGroup_FromName(Command.WhereList) )
					elseif type(Command.WhereList) == "string" and  SGroup_Exists(Command.WhereList) and SGroup_Count(SGroup_FromName(Command.WhoList)) >0 then
						Command_EntitySquad( World_GetPlayerAt(myloop), EGroup_FromName(Command.WhoList), Command.action_what, SGroup_FromName(Command.WhereList) )
					elseif type(Command.WhereList) == "string" and  Marker_Exists(Command.WhereList, "basic_marker") then
						Command_EntityPos( World_GetPlayerAt(myloop), EGroup_FromName(Command.WhoList), Command.action_what, Marker_GetPosition(Marker_FromName(Command.WhereList,"basic_marker") ) )
					elseif is_position(Command.WhereList) then
						Command_EntityPos( World_GetPlayerAt(myloop), EGroup_FromName(Command.WhoList), Command.action_what, Command.WhereList )
					elseif type(Command.WhereList) == "number" and Command.WhereList >= 0 and Command.WhereList <= table.getn(g_AllPlayerList) then
						--make a squadgroup of the target player and send command for that
						local tgroup=Player_GetEntities( g_AllPlayerList[Command.WhereList].PlayerNum )
						Command.WhereList="command_"..Command.action_what.."target"
						local ngroup=EGroup_CreateIfNotFound(Command.WhereList)
						EGroup_Clear(ngroup)
						EGroup_AddGroup(ngroup,tgroup)
						f_command(Command)
						--EGroup_Clear(tgroup)
					elseif Command.WhereList == "" or Command.WhereList== nil then
						Command_Entity( World_GetPlayerAt(myloop), EGroup_FromName(Command.WhoList), Command.action_what )
					end
				end
			end
		elseif SGroup_Exists(Command.WhoList) then
			--command a sgroup
			local myloop
			print("sgroup wherelist="..genstring(Command.WhereList))
--			print("what="..genstring(Command.action_what))
			for myloop=0,World_GetPlayerCount()-1 do
				if Player_IsAlive(World_GetPlayerAt(myloop)) then
					if type(Command.WhereList) == "string" and EGroup_Exists(Command.WhereList) and SGroup_Count(SGroup_FromName(Command.WhoList)) > 0 then
--						print("commanding a squad to do something to an entity:"..genstring(Command.WhereList))
						if SGroup_CountSpawned(SGroup_FromName(Command.WhoList)) > 0 then 
							Command_SquadEntity( World_GetPlayerAt(myloop), SGroup_FromName(Command.WhoList), Command.action_what, EGroup_FromName(Command.WhereList) )
							answer = true
						end
					elseif type(Command.WhereList) == "string" and SGroup_Exists(Command.WhereList) and SGroup_Count(SGroup_FromName(Command.WhoList)) >0  then
--						print("commanding a squad to do something to a squad: "..genstring(Command.WhereList))
						if SGroup_CountSpawned(SGroup_FromName(Command.WhoList)) > 0 then 
							Command_SquadSquad( World_GetPlayerAt(myloop), SGroup_FromName(Command.WhoList), Command.action_what, SGroup_FromName(Command.WhereList) )
							answer = true
						end
					elseif type(Command.WhereList) == "string" and Marker_Exists(Command.WhereList, "basic_marker") then
--						print("commanding a squad to do something to a marker: "..genstring(Command.WhereList))
						if SGroup_CountSpawned(SGroup_FromName(Command.WhoList)) > 0 then 
							Command_SquadPos( World_GetPlayerAt(myloop), SGroup_FromName(Command.WhoList), Command.action_what, Marker_GetPosition(Marker_FromName(Command.WhereList,"basic_marker") ) )
							answer = true
						end
					elseif is_position(Command.WhereList) then
--						print("commanding a squad to do something to a position: "..genstring(Command.WhereList))
						if SGroup_CountSpawned(SGroup_FromName(Command.WhoList)) > 0 then 
							Command_SquadPos( World_GetPlayerAt(myloop), SGroup_FromName(Command.WhoList), Command.action_what, Command.WhereList)
							answer = true
						end
					elseif type(Command.WhereList) == "number" and Command.WhereList >= 0 and Command.WhereList <= table.getn(g_AllPlayerList) then
						--make a squadgroup of the target player and send command for that
--						print("commanding a squad to do something to a player: "..genstring(Command.WhereList))
						local tgroup=Player_GetSquads( g_AllPlayerList[Command.WhereList].PlayerNum )
						Command.WhereList="command_"..Command.action_what.."target"
						local ngroup=SGroup_CreateIfNotFound(Command.WhereList)
						SGroup_Clear(ngroup)
						SGroup_AddGroup(ngroup,tgroup)
						answer = f_command(Command)
					elseif Command.WhereList=="" or Command.WhereList==nil then
--						print("command has no target.  Try to command it anyway")
						if SGroup_CountSpawned(SGroup_FromName(Command.WhoList)) > 0 then 
							Command_Squad( World_GetPlayerAt(myloop), SGroup_FromName(Command.WhoList), Command.action_what )
							answer = true
						end
					end
				end
			end
		elseif type(Command.WhoList) == "number" and Command.WhoList >= 0 and Command.WhoList <= table.getn(g_AllPlayerList) then
			--command a player
			--make an sgroup from all the players squads and command them
			print ("Commanding a player "..genstring(Command.WhereList))
			if Player_IsAlive(g_AllPlayerList[Command.WhoList].PlayerNum) then
				local tgroup=Player_GetSquads( g_AllPlayerList[Command.WhoList].PlayerNum )
				Command.WhoList="command_"..Command.action_what.."source"
				local ngroup=SGroup_CreateIfNotFound(Command.WhoList)
				SGroup_Clear(ngroup)
				SGroup_AddGroup(ngroup,tgroup)
				f_command(Command)
				--SGroup_Clear(tgroup)
			end
		else
			--we do not know what it is
			print("We are told to command "..genstring(Command.WhoList).." to do something, but we do not know who that is!")
		end
	end
	return answer
end

function is_local_player(player)
	--integer   World_GetPlayerIndex( PlayerID player )
	--Integer   Player_GetID( PlayerID player ) 
	--PlayerID  World_GetPlayerAt( Integer index ) 
	--PlayerID  Player_FromId( Integer id ) 
	--Boolean   Cpu_IsCpuPlayer( PlayerID player ) 
	--Integer   Misc_GetLocalPlayerID( Void  ) 
	local answer=false
--	return true
--	local player_type=""
	if type(player) == "number" and player > 8 then
		player=World_GetPlayerIndex(Player_FromID(player))
	end
	if type(player) == "table" then
		player=World_GetPlayerIndex(player)
	end
--	print("local player: looking at player "..genstring(player))
--	print("local player: looking at playerID "..genstring(Player_GetID(World_GetPlayerAt(player))))
--	print("Local player for game="..genstring(Misc_GetLocalPlayerID()))
--	player_type=getval({"PlayerType", player})
	if Cpu_IsCpuPlayer(World_GetPlayerAt(player)) then
		answer=true
		--print("Is CPU player")
	elseif Misc_GetLocalPlayerID() == Player_GetID(World_GetPlayerAt(player)) then
		answer=true
	end

	return true
end

--------------------------------------------
--############### Triggers #################
--------------------------------------------
function f_eprox(Command)
	local k,v
	local who={}
	local twho={}
	local orig_where=Command.action_where
	local orig_what=Command.action_what
	local fully_built=0
	local answer=false
	local buildings_completed = function( egroupid, itemindex, entityID )
		local mypercent=Entity_GetBuildingProgress( entityID )
		--print("Entity "..genstring(entityID).." percentage built ="..mypercent)
        if mypercent == 1 then
			fully_built = fully_built + 1
		end
    end
	if Command.operator == nil then
		Command.operator="or"
	end
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	if Command.WhoList == nil then
		return false
	end
	if type(Command.WhoList) == "table" and Command.WhoList.operator == nil then
		Command.WhoList.operator="or"
	end
--	print("Checking proximity with Command: "..genstring(Command))
	if Command.operator == "and" then
		answer=true
	end
	if type(Command.WhoList) == "table"  then
		local tanswer
		local tmpop=Command.WhoList.operator
		if tmpop == nil then
			tmpop = "or"
		end
		if Command.WhoList.operator ~= nil and Command.WhoList.operator == "and" then
			answer=true
		else
			answer=false
		end
		--print("WhoList is a table")
		for k,v in pairs(Command.WhoList) do
			if type(k) == "number" then
				Command.WhoList=v
				Command.action_what=orig_what
				Command.action_where=orig_where
	--			print("resetting wholist and re-calling proximity: "..genstring(Command))
				tanswer=f_eprox(Command)
				if tmpop == "and" then
					answer = answer and tanswer
					--print("'who' doing 'and' with answer: "..genstring(answer).." and tanswer: "..genstring(tanswer).." wholist: "..v)
				else
					answer = answer or tanswer 
					--print("'who' doing 'or' with answer: "..genstring(answer).." and tanswer: "..genstring(tanswer).." wholist: "..v)
				end
			end
		end
	elseif type(Command.action_what) == "table" then
		if Command.action_what.operator ~= nil then
			Command.operator=Command.action_what.operator
		end
		--print("EProx what Command.operator="..Command.operator)
		if Command.operator == "and" then
			answer=true
		else
			answer=false
		end
		local tanswer=true
		local myop = Command.operator
		for k,v in ipairs(Command.action_what) do
			Command.action_what=v
			Command.action_where=orig_where
			if myop == "and" then
				tanswer = f_eprox(Command)
				answer = answer and tanswer 
					--print("'what' doing 'and' with answer: "..genstring(answer).." tanswer= "..genstring(tanswer).." wholist: "..v)
			else
				tanswer = f_eprox(Command)
				answer = answer or tanswer 
					--print("'what' doing 'or' with answer: "..genstring(answer).." tanswer= "..genstring(tanswer).." wholist: "..v)
			end
			--print("EProx: answer in 'what' for is: "..genstring(answer))
		end
	elseif type(Command.action_where) == "table" then
		if Command.action_where.operator ~= nil then
			Command.operator=Command.action_where.operator
		end
		--print("EProx where Command.operator="..Command.operator)
		if Command.operator == "and" then
			answer=true
		else
			answer=false
		end
		local myop = Command.operator
		for k,v in ipairs(Command.action_where) do
			Command.action_where=v
			local tanswer=true
			if myop == "and" then
				tanswer = f_eprox(Command)
				answer = answer and tanswer 
					--print("'where' doing 'and' with answer: "..genstring(answer).." tanswer= "..genstring(tanswer).." wholist: "..v)
			else
				tanswer = f_eprox(Command)
				answer = answer or tanswer 
					--print("'where' doing 'or' with answer: "..genstring(answer).." tanswer= "..genstring(tanswer).." wholist: "..v)
			end
			--print("EProx: answer in 'where' for is: "..genstring(answer))
		end
	else
		--print("Checking entity proximity: "..genstring(Command))
		answer=false
		local proximity=10
		if Command.proximity ~= nil then
			proximity=Command.proximity
		end
		--At this time we are looking at one player, one optional entity_blueprint and one marker/egroup/sgroup 
		if type(Command.WhoList) == "number" and Command.WhoList >=0 and Command.WhoList <= table.getn(g_AllPlayerList) then
			if EGroup_Exists(Command.action_where) then
				--print("Checking egroup prox for"..genstring(Command.action_where))
				if Command.action_what ~= "" then
					if EBP_Exists(Command.action_what) then
						local testgroup1="TempEPROXGroup1"
						local testgroup2="TempEPROXGroup2"
						local testgroup1id=EGroup_CreateIfNotFound(testgroup1)
						EGroup_Clear(testgroup1id)
						local testgroup2id=EGroup_CreateIfNotFound(testgroup2)
						EGroup_Clear(testgroup2id)
						Player_GetAllEntitiesNearPos( g_AllPlayerList[Command.WhoList].PlayerNum , testgroup1, EGroup_GetPosition(EGroup_FromName(Command.action_where))  )
						Util_GetEntitiesByBP( testgroup1, testgroup2, Command.action_what)
						--We need to verify that one of the entities is fully built
						--the next command counts how many of the buildings in testgroup2 are fully built
						EGroup_ForEach(testgroup2id,buildings_completed)
						if fully_built > 0 then
							answer=true
						end
						--print("The number of fully built "..Command.action_what.." buildings is: "..fully_built)
					else
						debug_print("EProx: No such blueprint: "..Command.action_what)
					end
				else
					if Prox_PlayerEntitiesInProximityOfEntities( g_AllPlayerList[Command.WhoList].PlayerNum, 
						Command.action_where, proximity, false) then
						answer=true
					end
				end
			elseif SGroup_Exists(Command.action_where) then
				--print("Checking sgroup prox for"..genstring(Command.action_where))
				if Command.action_what ~= "" then
					if EBP_Exists(Command.action_what) then
						local testgroup1="TempEPROXGroup1"
						local testgroup2="TempEPROXGroup2"
						local testgroup1id=EGroup_CreateIfNotFound(testgroup1)
						EGroup_Clear(testgroup1id)
						local testgroup2id=EGroup_CreateIfNotFound(testgroup2)
						EGroup_Clear(testgroup2id)
						Player_GetAllEntitiesNearPos( g_AllPlayerList[Command.WhoList].PlayerNum , testgroup1, SGroup_GetPosition( Sgroup_FromName(Command.action_where ))  )
						Util_GetEntitiesByBP( testgroup1, testgroup2, Command.action_what)
						--the next command counts how many of the buildings in testgroup2 are fully built
						EGroup_ForEach(testgroup2id,buildings_completed)
						if fully_built > 0 then
							answer=true
						end
						--print("The number of fully built "..Command.action_what.." buildings is: "..fully_built)
					else
						debug_print("EPROX: No such blueprint: "..Command.action_what)
					end
				else
					if Prox_PlayerEntitiesInProximityOfSquads( g_AllPlayerList[Command.WhoList].PlayerNum, 
					  Command.action_where,  proximity, false) then
						answer=true
					end
				end
			elseif Marker_Exists(Command.action_where, "basic_marker" ) then
				answer=false
				if Command.action_what ~= "" then
					if EBP_Exists(Command.action_what) then
						local testgroup1="TempEPROXGroup1"
						local testgroup2="TempEPROXGroup2"
						local testgroup1id=EGroup_CreateIfNotFound(testgroup1)
						EGroup_Clear(testgroup1id)
						local testgroup2id=EGroup_CreateIfNotFound(testgroup2)
						EGroup_Clear(testgroup2id)
						Player_GetAllEntitiesNearMarker( g_AllPlayerList[Command.WhoList].PlayerNum , testgroup1, Command.action_where  )
						Util_GetEntitiesByBP( testgroup1, testgroup2, Command.action_what) 
						--the next command counts how many of the buildings in testgroup2 are fully built
						EGroup_ForEach(testgroup2id,buildings_completed)
						if fully_built > 0 then
							answer=true
						end
						--print("The number of fully built "..Command.action_what.." buildings is: "..fully_built)
					else
						debug_print("EProx: No such blueprint: "..Command.action_what)
					end
				else
					if Player_AreEntitiesNearMarker(g_AllPlayerList[Command.WhoList].PlayerNum , Command.action_where ) then
						answer=true
					end
				end
			else
				print("EProx: Don't know what is: "..Command.action_where)
			end
			if type(Command.WhoList)=="number" then
				if answer and Misc_GetLocalPlayerID() == Player_GetID(g_AllPlayerList[Command.WhoList].PlayerNum) and Command.message ~= nil  then
					UIWarning_Show( Command.message )
				end
			end
		end
	end
	return answer
end

function f_proximity(Command)
	local k,v
	local who={}
	local twho={}
	local orig_where=Command.action_where
	local answer=false
	if Command.operator == nil then
		Command.operator="or"
	end
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	if Command.WhoList == nil then
		if Command.true_if_empty ~= nil and Command.true_if_empty == true then
			return true
		else
			return false
		end
	end
	if type(Command.WhoList) == "table" and Command.WhoList.operator == nil then
		Command.WhoList.operator="or"
	end
--	print("Checking proximity with Command: "..genstring(Command))
	if Command.operator == "and" then
		answer=true
	end
	if type(Command.WhoList) == "table"  then
		local tanswer
		local tmpop=Command.WhoList.operator
		if Command.WhoList.operator ~= nil and Command.WhoList.operator == "and" then
			answer=true
		else
			answer=false
		end
		--print("WhoList is a table")
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			Command.action_where=orig_where
--			print("resetting wholist and re-calling proximity: "..genstring(Command))
			tanswer=f_proximity(Command)
			if tmpop == "and" then
				answer = answer and tanswer 
			else
				answer = answer or tanswer 
			end
		end
	elseif type(Command.action_where) == "table" then
		if Command.operator == "and" then
			answer=true
		else
			answer=false
		end
		for k,v in pairs(Command.action_where) do
			Command.action_where=v
			if Command.operator == "and" then
				answer = answer and f_proximity(Command)
			else
				answer = answer or f_proximity(Command)
			end
		end
	else
		local doitforall=true
		if Command.modifier==nil then
			Command.modifier="any"
		end
		if Command.modifier=="all" then
			doitforall=true
		else
			doitforall=false
		end
		local proximity=10
		if Command.proximity ~= nil then
			proximity=Command.proximity
		end
		--At this time we are looking at one player and one point
		if SGroup_Exists(Command.WhoList) then
			--It is a sgroup and not a player we are checking
			answer=false
			if type(Command.action_where) == "string" and EGroup_Exists(Command.action_where) then
				print("Any squad from "..Command.WhoList.." in proximity to egroup "..Command.action_where)
				if Prox_SquadsInProximityOfEntities( Command.WhoList, Command.action_where, proximity, doitforall ) then
					answer=true
				end
			elseif type(Command.action_where) == "string" and SGroup_Exists(Command.action_where) then
				print("Any squad from "..Command.WhoList.." in proximity to sgroup "..Command.action_where)
				if Prox_SquadsInProximityOfSquads( Command.WhoList, Command.action_where, proximity, doitforall ) then
					answer=true
				end
			elseif type(Command.action_where) == "string" and Marker_Exists(Command.action_where, "basic_marker" ) then
				print("Any squad from "..Command.WhoList.." in proximity to marker "..Command.action_where)
				if doitforall then
					if Prox_AllSquadNearMarker( Command.WhoList, Command.action_where ) then
						answer=true
					end
				else
					if Prox_AnySquadNearMarker( Command.WhoList, Command.action_where ) then
						answer=true
					end
				end
			end
			if type(Command.WhoList)=="number" then
				if answer and Misc_GetLocalPlayerID() == Player_GetID(g_AllPlayerList[Command.WhoList].PlayerNum) and Command.message ~= nil  then
					UIWarning_Show( Command.message )
				end
			end
		elseif type(Command.WhoList) == "number" and Command.WhoList >=0 and Command.WhoList <= table.getn(g_AllPlayerList) then
			--Turn all the player entities into one group, then use the group commands on it
			Player_GetSquads( g_AllPlayerList[Command.WhoList].PlayerNum )
			Command.WhoList="__Player"..Command.WhoList.."Squads"
			answer=f_proximity(Command)
		else
			if (type(Command.WhoList)=="string" and Command.WhoList~="or") or type(Command.WhoList)=="number" then
				if Command.true_if_empty ~= nil and Command.true_if_empty == true then
					print("group "..Command.WhoList.." does not exist, returning true regardless")
					answer=true
				end
			end
		end
		if answer then
			print ("prox is true")
		else
			print("prox is false")
		end
	end
	return answer
end

function f_egroup_destroyed(Command)
	local k,v
	local count
	local answer=true
	if Command.operator == "or" then
		answer=false
	else
		Command.operator="and"
	end
	if Command.times_to_fire == nil then
		Command.times_to_fire = 1
	end
	if type(Command.action_what) == "table" then
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			if Command.operator == "and" then
				answer = answer and f_egroup_destroyed(Command)
			else
				answer = answer or f_eroup_destroyed(Command)
			end
		end
	else
		answer=false
		if EGroup_Exists(Command.action_what) then
			--Not only does it exist, but there needs to be something in it
			count=EGroup_Count( EGroup_FromName(Command.action_what) )
			if count > 0 then
				if Command.times_to_fire ~= nil then
					Command.command_table.exists=Command.times_to_fire
				else
					Command.command_table.exists = 1
				end
			else
				if Command.command_table.exists ~= nil and (type(Command.command_table.exists)=="number" and Command.command_table.exists>=1) then
					--Mark that it no longer exists, so we only fire once
					Command.command_table.exists=Command.command_table.exists-1
					answer=true
				end
			end
		end
	end
	return answer
end

function f_wave_is(Command)
	--action_what=wave to compare
	--action_operator = > < before
	local k,v
	local count
	local answer=false
	if type(Command.action_what) == "table" then
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			answer = answer or f_wave_is(Command)
		end
	else
		print("WaveIs:  wave: "..g_wave_number.." operator: "..Command.action_operator.." compareto: "..Command.action_what.."  wave_timer: "..g_wave_timer.." alreadyspawning="..genstring(g_already_spawning))
		answer=false
		--make sure it is a number
		Command.action_what=tonumber(Command.action_what)
		if Command.action_operator == ">" then
			if g_wave_number > Command.action_what then
				answer=true
			end
		elseif Command.action_operator == "<" then
			if g_wave_number < Command.action_what then
				answer=true
			end
		elseif Command.action_operator == "=" then
			if ((g_wave_number == (Command.action_what + 1) and g_already_spawning == false) or 
				(g_wave_number == Command.action_what and g_already_spawning == true)) then
				answer=true
			end
		elseif Command.action_operator == "before" or Command.action_operator == "Before" then
			if g_wave_number == Command.action_what and g_wave_timer > 0 then
				answer=true
			end
		elseif Command.action_operator == "during" or Command.action_operator == "During" then
			if g_wave_number == Command.action_what and g_wave_timer == 0 then
				answer=true
			end
		end
	end
	return answer
end

function f_sgroup_destroyed(Command)
	local k,v
	local count
	local answer=true
	if Command.operator == "or" then
		answer=false
	else
		Command.operator="and"
	end
	if Command.times_to_fire == nil then
		Command.times_to_fire = 1
	end
	if type(Command.action_what) == "table" then
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			if Command.operator == "and" then
				answer = answer and f_sgroup_destroyed(Command)
			else
				answer = answer or f_sgroup_destroyed(Command)
			end
		end
	else
		answer=false
		print("Checking if sgroup exists: "..genstring(Command.action_what))
		if SGroup_Exists(Command.action_what) then
			--Not only does it exist, but there needs to be something in it
			count=SGroup_Count( SGroup_FromName(Command.action_what) )
			print("SGroup exists: "..Command.action_what.." with # "..count)
			if count > 0 then
				--mark it as existing
				Command.command_table.exists=tonumber(Command.times_to_fire)
				print("marking it as existing")
			else
				if Command.command_table.exists == nil then
					Command.command_table.exists=1
				end
				--If it once exsited, but now is gone
				if Command.command_table.exists >= 1 then
					--We set it so it only fires a few times (it only gets destroyed once)
					Command.command_table.exists=Command.command_table.exists-1
					answer=true
					print("used to exist!")
				end
			end
		end
	end
	if answer then
		print("sgroup "..genstring(Command.action_what).." destroyed")
	end
	return answer
end

function f_egroup_exists(Command)
	local k,v
	local count
	local answer=true
	if Command.operator == "or" then
		answer=false
	else
		Command.operator="and"
	end
	if type(Command.action_what) == "table" then
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			if Command.operator == "and" then
				answer = answer and f_egroup_exists(Command)
			else
				answer = answer or f_eroup_exists(Command)
			end
		end
	else
		answer=false
		if EGroup_Exists(Command.action_what) then
			--Not only does it exist, but there needs to be something in it
			count=EGroup_Count( EGroup_FromName(Command.action_what) )
			print ("egroup contains "..count.." items")
			if count > 0 then
				answer=true
			end
		end
	end
	return answer
end
function f_sgroup_exists(Command)
	local k,v
	local count
	local answer=true
	if Command.operator == "or" then
		answer=false
	else
		Command.operator="and"
	end
	if type(Command.action_what) == "table" then
		for k,v in pairs(Command.action_what) do
			Command.action_what=v
			if Command.operator == "and" then
				answer = answer and f_sgroup_exists(Command)
			else
				answer = answer or f_sgroup_exists(Command)
			end
		end
	else
		answer=false
		if SGroup_Exists(Command.action_what) then
			--Not only does it exist, but there needs to be something in it
			count=SGroup_Count( SGroup_FromName(Command.action_what) )
			print ("sgroup contains "..count.." items")
			if count > 0 then
				answer=true
			end
		end
	end
	return answer
end


function f_player_dead(Command)
	local k,v
	local answer=true
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
	if Command.WhoList == nil then
		return false
	end
	--A playerID is a table that looks like: { id=1001 }
	if type(Command.WhoList) == "table"  then
		for k,v in pairs(Command.WhoList) do
			Command.WhoList=v
			answer=answer and f_player_dead(Command)
		end
	else
	--Go through each player individually.  Break up "groups" (team, player, players)
	--At this time we are looking at one player
		answer=Player_IsAlive(g_AllPlayerList[Command.WhoList].PlayerNum)
	--the above does not work for vplayers
	end
	return answer
end

function f_compare(Command)
	local k,v
	local answer=false
	local operator=Command.action_operator
	local left_side=Command.left_side
	local right_side=Command.right_side
	local tl=type(left_side)
	local tr=type(right_side)
	local orig_left=left_side
	local orig_right=right_side
	--We have three items.  left_side, right_side, and operator.
	--Change the operator to be consistant
	if operator == "!=" or operator=="<>" then
		operator="~="
	end
	if Command.operator == nil then
		Command.operator = "and"
	end
	if tl == "table" and tr == "table" then
		--Compare each item individually, or compare genstring versions?
		if table.getn(left_side) == table.getn(right_side) or Command.operator == "or" then
			if Command.operator == "or" then
				answer= false
			else
				answer=true
			end
			for k,v in pairs(left_side) do
				Command.left_side=v
				Command.right_side=orig_right[k]
				if f_compare(Command) then
					if Command.operator == "or" then
						answer= true
					else
						answer=answer and true
					end
				else
					if Command.operator == "or" then
						answer = answer or false
					else
						answer = false
					end
				end
			end
		end
	elseif tl == tr then
		if operator == "=" then
			if left_side == right_side then
				answer = true
			end
		elseif operator == "<" then
			if left_side < right_side then
				answer = true
			end
		elseif operator == ">" then
			if left_side > right_side then
				answer = true
			end
		elseif operator == "~=" then
			if left_side ~= right_side then
				answer = true
			end
		end
	else
		--We might be comparing "6" with 6
		--or it might be "6" and "TimYoung"
		if tl == "table" or tr == "table" then
			if Command.operator == "or" then
				answer = false
			else
				answer = true
			end
			if tl == "table" then
				Command.left_side=orig_right
				Command.right_side=orig_left
				right_side=orig_left
			end
			for k,v in pairs(right_side) do
				Command.right_side=v
				if f_compare(Command) then
					if Command.operator == "or" then
						answer = true
					else
						answer = answer and true
					end
				else
					if Command.operator == "or" then
						answer = answer or false
					else
						answer = false
					end
				end
			end
		else
			print("compare types differ: "..genstring(tl).." "..genstring(tr))
			print ("Comparing "..genstring(left_side)..genstring(operator)..genstring(right_side))
			if operator == "=" then
				if genstring(left_side).."" == genstring(right_side).."" then
					answer = true
				end
			elseif operator == "<" then
				if genstring(left_side).."" < genstring(right_side).."" then
					answer = true
				end
			elseif operator == ">" then
				if genstring(left_side).."" > genstring(right_side).."" then
					answer = true
				end
			elseif operator == "~=" then
				if genstring(left_side).."" ~= genstring(right_side).."" then
					answer = true
				end
			end
		end
	end
	if answer then
		print ("Comparing "..genstring(left_side)..genstring(operator)..genstring(right_side))
	else
		debug_print ("Comparing "..genstring(left_side)..genstring(operator)..genstring(right_side))
	end
	return answer
end

function f_always(Command)
	return true
end

function f_point_taken(Command)
	local k,v
	local answer=false
	local who={}
	local tanswer
	local operator
	local orig_what=Command.action_what
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
--	print("entering f_point_taken: "..genstring(Command.action_who).."  "..genstring(Command.WhoList).."  "..genstring(Command.action_what))
	if Command.WhoList == nil then
		return false
	end
	if type(Command.action_what) == "table" then
--		print("f_point_taken has a table: "..genstring(Command.action_what))
		if Command.action_what.operator== nil or Command.action_what.operator=="and" then
			Command.action_what.operator="and"
			answer=true
		end
		if Command.action_what.operator== "or" then
			answer=false
		end
--		print("f_point_taken: start answer="..genstring(answer))
		operator=Command.action_what.operator
		for k,v in ipairs(Command.action_what) do
			Command.action_what=v
			tanswer=f_point_taken(Command)
			Command.action_what=orig_what
--			print ("f_point_taken: "..v.." answer="..genstring(tanswer)) 
			if operator== "and" then
				answer=answer and tanswer
			else
				answer=answer or tanswer
			end
--			print("f_point_taken: answer="..genstring(answer))
		end
	else
		answer=false
		--At this time we are looking at one point and a table of "WhoList"
		for k,v in pairs(Command.WhoList) do
			if v >=0 and v <= table.getn(g_AllPlayerList) then
				--local point=EGroup_FromName(Command.action_what)
				if EGroup_Exists(Command.action_what) then
					if EGroup_IsCapturedByPlayer( Command.action_what, g_AllPlayerList[v].PlayerNum, false ) then
						answer=true
					end
				else
					print("No such egroup to check if captured: "..Command.action_what)
				end
			end
		end
	end
	return answer
end

function f_point_controlled(Command)
	local k,v
	local answer=false
	local who={}
	local tanswer
	local operator
	local orig_what=Command.action_what
	if Command.WhoList==nil then
		Command.WhoList={}
		Command.WhoList= MatchPlayerList(Command.action_who)
	end
--	print("entering f_point_controlled: "..genstring(Command.action_who).."  "..genstring(Command.WhoList).."  "..genstring(Command.action_what))
	if Command.WhoList == nil then
		return false
	end
	if type(Command.action_what) == "table" then
--		print("f_point_controlled has a table: "..genstring(Command.action_what))
		if Command.action_what.operator== nil or Command.action_what.operator=="and" then
			Command.action_what.operator="and"
			answer=true
		end
		if Command.action_what.operator== "or" then
			answer=false
		end
--		print("f_point_controlled: start answer="..genstring(answer))
		operator=Command.action_what.operator
		for k,v in ipairs(Command.action_what) do
			Command.action_what=v
			tanswer=f_point_controlled(Command)
			Command.action_what=orig_what
--			print ("f_point_controlled: "..v.." answer="..genstring(tanswer)) 
			if operator== "and" then
				answer=answer and tanswer
			else
				answer=answer or tanswer
			end
--			print("f_point_controlled: answer="..genstring(answer))
		end
	else
		answer=false
		--At this time we are looking at one point and a table of "WhoList"
		for k,v in pairs(Command.WhoList) do
			if v >=0 and v <= table.getn(g_AllPlayerList) then
				--local point=EGroup_FromName(Command.action_what)
				if EGroup_Exists(Command.action_what) then
					if EGroup_IsCapturedByPlayer( Command.action_what, g_AllPlayerList[v].PlayerNum, false ) then
						answer=true
					end
				else
					print("No such egroup to check if captured: "..Command.action_what)
				end
			end
		end
	end
	return answer
end

--------------------------------------------
--################ Parsing #################
--------------------------------------------

--Trigger
TriggerType={ operator="and", trigger= "Always",  delay=0, counter=0, once=false, exists=-1, position=1, rotation="next", limit=-1 }
function TriggerType:New(o)
	o=o or {};
	setmetatable(o,self)
	self.__index= self
	return o
end

--Action
ActionType={ action = "none", delay=0, counter=0, once=false, exists=-1, position=1, rotation="next", limit=-1 }
function ActionType:New(o)
	o=o or {};
	setmetatable(o,self)
	self.__index= self
	return o
end

--Rule
RuleType={ trigger={}, action={} }
function RuleType:MeetsCriteria()
	return criteria_met(self.trigger)
end

--Need to accept a list of things affected by trigger
function RuleType:Actions_do()
	return actions_do(self.action)
end
function RuleType:CheckSyntax()
	local tester = check_action_syntax(self.action) and check_trigger_syntax(self.trigger)
	return tester
end
function RuleType:New(o)
	o=o or {};
	setmetatable(o,self)
	self.__index= self
	return o
end

--functions
function CreateRule(trigger,action)
	local _trigger
	local _action
	if type(trigger)=="table" then
		_trigger=TriggerType:New(trigger)
	else
		if type(trigger) == "string" and trigger == "Always" then
			--This one is fine
		else
			print("This trigger looks invalid.  Perhaps you forgot to put {} arount it?")
			print("Trigger="..genstring(trigger))
		end
		_trigger=TriggerType:New( { trigger } )
	end
	--print (genstring(_trigger))
	if type(action) == "table" then
		_action=ActionType:New(action)
	else
		if type(action) == "string" and trigger == "EndGame" then
			--This one is fine
		else
			print("This action looks invalid.  Perhaps you forgot to put {} arount it?")
			print("Action="..genstring(action))
		end
		_action=ActionType:New({action})
	end
	--print (genstring(_action))
	local _rule=RuleType:New( {trigger=_trigger, action=_action} )
	if RuleArray == nil then
		RuleArray={}
	end
	RuleArray[table.getn(RuleArray)+1]= _rule
	--now we need to store it in our array
end

function pre_init()
--Add a "func" parameter which is a pointer to a function
action_syntax={ 
	commands=[["Teleport|Destroy|Save|Squad|Build|FOW|Restrict|Message|Command|Resources|Restrict|
			 Unrestrict|Grant|Base|DoIntel|SetTimer|LoadProfile|SaveProfile|Uncapture|Setrace|Resources|
			 SetInvulnerable|ChangeGameType|KillPlayer|EndGame|SetWave|EndWave|SetSaved|DestroySGroup|
			 DestroyEGroup|CreateSGroup|CreateEGroup|StartVPlayer|DeSpawn|ReSpawn|HonorGuardPlus|
			 ObjectiveComplete|ChangeOwnership|Scatter|Summon|JumpToWave|BuildingDoDefault|Patrol|
			 AddVPlayer|Damage|Set|Function|SetStance|SeedRandom|LockFromAI|FX"]],
	Teleport={ params={"PLAYER","MARKER1","MARKER2"}, PLAYER="action_who",MARKER1="action_from",MARKER2="action_to",func=f_teleport},
	Scatter={params={"PLAYER","MARKER"}, PLAYER="action_who", MARKER="action_where", func=f_scatter},
	Summon={params={"SGROUP","MARKER"}, SGROUP="action_who", MARKER="action_where", func=f_summon},
	Patrol={params={"SGROUP","TYPE"}, SGROUP="action_who", TYPE="action_where", func=f_patrol},
	Destroy={params={"PLAYER","TYPE"}, PLAYER="action_who", TYPE="action_where", func=f_destroy},
	Damage={params={"PLAYER","MARKER","AMOUNT"}, PLAYER="action_who", MARKER="action_where", AMOUNT="action_what", func=f_damage},
	ChangeOwnership={params={"PLAYER","WHAT"}, PLAYER="action_who", WHAT="action_what",func=f_change_ownership},
	EndGame={params={}, func=f_end_game},
	BuildingDoDefault={params={"EGROUP","GROUP"},EGROUP="action_who", GROUP="action_where", func=f_building_do_default},
	JumpToWave={params={"NUMBER"}, NUMBER="action_what", func=f_jump_to_wave},
	DoIntel={params={"INTEL"}, INTEL="intel", func=f_do_intel},
	Command={params={"WHO","WHAT","WHERE"}, WHO="action_who", WHAT="action_what", WHERE="action_where", func=f_command},
	FOW={params={"TYPE","WHERE"}, TYPE="action_what", WHERE="action_where",func=f_fow},
	AddVPlayer={params={"LOCATION","RACE"}, RACE="action_what", LOCATION="action_where", func=f_add_vplayer},
	DeSpawn={params={"GROUP"}, GROUP="action_what", func=f_despawn},
	Function={params={"FUNCTION"}, FUNCTION="action_func", func=f_function},
	ReSpawn={params={"GROUP","WHERE"}, GROUP="action_what", WHERE="action_where", func=f_respawn},
	SetInvulnerable={params={"WHAT","WHAT_TO"}, WHAT="action_what",WHAT_TO="action_to", func=f_set_invulnerable},
	LockFromAI={params={"WHAT","WHAT_TO"}, WHAT="action_what",WHAT_TO="action_to", func=f_lock_from_ai},
	CreateSGroup={params={"WHO","WHAT","SGROUP"}, WHO="action_who",WHAT="action_what",SGROUP="group_name", func=f_create_sgroup},
	FX={params={"WHO","WHAT"}, WHO="action_who",WHAT="action_what", func=f_fx},
	SetStance={params={"WHO","WHAT"}, WHO="action_who",WHAT="action_what", func=f_set_stance},
	CreateEGroup={params={"WHO","WHAT","EGROUP"}, WHO="action_who",WHAT="action_what",EGROUP="group_name", func=f_create_egroup},
	Save={ params={"PLAYER", "MARKER", {item="WHAT", choices={"BLUEPRINT","EGROUP","SGROUP"}} } , 
		   PLAYER="action_who", MARKER="action_where", WHAT="action_what"},
	Squad={params={"PLAYER", "MARKER","SBLUEPRINT","SGROUP"},  PLAYER="action_who", MARKER="action_where",
		   SBLUEPRINT="action_what", SGROUP="group_name", PassDelay=true,func=f_squad },
	Building={params={"PLAYER", "MARKER","EBLUEPRINT","EGROUP"},  PLAYER="action_who", MARKER="action_where",
		   EBLUEPRINT="action_what", EGROUP="group_name", PassDelay=true,func= f_building },
	Grant={params={"PLAYER","WHAT","AMOUNT","NAME"},  PLAYER="action_who", WHAT="action_what",
		   AMOUNT="action_amount", NAME="action_name", func= f_grant },
	Set={params={"VALUE1","VALUE2"}, VALUE1="variable",VALUE2="value", func=f_set},
	Message={params={"PLAYER","TEXT"}, PLAYER="action_who",TEXT="action_what", func=f_message},
	SeedRandom={params={"VALUE"}, VALUE="action_what", func=f_seed_random},
	Base={ params={"PLAYER", "TYPE", "RACE", "LOCATION"}, PLAYER="action_who", TYPE="action_what", 
		   LOCATION="action_where", RACE="action_race", func=f_base},
}
criteria_syntax={
	commands=[["PointTaken|SgroupExists|EgroupExists|SGroupExists|EGroupExists|IsOwned|Require|
	SgroupDestroyed|EgroupDestroyed|SGroupDestroyed|EGroupDestroyed|BeforeWave|DuringWave|
	NotDuringWave|Always|Proximity|PlayerDead|Timer|Saved|StartGame|PreviouslySaved|
	PreviouslyCompleted|PreviousObjective|TimerFinished|InHonorguard|WaveIs|EProx|Compare"]],
	PointTaken={params={"PLAYER","EGROUP"}, PLAYER="action_who", EGROUP="action_what", func=f_point_taken},
	PlayerDead={params={"PLAYER"}, PLAYER="action_who", func=f_player_dead},
	PlayerAlive={params={"PLAYER"}, PLAYER="action_who", func=f_player_alive},
	Compare={params={"VALUE1","OPERATOR","VALUE2"}, VALUE1="left_side",VALUE2="right_side", OPERATOR="action_operator", func=f_compare},
	Always={params={}, func=f_always},
	Proximity={params={"PLAYER","TYPE"}, PLAYER="action_who", TYPE="action_where", func=f_proximity },
	EProx={params={"PLAYER","TYPE","WHAT"}, PLAYER="action_who", TYPE="action_where", WHAT="action_what", func=f_eprox },
	--In here twice to get the caps worked out (Group capatalized or lowercase)
	EgroupExists={params={"EGROUP"}, EGROUP="action_what", func=f_egroup_exists},
	SgroupExists={params={"SGROUP"}, SGROUP="action_what", func=f_sgroup_exists},
	EGroupExists={params={"EGROUP"}, EGROUP="action_what", func=f_egroup_exists},
	SGroupExists={params={"SGROUP"}, SGROUP="action_what", func=f_sgroup_exists},
	--In here twice to get the caps worked out
	EgroupDestroyed={params={"EGROUP"}, EGROUP="action_what", func=f_egroup_destroyed},
	SgroupDestroyed={params={"SGROUP"}, SGROUP="action_what", func=f_sgroup_destroyed},
	EGroupDestroyed={params={"EGROUP"}, EGROUP="action_what", func=f_egroup_destroyed},
	SGroupDestroyed={params={"SGROUP"}, SGROUP="action_what", func=f_sgroup_destroyed},
	WaveIs={params={"TYPE","NUMBER"}, TYPE="action_operator", NUMBER="action_what", func=f_wave_is},
}
end

function errorout(message)
	--we may want to print a big message if things are really bad
	print(message)
end

function criteria_met(trigger, parse_only)
	return parse_and_execute(trigger, parse_only, criteria_syntax)
end


function actions_do(action, parse_only)
	return parse_and_execute(action, parse_only, action_syntax)
end

function fuzzy_blueprint(tofind, bptype)
	--We are given something that looks like: ~hq
	--We need to pull off the leading ~
	--And return all matching blueprints that have that in the name
	--Only looking at the type (building/squad) specified
	local mylist={}
	local race_array={}
	local k,v
	local looper
	local bpname=""
	--remove the first character
	local mytofind=string.sub(tofind, 0 - (string.len(tofind) - 1) )

	local known_races= {
		"necron_race","space_marine_race","chaos_marine_race",
		"tau_race","guard_race","ork_race","eldar_race",
		"sisters_race","tyranid_race","dark_eldar_race" 
	}
	if bptype == "Squad" or bptype == "squad" or bptype == "all" then
--		print("Checking Squads")
		for k,v in pairs(known_races) do
			--print("Squads Race: "..v)
			race_array=get_squad_race_array(v)
			for looper = 1, ( table.getn(race_array) / 5 ) do
				bpname=race_array[ (looper * 5) -4 ]
				if string.find(bpname, mytofind) then
					--print("Found "..bpname.." matching "..mytofind)
					mylist[ table.getn(mylist) +1 ] = bpname 
				end
			end
		end
	end
	if bptype == "Building" or bptype == "building" or bptype == "all" then
--		print("Checking Buildings")
		for k,v in pairs(known_races) do
			race_array=get_building_race_array(v)
--			print("Buildings Race: "..v)
			for looper = 1, ( table.getn(race_array) / 3 ) do
				bpname=race_array[ (looper * 3) - 2 ]
				if string.find(bpname, mytofind) then
					--print("Found "..bpname.." matching "..mytofind)
					mylist[ table.getn(mylist) + 1 ] = bpname 
				end
			end
		end
	end
	if mylist ~= nil then
		mylist.operator="or"
	end
	print("Fuzzy list="..genstring(mylist))
	return mylist
end

function parse_and_execute(command_string, parse_only, syntax_array )
	local k
	local v
	local shifter=0
	local mynot=false
	local response=true
	local tresponse=false
	local alltables=true
	local error_condition=false
	local Command={
		command_string_who="",
		command_string_what="",
		command_string_where="",
		command_string_from="",
		command_string_to="",
	}
	local TempCommand={}
	if command_string == nil then
		--nothing to do
		return true
	end
	if command_string.counter == nil then
		command_string.counter=0
	end
	if command_string.limit == nil then
		command_string.limit=-1
	end
	if command_string.once ~= nil and command_string.once then
		command_string.limit=1
		command_string.once=false
	end
	if command_string.delay == nil then
		command_string.delay =0
	end
	if type(command_string)== "string" then
		--call ourselves with the command_string in a table.  Makes programming easier
		return parse_and_execute( { command_string }, parse_only,syntax_array )
	elseif type(command_string) =="table" then
--		print("looking at command "..genstring(command_string))
		--Here is where most of the work is
		for v, k in ipairs( command_string ) do
			--the "operator" is not considered in this case
			if v~="operator" and type( k ) ~= "table" and k ~= "not" then
				alltables=false
			end
		end
		if alltables then
--			print("alltables")
			--We cannot have a command that is a table.
			--So we assume all tables means a list of commands
			if command_string.operator == "and" then
				response=true
			else
				response=false
			end
			if command_string.limit==0 then
				return false
			end
			if command_string.once then
				--We do it once
				command_string.once=false
				command_string.limit = 1
			end
			if command_string.counter > 0 then
				command_string.counter = command_string.counter -1
				return false
			else
				--The delay is up, now we do it
				command_string.counter = command_string.delay
				for v, k in ipairs( command_string ) do
					if command_string.operator=="and" then
						response=response and parse_and_execute(k, parse_only, syntax_array)
					elseif command_string.operator=="or" then
						response=response or parse_and_execute(k, parse_only, syntax_array)
					else
						--If there is no operator (and/or) we assume we need to run everything.
						--An and or or operator can be short-circuited.
						tresponse=parse_and_execute(k, parse_only, syntax_array)
						response=response or tresponse
					end
				end
			end
			--If we have a limit, we only decrease that limit when we do it
			if command_string.limit > 0 and response then
				command_string.limit= command_string.limit -1
			end
			return response
		else
			local origk
			--Here we start to parse everything
			--At this time, we are a table consisting of a command and possible parameters.
			for v, origk in pairs(command_string) do
				--process any computed fields
				k=getval(origk)
				--print("orig val: "..genstring(origk).." modified: "..genstring(k))
				if k ~= origk then
					--If we are supposed to replace the original value with the computed one, do so.
					--This may optimize things if we have a lot of complexities
					if type(origk) == "table" and origk.optimize ~= nil and (origk.optimize == "replace" or origk.optimize == "Replace") then
						command_string[v] = k
					end
				end
				if (type(v)=="number" and v == 1) or (command_string[1]=="not" and type(v)=="number" and v==2) then
					shifter=shifter+1
					--this is the command.  Check to see if it is valid
					if k=="not" then
						print("found a not")
						mynot=true
					else
						--print("looking at command "..k)
						if string.find(k, "|") then
							error_condition=true
							errorout("The pipe character (|) is not allowed in a command")
						end
						if string.find(syntax_array.commands, k) then
							--We have a valid command.  If the parameters are correct, we are set to go
							Command.command=k
						else
							--We did not find the command in our list.
							error_condition=true
							errorout('The command: "'..k..'" is invalid' )
						end
					end
				elseif type(v) == "number" then
					if Command.command ~= nil then
						local var=""
						--This is not the first parameter.  Now we start pulling out parameters from the list
						if syntax_array[Command.command]~= nil and syntax_array[Command.command].params ~= nil then
							--Pull out the variable type for the parameter
							var=syntax_array[Command.command].params[v - shifter]
							--var should now = something like: PLAYER, MARKER, BLUEPRINT, *, SGROUP, EGROUP
							--(it could be an array of options.  But this code does not deal with that yet)
							if is_valid_type(k, var, true) then
								--if it is valid, we want to do the following
								debug_print("setting "..var.." to be "..genstring(k))
								TempCommand[var]=k
							else
								print("Not valid type: looking it up...")
								--It is not valid.  Yet.  Perhaps we need to do something different with it
								-- If it is a blueprint that begins with ~ then we search for all blueprints
								-- and replace it with the possible list of them.
								if type(k)=="string" and string.sub(k,1,1) == "~" then
									--This could be eblueprint, sblueprint, or blueprint
									--Right now, look it up from the tables we have
									
									--use this: fuzzy_blueprint(k, bptype)
									--fuzzy_blueprint(k, "Squad")
									--fuzzy_blueprint(k, "Building")
									if var == "BLUEPRINT" then
										command_string[ v ] = fuzzy_blueprint(k, "all")
									elseif var == "SBLUEPRINT" then
										command_string[ v ] = fuzzy_blueprint(k, "Squad")
										print("Searching for Squad Blueprint using 'Squad'")
									elseif var == "EBLUEPRINT" then
										print("Searching for Squad Blueprint using 'Building'")
										command_string[ v ] = fuzzy_blueprint(k, "Building")
									else
										print("unknown blueprint type: "..var.." using 'all'")
										--many times the "type" may be something much more generic
										--of which a blueprint is one possibility
										command_string[ v ] = fuzzy_blueprint(k, "all")
									end
									if TempCommand[var] == nil then
										TempCommand[var]={}
									end
									TempCommand[var]=command_string[ v ]
									print("Fuzzy Blueprint Found: "..genstring(command_string[ v ]))
								elseif type(k)=="string" and string.find(k,"|") then
									--check if we are looking for race or blueprint
									local ormaster=k
									if var=="BLUEPRINT" or var=="SBLUEPRINT" or var=="EBLUEPRINT" or var=="WHAT" or var=="WHO" then
										k=get_first_blueprint(k)
									elseif var == "RACE" then
										k=get_first_race_name(k)
									end
									if is_valid_type(k, var, true) then
										--if it is valid, we want to do the following
										debug_print("found and setting "..var.." to be "..genstring(k))
										TempCommand[var]=k
									else
										print ("WARNING: Unable to find a valid "..var.." in "..ormaster)
									end
								elseif type(k) == "table" then
									local l, m
									for l, m in ipairs(k) do
										if command_string[ v ] == nil then
											command_string[ v ]={}
										end
										if type(m) == "string" and string.find(m,"~") then
											if var == "BLUEPRINT" then
												command_string[ v ][l] = fuzzy_blueprint(m, "all")
											elseif var == "SBLUEPRINT" then
												print("Searching for Squad Blueprint using 'Squad'")
												command_string[ v ][l] = fuzzy_blueprint(m, "Squad")
											elseif var == "EBLUEPRINT" then
												print("Searching for Squad Blueprint using 'Building'")
												command_string[ v ][l] = fuzzy_blueprint(m, "Building")
											else
												--many times the "type" may be something much more generic
												--of which a blueprint is one possibility
												print("unknown blueprint type: "..var.." using 'all'")
												command_string[ v ][l] = fuzzy_blueprint(m, "all")
											end
											print("Fuzzy Blueprint Found: "..genstring(command_string[ v ][l]))
										end
										if var == nil then
											print("ERROR!  Invalid syntax for command!")
											print(genstring(command_string))
											print("The next thing you will see is a SCAR error.")
										end
										if TempCommand[var] == nil then
											TempCommand[var]={}
										end
										TempCommand[var][l] = command_string[ v ][l]
									end
								else
									print(genstring(k).."was invalid")
								end
							end
						end
					else
						print("command was nil")
					end
				else
					--This is what happens if you pass in a named parameter.  For example "message" in
					--{ "Scatter","Player1",message="Can't go there!" }
					Command[v]=k
				end
			end
			--Now we want to take our variables and put them into Command
			if Command.command ~= nil then
				if syntax_array[Command.command] ~= nil then
					for v, k in ipairs(syntax_array[Command.command].params) do
						--k will be PLAYER, MARKER, Etc.
						--command_string_syntax[command_string_what][k]=command_string_what|command_string_where|etc
						--TempCommand[k]=the parameter passed in
						--print("k="..k.."  "..genstring(syntax_array[Command.command]))
						if syntax_array[Command.command][k] ~= nil then
							Command[syntax_array[Command.command][k]]=TempCommand[k]
						end
					end
				end
			end
		end
	end
	if Command.command == nil then 
		return false
	end
	--We now have all our variables set.  Now we prepare to execute it
	--first, prepare timers and other info
	Command.command_table=command_string
	if Command.once then
		Command.once=false
		Command.limit=1
	end
	if Command.limit == 0 then
		return false
	end
	if syntax_array[Command.command].PassDelay == nil then
		syntax_array[Command.command].PassDelay=false
	end
	if not error_condition and not parse_only and Command.command ~=nil then
		if not syntax_array[Command.command].PassDelay and command_string.counter > 0 then
			command_string.counter=command_string.counter -1
		else
			if not syntax_array[Command.command].PassDelay then
				--command_string.counter=command_string.delay
				if type(command_string.delay) == "table" then
					if command_string.next_delay == nil then
						command_string.next_delay=0
					end
					command_string.counter=command_string.delay[command_string.next_delay]
					command_string.next_delay=command_string.next_delay+1
					if command_string.next_delay > table.getn(command_string.delay) then
						command_string.next_delay=table.getn(command_string.delay)
					end
				else
					command_string.counter=command_string.delay
				end

			end
			local cmdstr=genstring(Command.command)
			if Command.action_who ~= nil then
				cmdstr=cmdstr.. " WHO="..genstring(Command.action_who)
			end
			if Command.action_what ~= nil then
				cmdstr=cmdstr.. " WHAT="..genstring(Command.action_what)
			end
			if Command.action_where ~= nil then
				cmdstr=cmdstr.. " WHERE="..genstring(Command.action_where)
			end
			debug_print("Command to run: "..cmdstr)
			if command_string.limit == -1 or command_string.limit > 0 then
				if syntax_array[Command.command].func ~= nil then
					--here we would loop for each player that we are supposed to check so the 
					--func only needs to do it for one
					results=syntax_array[Command.command].func(Command)
					print("Command run: "..cmdstr.." returned: "..genstring(results))
					if mynot then
						results= not results
						print("We have a 'not', so returning opposite... "..genstring(results))
					end
					if results and command_string.limit > 0 then
						debug_print("subtracting limit "..command_string.limit)
						command_string.limit=command_string.limit-1
						debug_print("new limit "..command_string.limit)
					end
					return results
				else
					error_condition=true
					errorout("The command was fine, but no function to process it! "..genstring(command_string))
					errorout("The syntax for "..genstring(Command.command).." was: "..genstring(syntax_array[Command.command]))
				end
			end
		end
	end
	return error_condition
end

function is_valid_type( my_var, check_type, doerror )
	local isit=false
	local harderror=false
	local tmp_type=check_type
	--Pull off any trailing number (it may be MARKER1, MARKER2, etc) so all we have is the "type"
	--print("checking type of "..genstring(my_var).." to be "..check_type)
	if type(check_type) ~= "string" then
		return false
	end
	local posnum=string.find(check_type,"%d")
	if type(posnum)=="number" and posnum > 0 then
		--print("found a number!"..posnum)
		tmp_type=string.sub(check_type,1,posnum - 1)
	end
	--print ("newtype: "..genstring(tmp_type))
	--Then, check if it is valid, using EBP_Exists, SBP_Exists, etc
	if type(my_var) == "table" and my_var[1] ~= "OwnerOf" then
		local k,v 
		isit=true
		for k,v in ipairs(my_var) do
			isit=isit and is_valid_type(v,check_type, doerror)
		end
		if not isit then
			return false
		end
	else
		if type(my_var)== "string" and string.find(my_var,"^~") then
			--We found a ~ at the beginning of a string.  It is "fuzzy".
			--we fail here, and it is replaced
			isit=false
			harderror=true
			print("We have a fuzzy something")
		elseif tmp_type == "MARKER" then
			if type(my_var) == "string" and Marker_Exists( my_var, "basic_marker" ) then
				isit=true
			elseif is_position( my_var ) then
				isit=true
			else
				isit=false
				harderror=true
			end
		elseif tmp_type == "NUMBER" then
			if type(my_var) == "number" then
				isit=true
			end
		elseif tmp_type == "PLAYER" then
			if type(my_var)=="string" then
				--proper "players" are "player", "player1", "team1", "enemy"
				local valid="player|player1|player2|player3|player4|player5|player6|player7|player8|team1|team2|team3"
				valid=valid.."|team4|team5|team6|team7|team8|enemy|vplayer|any|all|anyone"
				local test_var=my_var
				if string.find(my_var,"vplayer") then
					test_var="vplayer"
				end
				if string.find(valid,test_var) then
					isit=true
				end
			elseif type(my_var) == "number" then
				if my_var > 1000 or (my_var < 8 and my_var >=0 ) then
					--these numbers should actually be something like 1001
					--but they may also be 0-7
					isit=true
				else
					isit=false
				end
			elseif type(my_var) == "table" and my_var[1]=="OwnerOf" and table.getn(my_var) == 2 then
				--This allows us to substitute something like
				--{ "OwnerOf", "mypoint" }
				--{ "OwnerOf", "myegroup" }
				--{ "OwnerOf", "mysgroup" }
				isit=true
			else
				isit=false
			end
		elseif tmp_type == "INTEL" then
			if type(my_var) == "function" then
				isit=true
			elseif type(my_var) == "table" then
				isit=true
			else
				harderror=true
			end
		elseif tmp_type == "TYPE" then
			--Sadly, we do not have a good way to know what we are looking for.  Allow it.
			isit=true
		elseif tmp_type == "RACE" then
			if string.find([["necron_race|space_marine_race|chaos_marine_race|tao_race|guard_race|ork_race|
				eldar_race|sisters_race|tyranid_race|dark_eldar_race|custom1|custom2|default"]],my_var) then
				isit=true
			end
		elseif tmp_type == "OPERATOR" then
			if string.find("=|>|<|!=|~=|<>|?",my_var) then
				isit=true
			else
				harderror=true
			end
		elseif tmp_type == "SGROUP" then
			if SGroup_Exists(my_var) then
				isit=true
			end
			--egroups and sgroups can be generated during game play.  No hard error.
		elseif tmp_type == "EGROUP" then
			if EGroup_Exists(my_var) then
				isit=true
			end
		elseif tmp_type == "LOCATION" then
			my_var=""..my_var
			if Marker_Exists(my_var,"basic_marker") then
				isit=true
			elseif Marker_Exists(my_var.."-hq-1", "basic_marker") then
				isit=true
			elseif Marker_Exists(my_var.."-webway-1","basic_marker") then 
				isit=true
			elseif Marker_Exists(my_var.."-military-1", "basic_marker") then
				isit=true
			elseif Marker_Exists(my_var.."-turret-1", "basic_marker") then
				isit=true
			elseif Marker_Exists(my_var.."-minefield-1", "basic_marker") then
				isit=true
			elseif is_position(my_var) then
				isit=true
			else
				harderror=true
			end
			--egroups and sgroups can be generated during game play.  No hard error.
		elseif tmp_type == "SBLUEPRINT" then
			if SBP_Exists(my_var) then
				isit=true
			else
				harderror=true
			end
		elseif tmp_type == "WHERE" then
			if is_valid_type( my_var, "LOCATION", false ) or is_valid_type( my_var, "SGROUP", false ) or is_valid_type( my_var, "EGROUP", false ) then
				isit=true
			else
				harderror=true
			end
		elseif tmp_type == "EBLUEPRINT" then
			if EBP_Exists(my_var) then
				isit=true
			else
				harderror=true
			end
		elseif tmp_type == "BLUEPRINT" then
			--if it is either a squad or building blueprint
			if is_valid_type( my_var, "EBLUEPRINT", false ) or is_valid_type( my_var, "SBLUEPRINT", false ) then
				isit=true
			else
				harderror=true
			end
		elseif tmp_type == "WHAT" then
			--if it is either a squad or building blueprint
			if type(my_var) == "string" and string.find(my_var, "~") then
				--We want it to fail here, though it could be a fuzzy blueprint
				isit=false
				harderror=true
			elseif is_valid_type( my_var, "BLUEPRINT", false ) or is_valid_type( my_var, "SGROUP", false ) or is_valid_type( my_var, "EGROUP", false ) then
				isit=true
			else
				harderror=true
			end
		elseif tmp_type == "FUNCTION" then
			--is it a function?
			if type(my_var) == "function" then
				isit = true
			else
				harderror=true
			end
		elseif tmp_type == "VALUE" then
			--a value is basically anything
			isit = true
		elseif tmp_type == "TEXT" then
			if type(my_var)=="string" then
				isit = true
			else
				harderror=true
			end
		elseif tmp_type == "WHO" then
			--if it is either a squad or building blueprint
			if is_valid_type( my_var, "PLAYER", false ) or is_valid_type( my_var, "SGROUP", false ) or is_valid_type( my_var, "EGROUP", false ) then
				isit=true
			else
				harderror=true
			end
		end
		if not isit and harderror then
			--only print the error if we need to
			if doerror then
				errorout("ERROR: "..genstring(my_var).." is not valid or of type "..tmp_type)
			end
			return false
		elseif not isit then
			--The type may be correct, but we cannot verify it
			print("WARNING: "..genstring(my_var).." may not be valid or of type "..genstring(tmp_type))
		else 
			debug_print("NOTICE: "..genstring(my_var).." is of type "..genstring(tmp_type))
		end
	end
	return true
end


function randomize_groups(grouplist)
	--This function will receive a list of egroups or sgroups, and randomize them.
	--If the list is mixed (some egroups, some sgroups), it will blow up.
	local tempgroup
	local tempnum
	local k, v
	if type(grouplist) == "table" then
		if table.getn(grouplist) > 1 then
			if EGroup_Exists(grouplist[1]) then
				tempgroup=EGroup_CreateIfNotFound("randomizeGroup")
				EGroup_Clear(tempgroup)
				for k,v in ipairs(grouplist) do
					tempnum=World_GetRand(1, table.getn(grouplist))
					if tempnum ~= k then
						EGroup_AddGroup(tempgroup, EGroup_FromName(v))
						EGroup_Clear(EGroup_FromName(v))
						EGroup_AddGroup(EGroup_FromName(v),EGroup_FromName(grouplist[tempnum]))
						EGroup_Clear(EGroup_FromName(grouplist[tempnum]))
						EGroup_AddGroup(EGroup_FromName(grouplist[tempnum]), tempgroup)
						EGroup_Clear(tempgroup)
					end
				end
				EGroup_Destroy("randomizeGroup")
			elseif SGroup_Exists(grouplist[1]) then
				tempgroup=SGroup_CreateIfNotFound("randomizeGroup")
				SGroup_Clear(tempgroup)
				for k,v in ipairs(grouplist) do
					tempnum=World_GetRand(1, table.getn(grouplist))
					if tempnum ~= k then
						SGroup_AddGroup(tempgroup, SGroup_FromName(v))
						SGroup_Clear(SGroup_FromName(v))
						SGroup_AddGroup(SGroup_FromName(v),SGroup_FromName(grouplist[tempnum]))
						SGroup_Clear(SGroup_FromName(grouplist[tempnum]))
						SGroup_AddGroup(SGroup_FromName(grouplist[tempnum]), tempgroup)
						SGroup_Clear(tempgroup)
					end
				end
				SGroup_Destroy("randomizeGroup")
			end
		end
	end
end

function rnd_pick(list)
	if type(list)=="table" then
		local which=World_GetRand( 1, table.getn(list) )
		return list[which]
	else
		return list
	end
end

--return a marker
function return_marker(Command,which)
	local marker
	if which == nil then
		which = 0
	end
	if which == 0 then
		marker=Command.action_where
	elseif which == 1 then
		marker=Command.action_from
	elseif which == 2 then
		marker=Command.action_to
	else
		marker={}
	end
	if Command.command_table.rotation == nil then
		Command.command_table.rotation="next"
	end
	if type(marker) == "table" and not is_position(marker) then
		if Command.command_table.rotation == "random" then
			return rnd_pick(marker)
		else
			if Command.command_table.position == nil then
				Command.command_table.position = 1
			end
			if Command.command_table.position > table.getn(marker) then
				Command.command_table.position = 1
			end
			local tester=marker[Command.command_table.position]
			Command.command_table.position = Command.command_table.position + 1
			return tester
		end
	else
		return marker
	end
end

function do_all_rules()
	local looper=0
	if RuleArray == nil then
		return false
	end
	local numbero=table.getn(RuleArray)
	if RuleArray ~= nil then
		looper=1
		for looper = 1, numbero do
			if criteria_met(RuleArray[looper].trigger,false, { looper } ) then
				actions_do(RuleArray[looper].action,false, { looper } )
			end
		end
	end
end

function DoItNow(action)
	--generate a temp rule from passed in
	if type(action) == "table" then
		_action=ActionType:New(action)
	else
		if type(action) == "string" and action=="EndGame" then
			--This one works
		else
			print("Action may be invalid.  Did you forget the {}?")
			print("Action="..genstring(action))
		end
		_action=ActionType:New({action})
	end
	print ("Running Action: "..genstring(_action))

	return actions_do(_action, false)
end

function check_action_syntax(action)
	actions_do(action, true )
end

function check_trigger_syntax(trigger)
	criteria_met(trigger, true)
end

function genname(mytable)
	local name=""
	spacer=""
	local k,v 
	for v,k in pairs(mytable) do
		if type(k) == "table" then
			name=name..spacer..genname(k)
		else
			name=name..spacer..k
		end
		spacer="-"
	end
	return name
end

function SGroup_GetPlayers(sgroup)
	--make a list of all the players that own items in the sgroup
	--return a table of player Indexes from g_AllPlayerList
	local playerlist={}
	local getplayer=function( sgroupid, itemindex, squadID )
		playerlist[table.getn(playerlist)+1]=World_GetPlayerIndex( Squad_GetPlayerOwner( squadID ) )
	end
	--This will give us a playerlist that looks like: {1,2,3,4}
	SGroup_ForEach( SGroup_FromName(sgroup), getplayer )
	--now, remove any extra stuff.
	playerlist=Uniqueify(playerlist)
	if genstring(playerlist) == genstring( {} ) then
		return nil
	end
	return playerlist
end

function SGroup_GetTeams(sgroup)
	--make a list of all the teams represented by the sgroup
	--return a list of team numbers (as given in g_AllPlayerList)
	local playerlist=SGroup_GetPlayers(sgroup)
	local teamlist={}
	if playerlist == nil then
		return nil
	end
	for k,v in ipairs(playerlist) do
		teamlist[table.getn(teamlist)+1]=g_AllPlayerList[v].Team
	end
	teamlist=Uniqueify(teamlist)
	if genstring(teamlist) == genstring({}) then
		return nil
	end
	return teamlist
end

function EGroup_GetPlayers(egroup)
	--make a list of all the players that own items in the sgroup
	--return a table of player Indexes from g_AllPlayerList
	local playerlist={}
	local getplayer=function( sgroupid, itemindex, entityID )
		if not Entity_GetWorldOwner( entityID ) then
			playerlist[table.getn(playerlist)+1]=World_GetPlayerIndex( Entity_GetPlayerOwner( entityID ) )
		end
	end
	--This will give us a playerlist that looks like: {1,2,3,4}
	EGroup_ForEach( EGroup_FromName(egroup), getplayer )
	--now, remove any extra stuff.
	playerlist=Uniqueify(playerlist)
	if genstring(playerlist) == genstring( {} ) then
		return nil
	end
	return playerlist
end

function EGroup_GetTeams(egroup)
	--make a list of all the teams represented by the sgroup
	--return a list of team numbers (as given in g_AllPlayerList)
	local playerlist=EGroup_GetPlayers(egroup)
	local teamlist={}
	if playerlist == nil then
		return nil
	end
	for k,v in ipairs(playerlist) do
		teamlist[table.getn(teamlist)+1]=g_AllPlayerList[v].Team
	end
	teamlist=Uniqueify(teamlist)
	if genstring(teamlist) == genstring({}) then
		return nil
	end
	return teamlist
end

function is_position(item)
	answer=false
	local metatable
--	print("is_position: looking at "..genstring(item))
	if type(item)=="table" then
--		print("Is table")
		metatable=getmetatable(item)
--		print("is_position: metatable="..genstring(metatable))
		if metatable ~= nil and metatable.__scartype=="simscarpos" then
--			print("is position")
			answer=true
		end
		if item ~= nil and type(item.x) == "number" and type(item.y) == "number" and type(item.z) == "number" then
--			print("found a position")
			answer=true
		end
	end
	return answer
end



function cputest()
	local t_val = {3,8,10,12,14}
	local difs = {"easy", "standard", "hard", "harder", "insane"}
	local count = World_GetPlayerCount()
	for i = 1, count do
		local player = World_GetPlayerAt(i-1)
		if Community_Cpu_IsCpuPlayer(player) == false then
			human = player
			if World_DoesRaceUseRequisition(Player_GetRace(player   )) == true then
				res = RT_Requisition
				hum = 1
			else
				res = RT_Power
				hum = 0.5
			end
			humgath = (Stats_PlayerResGathered(Player_GetID(human), res))
			break
		end
	end
	for i = 1, count do
		local player = World_GetPlayerAt(i-1)
		if Player_GetID(player) ~= Player_GetID(human)
		and Community_Cpu_IsCpuPlayer(player) == true then
			if World_DoesRaceUseRequisition(Player_GetRace(player  )) == true then
				res = RT_Requisition
				rac = 1
			else
				res = RT_Power
				rac =2
			end
			gathered = (Stats_PlayerResGathered(Player_GetID(player), res))
			for j = 1, 5 do
				if math.ceil((gathered/humgath)*10*rac*hum) == t_val[j]
				or math.floor((gathered/humgath)*10*rac*hum)== t_val[j]  then
					difficulty = difs[j]
				break
				end
			end
			break
		end
	end
	if difficulty == nil then
		difficulty = "unknown"
	end
	print ("difficulty = ".. difficulty)
end

--[[LIBRARY]]

--Can be called at 5 seconds, returns a string
function Community_Cpu_GetDifficulty()
	--returns nil if it has not yet been computed
	return (difficulty)
end

--change any names before using this
function Community_Cpu_IsCpuPlayer(playerid)
	local playername = Player_GetDisplayName(playerid)[1]
	if string.sub(playername, 1, 8) ~= "Computer" then
		return (false)
	else
		return (true)
	end
end


function awards()
	local k,v, player, playerID
	local sprees={"Dominating","Rampage!","Killing Spree!","Unstoppable","Godlike","WICKED SICK!"}
	local spree_count={5, 10, 15, 20, 25, 30}
	local spree_death_count=3
	if g_player_awards == nil then
		g_player_awards = {}
	end
	for player = 0, World_GetPlayerCount() -1 do
		print("Checking awards for player "..player)
		playerID=World_GetPlayerAt(player)
		if Player_IsAlive(playerID) then
			if g_player_awards[player] == nil then
				g_player_awards[player]={}
			end
			print("kills for player "..player..": "..genstring(Stats_PlayerUnitsKilled( Player_GetID(playerID) )))
			print("lost for player "..player..": "..genstring(Stats_PlayerUnitsLost( Player_GetID(playerID) )))
			if g_player_awards.first_blood == nil and  Stats_PlayerUnitsKilled( Player_GetID(playerID) ) > 0 then
				g_player_awards.first_blood=player
				g_player_awards[player].first_blood=1
				queue_message( {player, "First Blood!" })
				print ("AWARD: FIRST BLOOD!")
			end
			--Num kills in a short period of time (kills)
			--double kill
			--monster-kill
			--multi-kill
			--mega-kill
			--ultra-kill
			--LUDICROUS KILL!
			--Holy Cow!
			
			--Num kills in a row with no deaths (spree)
			if g_player_awards[player].spree == nil then
				g_player_awards[player].spree={}
				g_player_awards[player].spree.base_kills=0
				g_player_awards[player].spree.base_deaths=0
				g_player_awards[player].spree.award_level=0
				g_player_awards[player].spree.award={}
				g_player_awards[player].spree.next_kill_amount=spree_count[1]
			end
			if g_player_awards[player].spree.base_deaths + spree_death_count <= Stats_PlayerUnitsLost( Player_GetID(playerID) ) then
				--The player lost his award.  For each run, he only keeps the highest one attained.
				--So we grant it to him when he loses it (or, when he gains the last one multiple times)
				--If the award was the last one we know about, we already awarded it to them.
				if g_player_awards[player].spree.award_level ~= table.getn(sprees) then
					if g_player_awards[player].spree.award[g_player_awards[player].spree.award_level] == nil then
						g_player_awards[player].spree.award[g_player_awards[player].spree.award_level]=0
					end
					g_player_awards[player].spree.award[g_player_awards[player].spree.award_level]=g_player_awards[player].spree.award[g_player_awards[player].spree.award_level] + 1
				end
				g_player_awards[player].spree.base_kills=Stats_PlayerUnitsKilled( Player_GetID(playerID) )
				g_player_awards[player].spree.base_deaths=Stats_PlayerUnitsLost( Player_GetID(playerID) )
				g_player_awards[player].spree.award_level=0
				g_player_awards[player].spree.next_kill_amount=spree_count[1]
			elseif g_player_awards[player].spree.base_kills + spree_count[g_player_awards[player].spree.award_level + 1] < Stats_PlayerUnitsKilled( Player_GetID(playerID) ) then
				print("award_level: "..g_player_awards[player].spree.award_level) 
				while g_player_awards[player].spree.award_level < table.getn(sprees) and
					g_player_awards[player].spree.base_kills + spree_count[g_player_awards[player].spree.award_level + 1] < Stats_PlayerUnitsKilled( Player_GetID(playerID) ) do
					g_player_awards[player].spree.award_level=g_player_awards[player].spree.award_level + 1
				end
				queue_message( {player, sprees[g_player_awards[player].spree.award_level] })
				print ("AWARD: "..genstring(sprees[g_player_awards[player].spree.award_level]))
				if g_player_awards[player].spree.award_level == table.getn(sprees) then
					if g_player_awards[player].spree.award[g_player_awards[player].spree.award_level] == nil then
						g_player_awards[player].spree.award[g_player_awards[player].spree.award_level]=0
					end
					--We do not have awards higher than this.  Loop.  Repeat last #
					g_player_awards[player].spree.base_kills=g_player_awards[player].spree.base_kills + spree_count[g_player_awards[player].spree.award_level]
					--Award them this award for each second they keep it.
					g_player_awards[player].spree.award[g_player_awards[player].spree.award_level]=g_player_awards[player].spree.award[g_player_awards[player].spree.award_level] + 1
				end
			end
		end
	end
end

function gametime()
	local mytime=World_GetGameTime()
	local hours=math.floor(mytime/3600)
	mytime=mytime - (hours * 3600)
	local minutes=math.floor(mytime/60)
	mytime=mytime - (minutes * 60)
	local seconds= mytime
	local time=""
	if hours > 0 then 
		time=string.format("Hours: %2.0f Minutes: %3.0f Seconds: %2.0f",hours,minutes,seconds)
	else
		time=string.format("Minutes: %3.0f Seconds: %2.0f",minutes,seconds)
	end
print("Someone asked for Time: "..time)
	return time
end

Rule_AddOneShot(cputest, 4)	--This community SCAR code to test the difficulty was coded by incarnate - Thanks!

function OnInit( )
	g_end_time=0  --When this is set > 0 then the end of game countown occurs
	g_num_saved=0

	if EVENTS == nil then
		EVENTS={}
	end

	EVENTS.PlayConversation=function()
		conv = CONVERSTATION
		print("PlayConversation START")
		for i,v in ipairs(conv) do
			CTRL.Actor_PlaySpeech( v.speaker, v.message)
			CTRL.WAIT()
		end
		print("PlayConversation END")
	end

--	Util_StartIntel     ( EVENTS.INTEL1 )
    pre_init()
	build_player_list()
	if localinit ~= nil then
		localinit()
	end
	print ("Lua version: ".._VERSION)
	if g_debug == nil then
		g_debug = false
	end
	if g_DestroyHQ == nil then 
		g_DestroyHQ = true
	end
	if g_MapConfiguredFor == nil then
		g_MapConfiguredFor = 3
	end
	
	if g_AutoRecompute == nil then 
		g_AutoRecompute=true
	end
	if g_max_locations == nil then 
		g_max_locations=14
	end
	if g_cycle_webways == nil then
		g_cycle_webways=true
	end
	if g_end_game_after_waves == nil then 
		g_end_game_after_waves=true
	end
	if g_end_game_when_saved == nil then 
		g_end_game_when_saved=-1
	end
	--compatibility.  Here we replace race_names and blueprints if there are 
	--multiple of them on a line.  Like "sisters_race|necron_race|guard_race"
	local looper
	local base
	local orig
	local result
	for looper = 1, (table.getn(g_WaveActions) / 7) do
		base=(looper*7)-6
		--g_WaveActions.  position 6 could be race or blueprint
		orig=g_WaveActions[ base + 5 ]
		result=orig
		if string.find(orig, "|") then
			result=get_first_blueprint(orig)
			if result == "" then
				result=get_first_race_name(orig)
			end
		end
		if result ~= "" and result ~= nil then
			g_WaveActions[ base + 5 ] = result
		end
		--g_WaveActions.  position 5 could be race or blueprint
		orig=g_WaveActions[ base + 4 ]
		result=orig
		if string.find(orig, "|") then
			result=get_first_blueprint(orig)
			if result == "" then
				result=get_first_race_name(orig)
			end
		end
		if result ~= "" and result ~= nil then
			g_WaveActions[ base + 4 ] = result
		end
	end
	--Compatibility for the g_Bonus array
	for looper = 1, (table.getn(g_Bonus) / 6) do
		base=(looper*6)-5
		--g_Bonus.  position 3 could be blueprint
		orig=g_Bonus[ base + 2 ]
		result=orig
		if string.find(orig, "|") then
			result=get_first_blueprint(orig)
		end
		if result ~= "" and result ~= nil then
			g_Bonus[ base + 2 ] = result
		end
	end
	--g_GamePlay compatibility
	for looper = 1, (table.getn(g_GamePlay) / 7) do
		base=(looper*7)-6
		--g_WaveActions.  position 6 could be race or blueprint
		orig=g_GamePlay[ base ]
		result=orig
		if string.find(orig, "|") then
			result=get_first_race_name(orig)
		end
		if result ~= "" and result ~= nil then
			g_GamePlay[ base ] = result
		end
	end
	g_tempassert=""
	--g_testvar=PlayerProfile_GetVar("testvar")
	--print("Test variable from profile="..g_testvar)
	--g_testvar=g_testvar.."X"
	--PlayerProfile_SetVar("testvar",g_testvar)

--Code to see if various functions exist in DOW Lua
--for k,v in pairs(_G) do
--	t=big_genstring(v,0)
--	if string.find(k,"_t_") or string.find(k,"Restrictions") then
--	if string.find(k,"Player2") then
--		t=big_genstring(v,0)
--		print("String found..")
--		print (k, v)
--		print (t)
--	end
--	if string.find(k,"assert") or string.find(k,"Assert") then
--		print("String found..")
--		print (k, v)
--	end
--end

--	timtest={ {"1-test1","1-test2","1-test3"}, "2-wholetest",{ { "3-test1a","3-test1b"},"3-test2"}, a="Tester", "test4"}
--	timtest2={}
--	g_testvar="g_testarray = "..genstring(timtest)
--	testarray={}
--	g_testvar='g_testarray={"test1","test2","test3"}'
--	print ("timtest="..timtest)
--	assert(loadstring(g_testvar))()
--	print ("testvar="..g_testvar)
--for k,v in ipairs(g_testarray) do
--	if type(v) ~= "table" then
--		print (k.."->"..v)
--	else
--		print (k.."-> table")
--	end
--end
--print(genscarerror{here})
	recompute_difficulty()
	print("Player1Type: "..genstring(getval({"PlayerType","player1"})))
	print("Player1Name: "..genstring(getval({"PlayerName","player1"})))
	print("Player2Type: "..genstring(getval({"PlayerType","player2"})))
	print("Player2Name: "..genstring(getval({"PlayerName","player2"})))
	print("Player8Type: "..genstring(getval({"PlayerType","player8"})))
	print("Player8Name: "..genstring(getval({"PlayerName","player8"})))
	print("num 0: "..genstring(getval(0)))
	print("location: "..genstring(getval("location")))
	print("sgroup: "..genstring(getval("sgroup")))
	print("egroup: "..genstring(getval("egroup")))
	print("command: "..genstring(getval({"Squad","player1","myblueprint","mysquad",{"PlayerName","player1"}, message="test"})))
	g_testmessage_no = 0
	g_hasbeenrandomized=false
--	tmp_squadID=SGroup_GetSpawnedSquadAt( "othergroup", 1 )
--	print("a squadid looks like: "..genstring(tmp_squadID))
	--a squadid looks like { id=50016 }
	print("OnInit")
--	print(genstring(getnth("necron_race|eldar_race|default|custom1_race|chaos_temple",4)))
--	print(genstring(getnth("ooga booga||rapid|default|chaos_temple",4)))
--	print(genstring(getnth("ooga booga||rapid|default|chaos_temple",5)))
	build_building_lists()
	g_enemy_scheduled=false
	g_wave_timer_max=60   --Number of seconds between waves.
	if g_debug == true then 
		g_wave_timer_max = 10
	end
	m_messagerule={}
	m_messagepos={}
	g_alive_enemies=0
	local looper=0
	g_end_wave=0
	for looper = 1, (table.getn(g_GamePlay)/8) do
		if g_GamePlay[(looper * 8) - 7] > g_end_wave then
			g_end_wave = g_GamePlay[(looper * 8) - 7]
		end
	end
	g_ActionDelay={}
	for looper = 1, (table.getn(g_WaveActions) / 7) do
		g_ActionDelay[looper]=0
	end
	g_BonusDelay={}
	g_DeadPlayers={}
	for looper = 1, (table.getn(g_Bonus) / 6) do
		g_BonusDelay[looper]=0
	end
	--Change the enemy's limits so that they are more powerful
	--	increase_caps(g_Player2, 15)
	--	is_position(World_Pos(0,0,0))
	--print ("A position looks like: "..genstring(World_Pos(0,0,0)))
	--print ("A position is of type: "..type(World_Pos(0,0,0)))
	--local temper=getmetatable(World_Pos(0,0,0))
	--if getmetatable(World_Pos(0,0,0)) ~= nil then
	--	print("get metatable returned something")
	--end
	--print ("metatable is.."..genstring(temper))
	Rule_AddInterval(game_control, 1)
	if g_do_awards ~= nil and g_do_awards == true then
		Rule_AddInterval(awards, 1)
	end
--	local race_name=Player_GetRaceName( g_Player2 )
--	if race_name == "chaos_marine_race" then
--		one_base(g_Player2, "team2-base-1", chaos_buildings)
--	elseif race_name == "eldar_race" then
--		one_base(g_Player2, "team2-base-1", eldar_buildings)
--	elseif race_name == "guard_race" then
--		one_base(g_Player2, "team2-base-1", ig_buildings)
--	elseif race_name == "ork_race" then
--		one_base(g_Player2, "team2-base-1", ork_buildings)
--	elseif race_name == "space_marine_race" then
--		one_base(g_Player2, "team2-base-1", space_marine_buildings)
--	elseif race_name == "necron_race" then
--		one_base(g_Player2, "team2-base-1", necron_buildings)
--	elseif race_name == "tau_race" then
--		one_base(g_Player2, "team2-base-1", tau_buildings)
--	elseif race_name == "custom1" then
--		one_base(g_Player2, "team2-base-1", custom1_buildings)
--	elseif race_name == "custom2" then
--		one_base(g_Player2, "team2-base-1", custom2_buildings)
--	end
end
--Register the OnInit function so it occues at the beginning
Scar_AddInit( OnInit )
